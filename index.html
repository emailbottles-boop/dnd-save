<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The Fractured Sky - Ultimate VTT v3.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0e1a;
            --bg-card: #151928;
            --bg-hover: #1f2537;
            --accent: #8b5cf6;
            --accent-secondary: #ec4899;
            --gold: #fbbf24;
            --text: #e5e7eb;
            --text-dim: #9ca3af;
            --border: rgba(139, 92, 246, 0.2);
            --success: #10b981;
            --danger: #ef4444;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }

        /* HEADER */
        .header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            position: relative;
            z-index: 100;
        }

        .title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .campaign-badge {
            padding: 0.5rem 1rem;
            background: var(--bg-hover);
            border-radius: 8px;
            border: 1px solid var(--border);
            color: var(--gold);
            font-weight: 600;
            font-size: 0.9rem;
        }

        /* BUTTONS */
        .btn {
            padding: 0.6rem 1.2rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            font-family: 'Inter', sans-serif;
        }

        .btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            transform: translateY(-1px);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            border: none;
            color: white;
        }

        .btn-small {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        .btn-success {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }

        /* WELCOME SCREEN */
        .welcome-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f3a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        .welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .welcome-content {
            text-align: center;
            padding: 3rem;
        }

        .welcome-title {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            color: var(--text-dim);
            margin-bottom: 3rem;
        }

        .welcome-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .welcome-btn {
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: 12px;
            cursor: pointer;
            border: none;
            font-weight: 600;
            transition: all 0.3s;
            font-family: 'Inter', sans-serif;
        }

        .welcome-btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            color: white;
        }

        .welcome-btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.5);
        }

        .welcome-btn-secondary {
            background: var(--bg-card);
            color: var(--text);
            border: 2px solid var(--border);
        }

        .welcome-btn-secondary:hover {
            border-color: var(--accent);
            background: var(--bg-hover);
        }

        /* MODALS */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.3s;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .modal-content {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .modal-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-dim);
            font-weight: 500;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.95rem;
            font-family: 'Inter', sans-serif;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .error, .success, .info {
            padding: 0.75rem;
            border-radius: 6px;
            margin: 1rem 0;
            display: none;
        }

        .error { background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); color: var(--danger); }
        .success { background: rgba(16, 185, 129, 0.1); border: 1px solid var(--success); color: var(--success); }
        .info { background: rgba(139, 92, 246, 0.1); border: 1px solid var(--accent); color: var(--accent); }

        .error.show, .success.show, .info.show { display: block; }

        /* CONNECTION TAB */
        .connection-tab-container {
            position: fixed;
            top: 70px;
            left: 20px;
            z-index: 501;
            display: none;
        }

        .connection-tab {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-top: none;
            padding: 0.5rem 1.5rem;
            border-radius: 0 0 8px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .connection-tab:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .connection-tab.open {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .connection-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--danger);
        }

        .connection-indicator.connected {
            background: var(--success);
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* CONNECTION PANEL */
        .connection-panel {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border-bottom: 2px solid var(--border);
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s;
            z-index: 500;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }

        .connection-panel.open {
            max-height: 400px;
            padding: 1.5rem;
        }

        .connection-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .connection-section {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
        }

        .connection-section h3 {
            color: var(--gold);
            margin-bottom: 0.75rem;
            font-size: 1rem;
        }

        .room-code {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-family: monospace;
            font-size: 0.85rem;
            word-break: break-all;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            color: var(--accent);
        }

        .room-code:hover {
            border-color: var(--accent);
            transform: scale(1.02);
        }

        .user-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .user-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: var(--bg-dark);
            border-radius: 6px;
        }

        .user-role {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: var(--accent);
            color: white;
        }

        /* MAIN LAYOUT */
        .container {
            display: flex;
            height: calc(100vh - 70px);
        }

        .main-area {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .tabletop {
            flex: 1;
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }

        .tabletop-header {
            padding: 1rem 1.5rem;
            background: var(--bg-hover);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-name {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .slider {
            width: 120px;
            height: 4px;
            background: var(--bg-dark);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        /* CANVAS */
        .canvas-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a1f2e 0%, var(--bg-dark) 100%);
            overflow: hidden;
        }

        #mainCanvas {
            display: block;
            cursor: grab;
        }

        #mainCanvas:active {
            cursor: grabbing;
        }

        /* TOKEN STAGING ZONE */
        .staging-zone {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 2px solid var(--gold);
            border-radius: 12px;
            padding: 1rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            max-width: 80%;
            overflow-x: auto;
            z-index: 50;
        }

        .staging-label {
            font-size: 0.85rem;
            color: var(--gold);
            font-weight: 600;
            white-space: nowrap;
        }

        .staging-tokens {
            display: flex;
            gap: 0.5rem;
        }

        .token-item {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--border);
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            flex-shrink: 0;
            transition: all 0.2s;
            position: relative;
        }

        .token-item:hover {
            transform: scale(1.1);
            border-color: var(--accent);
            z-index: 10;
        }

        .token-owner {
            position: absolute;
            bottom: -20px;
            font-size: 0.65rem;
            color: var(--text-dim);
            white-space: nowrap;
        }

        /* MINIMAP NAVIGATOR */
        .minimap-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 600;
            cursor: move;
        }

        .minimap-container.docked {
            cursor: default;
        }

        .minimap {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 0.75rem;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            width: 180px;
            transition: all 0.3s;
        }

        .minimap.collapsed {
            width: auto;
            padding: 0.5rem 1rem;
        }

        .minimap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .minimap.collapsed .minimap-header {
            margin-bottom: 0;
        }

        .minimap-title {
            font-size: 0.75rem;
            color: var(--gold);
            font-weight: 600;
        }

        .minimap-controls {
            display: flex;
            gap: 0.25rem;
        }

        .minimap-btn {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            width: 20px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: all 0.2s;
        }

        .minimap-btn:hover {
            background: var(--accent);
            color: white;
        }

        .minimap-content {
            display: block;
        }

        .minimap.collapsed .minimap-content {
            display: none;
        }

        .minimap-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 2px;
            margin-bottom: 0.5rem;
        }

        .minimap-cell {
            aspect-ratio: 1;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s;
            position: relative;
        }

        .minimap-cell:hover {
            border-color: var(--accent);
            transform: scale(1.1);
            z-index: 1;
        }

        .minimap-cell.has-content {
            background: var(--accent);
            opacity: 0.6;
        }

        .minimap-cell.locked::after {
            content: 'üîí';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
        }

        .minimap-cell.current {
            border: 2px solid var(--gold);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        .minimap-actions {
            display: flex;
            gap: 0.25rem;
        }

        .minimap-action-btn {
            flex: 1;
            padding: 0.4rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.2s;
            color: var(--text);
            text-align: center;
        }

        .minimap-action-btn:hover {
            background: var(--accent);
            color: white;
        }

        /* DM PANEL */
        .dm-panel {
            width: 420px;
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s;
            box-shadow: -4px 0 24px rgba(0,0,0,0.4);
        }

        .dm-panel.open {
            transform: translateX(0);
        }

        .dm-header {
            position: sticky;
            top: 0;
            background: var(--bg-hover);
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .dm-header h2 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
        }

        .dm-content {
            padding: 1rem;
        }

        .section {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s;
        }

        .section.active {
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
            background: rgba(139, 92, 246, 0.05);
        }

        .section h3 {
            margin-bottom: 0.75rem;
            color: var(--gold);
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin: 0.75rem 0;
        }

        .tool-btn {
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .tool-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0.75rem 0;
        }

        .control-row label {
            min-width: 60px;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        input[type="color"] {
            width: 50px;
            height: 36px;
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            background: var(--bg-dark);
        }

        .grid-selector {
            background: var(--bg-dark);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border: 2px solid var(--border);
        }

        .grid-info {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .grid-info .current {
            color: var(--accent);
            font-weight: 600;
            font-size: 1.1rem;
        }

        .grid-nav {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.5rem;
        }

        #mapCanvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: white;
            cursor: crosshair;
            margin: 0.5rem 0;
        }

        .history-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .asset-indicator {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--text-dim);
            text-align: center;
            margin-top: 0.5rem;
        }

        .asset-indicator .current-asset {
            color: var(--accent);
            font-weight: 600;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .fog-groups {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin: 0.75rem 0;
        }

        .fog-group-item {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 0.75rem;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fog-group-item.active {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }

        .fog-group-name {
            font-weight: 600;
            color: var(--text);
        }

        .fog-group-controls {
            display: flex;
            gap: 0.5rem;
        }

        .pending-requests {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .request-item {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .request-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .request-name {
            font-weight: 600;
            color: var(--text);
        }

        .request-detail {
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .request-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }

        /* UTILITY */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- WELCOME SCREEN -->
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-content">
            <div class="welcome-title">‚öîÔ∏è THE FRACTURED SKY</div>
            <div class="welcome-subtitle">Ultimate Virtual Tabletop v3.0</div>
            <div class="welcome-buttons">
                <button class="welcome-btn welcome-btn-primary" onclick="showDMLogin()">üé≠ Create Room (DM)</button>
                <button class="welcome-btn welcome-btn-secondary" onclick="showPlayerLogin()">üë§ Join Room (Player)</button>
            </div>
            <p style="position: absolute; bottom: 20px; width: 100%; text-align: center; font-size: 0.75rem; color: var(--text-dim);">
                Build: 1770456189 ‚Ä¢ Click a button to test
            </p>
        </div>
    </div>

    <!-- DM LOGIN MODAL -->
    <div class="modal" id="dmModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üßô</div>
                <div class="modal-title">Dungeon Master</div>
            </div>
            <form onsubmit="dmLogin(event)">
                <div class="form-group">
                    <label>USERNAME</label>
                    <input type="text" id="dmUser" placeholder="Wizard" required>
                </div>
                <div class="form-group">
                    <label>PASSWORD</label>
                    <input type="password" id="dmPass" placeholder="FracturedSky2025!" required>
                </div>
                <div class="form-group">
                    <label>SESSION ID (Optional - leave blank for new session)</label>
                    <input type="text" id="sessionId" placeholder="Paste previous session ID to rejoin">
                    <p style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.25rem;">üí° Save your session ID to rejoin this campaign later!</p>
                </div>
                <div class="error" id="dmError">Invalid credentials</div>
                <div class="info" id="dmInfo" style="display: none;">Rejoining previous session...</div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">LOGIN & CREATE ROOM</button>
                <button type="button" class="btn" onclick="closeDMModal()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <!-- PLAYER LOGIN MODAL -->
    <div class="modal" id="playerModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üë§</div>
                <div class="modal-title">Join as Player</div>
            </div>
            <form onsubmit="playerLogin(event)">
                <div class="form-group">
                    <label>YOUR NAME</label>
                    <input type="text" id="playerName" placeholder="Enter character name" required>
                </div>
                <div class="form-group">
                    <label>ROOM CODE</label>
                    <input type="text" id="roomCodeInput" placeholder="Paste full room code" required>
                </div>
                <div class="error" id="playerError">Connection failed</div>
                <div class="success" id="playerSuccess">Request sent! Waiting for DM approval...</div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">REQUEST TO JOIN</button>
                <button type="button" class="btn" onclick="closePlayerModal()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <!-- TOKEN REQUEST MODAL (DM) -->
    <div class="modal" id="tokenRequestModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üé≤</div>
                <div class="modal-title">Create Token</div>
            </div>
            <div class="form-group">
                <label>TOKEN EMOJI</label>
                <input type="text" id="tokenEmoji" placeholder="‚öîÔ∏è" maxlength="2">
            </div>
            <div class="form-group">
                <label>TOKEN COLOR</label>
                <input type="color" id="tokenColor" value="#e74c3c">
            </div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="createToken()" style="flex: 1;">Create</button>
                <button class="btn" onclick="closeTokenModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- FOG GROUP MODAL -->
    <div class="modal" id="fogGroupModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üë•</div>
                <div class="modal-title">Create Fog Group</div>
            </div>
            <div class="form-group">
                <label>GROUP NAME</label>
                <input type="text" id="fogGroupName" placeholder="e.g., Party A, Solo Explorer" required>
            </div>
            <div class="info">Players in this group will share fog visibility</div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="createFogGroup()" style="flex: 1;">Create Group</button>
                <button class="btn" onclick="closeFogGroupModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- HEADER -->
    <div class="header">
        <div class="title">‚öîÔ∏è THE FRACTURED SKY</div>
        <div class="campaign-badge" id="campaignBadge" style="display: none;">Campaign Name</div>
        <div class="header-actions">
            <button class="btn" id="dmControlsBtn" onclick="toggleDMPanel()" style="display: none;">üé≠ DM Controls</button>
        </div>
    </div>

    <!-- CONNECTION TAB -->
    <div class="connection-tab-container" id="connectionTabContainer">
        <div class="connection-tab" onclick="toggleConnectionPanel()" id="connectionTab">
            <div class="connection-indicator" id="tabIndicator"></div>
            <span id="tabText">Connection</span>
            <span id="tabArrow">‚ñº</span>
        </div>
    </div>

    <!-- CONNECTION PANEL -->
    <div class="connection-panel" id="connectionPanel">
        <div class="connection-content">
            <div class="connection-section" id="roomCodeSection" style="display: none;">
                <h3>üé≠ Room Code</h3>
                <p style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Share this FULL code:</p>
                <div class="room-code" id="roomCode" onclick="copyRoomCode()">----</div>
                <p style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem; text-align: center;">Click to copy</p>
            </div>
            <div class="connection-section">
                <h3>üì° Status</h3>
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                    <div class="connection-indicator" id="statusIndicator"></div>
                    <span id="statusText">Disconnected</span>
                </div>
            </div>
            <div class="connection-section">
                <h3>üë• Connected Users</h3>
                <div class="user-list" id="userList">
                    <p style="font-size: 0.85rem; color: var(--text-dim);">No users</p>
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN CONTAINER -->
    <div class="container">
        <div class="main-area">
            <div class="tabletop">
                <div class="tabletop-header">
                    <div class="session-name">Session</div>
                    <div class="zoom-controls">
                        <span style="font-size: 0.9rem; color: var(--text-dim);">Zoom:</span>
                        <input type="range" class="slider" id="zoomSlider" min="25" max="200" value="100" oninput="setZoom(this.value)">
                        <span id="zoomValue" style="min-width: 50px; font-size: 0.9rem;">100%</span>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                    
                    <!-- TOKEN STAGING ZONE -->
                    <div class="staging-zone" id="stagingZone" style="display: none;">
                        <div class="staging-label">üé≤ TOKENS</div>
                        <div class="staging-tokens" id="stagingTokens"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DM PANEL -->
        <div class="dm-panel" id="dmPanel">
            <div class="dm-header">
                <h2>üé≠ DM Controls</h2>
                <button class="btn btn-small" onclick="toggleDMPanel()">‚úï</button>
            </div>
            <div class="dm-content">
                <!-- CAMPAIGN MANAGER -->
                <div class="section" id="campaignSection">
                    <h3>üíæ Campaign Manager</h3>
                    
                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Export/Import Campaign:</div>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="exportCampaign()" style="flex: 1;">üì• Export .JSON</button>
                            <button class="btn" onclick="document.getElementById('importFile').click()" style="flex: 1;">üì§ Import .JSON</button>
                        </div>
                        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importCampaign(event)">
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Cloud Campaign Link (Google Drive, Dropbox, etc.):</div>
                        <input type="text" id="cloudLink" placeholder="Paste shareable link here" style="width: 100%; padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 0.85rem; margin-bottom: 0.5rem;">
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="saveCloudLink()" style="flex: 1;">üíæ Save Link</button>
                            <button class="btn" onclick="openCloudLink()" style="flex: 1;">üîó Open Link</button>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                            üí° Upload exported .json to Google Drive ‚Üí Get shareable link ‚Üí Paste here ‚Üí Save<br>
                            Other DMs can use this link to access the campaign!
                        </div>
                    </div>

                    <div class="success" id="exportSuccess">Campaign exported!</div>
                    <div class="success" id="importSuccess">Campaign imported!</div>
                    <div class="success" id="linkSuccess">Cloud link saved!</div>
                    <div class="error" id="importError">Import failed. Check file format.</div>
                </div>

                <!-- PLAYER REQUESTS -->
                <div class="section" id="requestsSection">
                    <h3>üì¨ Player Requests</h3>
                    <div class="pending-requests" id="pendingRequests">
                        <p style="font-size: 0.85rem; color: var(--text-dim);">No pending requests</p>
                    </div>
                </div>

                <!-- MAP BUILDER -->
                <div class="section active" id="mapSection">
                    <h3>üó∫Ô∏è Map Builder</h3>
                    
                    <div class="grid-selector">
                        <div class="grid-info">
                            Cell: <span class="current" id="currentCell">Center</span>
                        </div>
                        <div class="grid-nav">
                            <button class="btn btn-small" onclick="selectCell(0,0)">‚Üñ</button>
                            <button class="btn btn-small" onclick="selectCell(1,0)">‚Üë</button>
                            <button class="btn btn-small" onclick="selectCell(2,0)">‚Üó</button>
                            <button class="btn btn-small" onclick="selectCell(0,1)">‚Üê</button>
                            <button class="btn btn-small" onclick="selectCell(1,1)">‚óè</button>
                            <button class="btn btn-small" onclick="selectCell(2,1)">‚Üí</button>
                            <button class="btn btn-small" onclick="selectCell(0,2)">‚Üô</button>
                            <button class="btn btn-small" onclick="selectCell(1,2)">‚Üì</button>
                            <button class="btn btn-small" onclick="selectCell(2,2)">‚Üò</button>
                        </div>
                    </div>

                    <div class="history-controls">
                        <button class="btn btn-small" onclick="undo()" id="undoBtn" disabled>‚Ü∂ Undo</button>
                        <button class="btn btn-small" onclick="redo()" id="redoBtn" disabled>‚Ü∑ Redo</button>
                    </div>

                    <div class="tool-grid">
                        <div class="tool-btn active" onclick="setTool('brush')" id="brushBtn">üñåÔ∏è<br>Brush</div>
                        <div class="tool-btn" onclick="setTool('eraser')" id="eraserBtn">üßπ<br>Erase</div>
                        <div class="tool-btn" onclick="setTool('texture')" id="textureBtn">üé®<br>Texture</div>
                        <div class="tool-btn" onclick="setTool('image')" id="imageBtn">üñºÔ∏è<br>Image</div>
                    </div>

                    <div class="asset-indicator">
                        Active: <span class="current-asset" id="currentAsset">Brush</span>
                    </div>

                    <!-- ERASER MODE TOGGLE -->
                    <div id="eraserOptions" style="display: none; margin: 0.75rem 0; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Eraser Mode:</div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-small" onclick="setEraserMode('content')" id="eraseContentBtn" style="flex: 1;">Content Only</button>
                            <button class="btn btn-small" onclick="setEraserMode('all')" id="eraseAllBtn" style="flex: 1;">Everything</button>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem;" id="eraserModeDesc">
                            Erases drawn content without touching background
                        </div>
                    </div>

                    <div class="control-row">
                        <label>Color:</label>
                        <input type="color" id="colorPicker" value="#4a7c59">
                    </div>
                    <div class="control-row">
                        <label>Size:</label>
                        <input type="range" class="slider" id="sizeSlider" min="1" max="30" value="8" oninput="setSize(this.value)" style="flex: 1;">
                        <span id="sizeValue">8px</span>
                    </div>

                    <canvas id="mapCanvas" width="400" height="400"></canvas>

                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="submitCell()">‚úì Submit</button>
                        <button class="btn" onclick="clearMapCanvas()">Clear</button>
                    </div>
                </div>

                <!-- FOG OF WAR -->
                <div class="section" id="fogSection">
                    <h3>üå´Ô∏è Fog of War</h3>
                    
                    <button class="btn btn-primary" onclick="toggleFogMode()" id="fogModeToggle" style="width: 100%; margin-bottom: 1rem; transition: all 0.3s;">
                        üå´Ô∏è Fog Paint Mode: OFF
                    </button>
                    
                    <div id="fogControls" style="opacity: 0.5; pointer-events: none; transition: all 0.3s;">
                        <div class="fog-groups" id="fogGroups">
                            <div class="fog-group-item active">
                                <span class="fog-group-name">Everyone</span>
                                <button class="btn btn-small btn-primary" onclick="setActiveFogGroup('everyone')">Active</button>
                            </div>
                        </div>

                        <button class="btn" onclick="showFogGroupModal()" style="width: 100%; margin-bottom: 0.75rem;">+ New Group</button>

                        <div style="margin-bottom: 0.75rem;">
                            <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Fog Paint Mode:</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <button class="btn btn-small btn-primary" onclick="setFogPaintMode('brush')" id="fogBrushBtn">üñåÔ∏è Brush</button>
                                <button class="btn btn-small" onclick="setFogPaintMode('rect')" id="fogRectBtn">‚ñ≠ Rectangle</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Brush Size:</label>
                            <input type="range" class="slider" id="fogSize" min="20" max="150" value="60" oninput="updateFogSize(this.value)" style="flex: 1;">
                            <span id="fogSizeValue">60px</span>
                        </div>

                        <div class="control-row">
                            <label>
                                <input type="checkbox" id="revealMode" checked> Reveal Fog
                            </label>
                        </div>

                        <div class="btn-group">
                            <button class="btn" onclick="resetFog()">Reset All Fog</button>
                        </div>
                        
                        <div style="margin-top: 0.75rem; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; font-size: 0.75rem; color: var(--text-dim);">
                            üí° Hold Ctrl + Click on the map to paint fog
                        </div>
                    </div>
                </div>

                <!-- TOKENS -->
                <div class="section" id="tokenSection">
                    <h3>üé≤ Tokens</h3>
                    
                    <div class="control-row">
                        <label>
                            <input type="checkbox" id="gridSnap" onchange="toggleGridSnap()" checked> Grid Snap (25px)
                        </label>
                    </div>

                    <button class="btn btn-primary" onclick="showTokenModal()" style="width: 100%;">+ Create Token</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MINIMAP NAVIGATOR -->
    <div class="minimap-container" id="minimapContainer">
        <div class="minimap" id="minimap">
            <div class="minimap-header">
                <div class="minimap-title">üó∫Ô∏è Navigator</div>
                <div class="minimap-controls">
                    <div class="minimap-btn" onclick="toggleMinimapCollapse()" title="Collapse">‚àí</div>
                    <div class="minimap-btn" onclick="toggleMinimapDock()" title="Lock/Unlock" id="dockBtn">üîì</div>
                </div>
            </div>
            <div class="minimap-content">
                <div class="minimap-grid" id="minimapGrid"></div>
                <div class="minimap-actions">
                    <div class="minimap-action-btn" onclick="recenterView()">‚äô Center</div>
                    <div class="minimap-action-btn" onclick="resetZoom()">üîç Reset</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.clear();
        console.log('%cüéÆ THE FRACTURED SKY - Ultimate VTT v3.0', 'font-size: 20px; font-weight: bold; color: #8b5cf6;');
        console.log('%cBuild: 1770456189', 'font-size: 14px; color: #fbbf24;');
        console.log('%cScript started at:', 'font-weight: bold;', new Date().toLocaleTimeString());
        console.log('%c‚úì JavaScript is loading...', 'color: #10b981;');

        // === CORE STATE ===
        let peer = null;
        let isDM = false;
        let myId = null;
        let myName = null;
        let roomCode = null;
        let connections = new Map();
        let savedPeerId = null; // For DM session persistence

        // Game state
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let gridSnapEnabled = true;
        const GRID_SNAP_SIZE = 25;
        const GRID_SIZE = 400;
        const CELL_SIZE = 400;

        // Map builder
        let currentCellX = 1;
        let currentCellY = 1;
        let gridCells = {};
        let lockedCells = {};
        let tool = 'brush';
        let color = '#4a7c59';
        let size = 8;
        let currentAsset = 'Brush';
        let lastToolBeforeEraser = 'brush'; // Track tool before eraser
        let eraserMode = 'content'; // 'content' or 'all'
        
        // History tracking
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // Drawing state
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Tokens
        let stagingTokens = [];
        let placedTokens = [];
        let draggedToken = null;

        // Fog
        let activeFogGroup = 'everyone';
        let fogGroups = { everyone: { name: 'Everyone', canvas: null } };
        let fogMode = false;
        let fogPaintMode = 'brush'; // 'brush' or 'rect'
        let fogBrushSize = 60;
        let fogRectStart = null;
        let isFogDrawing = false;
        let dmFogOpacity = 0.3; // DM sees through fog

        // Player requests
        let pendingRequests = [];

        // Minimap
        let minimapDocked = false;
        let minimapDragOffset = null;

        const gridNames = [
            ['Top-Left', 'Top-Center', 'Top-Right'],
            ['Middle-Left', 'Center', 'Middle-Right'],
            ['Bottom-Left', 'Bottom-Center', 'Bottom-Right']
        ];

        // Canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');

        // Initialize fog canvases
        for (let group in fogGroups) {
            const fogCanvas = document.createElement('canvas');
            fogCanvas.width = GRID_SIZE * 3;
            fogCanvas.height = GRID_SIZE * 3;
            const fogCtx = fogCanvas.getContext('2d');
            fogCtx.fillStyle = 'rgba(0,0,0,0.9)';
            fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
            fogGroups[group].canvas = fogCanvas;
        }

        // === INITIALIZATION ===
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            mapCtx.fillStyle = '#f5f5dc';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            
            updateGridDisplay();
            updateMinimap();
            saveHistory();
            
            // Close DM panel when double-clicking outside
            document.addEventListener('dblclick', (e) => {
                if (!isDM) return;
                const panel = document.getElementById('dmPanel');
                if (!panel.contains(e.target) && panel.classList.contains('open')) {
                    toggleDMPanel();
                    deselectAllTools();
                }
            });

            console.log('‚úÖ VTT Ready!');
        }

        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            panX = (canvas.width - GRID_SIZE * 3) / 2;
            panY = (canvas.height - GRID_SIZE * 3) / 2;
            draw();
        }

        // === AUTHENTICATION ===
        function showDMLogin() {
            console.log('üé≠ showDMLogin called');
            // Pre-fill session ID from localStorage if available
            const savedSession = localStorage.getItem('fracturedSkySessionId');
            if (savedSession) {
                document.getElementById('sessionId').value = savedSession;
            }
            const modal = document.getElementById('dmModal');
            console.log('DM Modal element:', modal);
            modal.classList.add('active');
            console.log('DM Modal classes:', modal.className);
            
            // Debug computed styles
            setTimeout(() => {
                const computed = window.getComputedStyle(modal);
                console.log('Modal computed opacity:', computed.opacity);
                console.log('Modal computed visibility:', computed.visibility);
                console.log('Modal computed z-index:', computed.zIndex);
                console.log('Modal computed display:', computed.display);
                console.log('Modal computed pointer-events:', computed.pointerEvents);
            }, 100);
        }

        function closeDMModal() {
            console.log('closeDMModal called');
            document.getElementById('dmModal').classList.remove('active');
            document.getElementById('dmError').classList.remove('show');
            document.getElementById('dmInfo').style.display = 'none';
        }

        function dmLogin(e) {
            e.preventDefault();
            console.log('dmLogin called');
            const user = document.getElementById('dmUser').value;
            const pass = document.getElementById('dmPass').value;
            const sessionId = document.getElementById('sessionId').value.trim();
            
            // Changed password to avoid security warnings
            if (user === 'Wizard' && pass === 'FracturedSky2025!') {
                closeDMModal();
                
                if (sessionId) {
                    // Rejoin existing session
                    savedPeerId = sessionId;
                    createRoom(sessionId);
                } else {
                    // Create new session
                    createRoom();
                }
            } else {
                document.getElementById('dmError').classList.add('show');
            }
        }

        function showPlayerLogin() {
            console.log('üë§ showPlayerLogin called');
            const modal = document.getElementById('playerModal');
            console.log('Player Modal element:', modal);
            modal.classList.add('active');
            console.log('Player Modal classes:', modal.className);
        }

        function closePlayerModal() {
            document.getElementById('playerModal').classList.remove('active');
            document.getElementById('playerError').classList.remove('show');
            document.getElementById('playerSuccess').classList.remove('show');
        }

        function playerLogin(e) {
            e.preventDefault();
            myName = document.getElementById('playerName').value;
            const code = document.getElementById('roomCodeInput').value.trim();
            
            peer = new Peer();
            peer.on('open', (id) => {
                myId = id;
                const conn = peer.connect(code);
                
                setupConnection(conn, true);
                
                conn.on('open', () => {
                    // Send join request
                    sendToPeer(conn, {
                        type: 'playerJoinRequest',
                        name: myName,
                        peerId: myId
                    });
                    
                    document.getElementById('playerSuccess').classList.add('show');
                    
                    setTimeout(() => {
                        closePlayerModal();
                        document.getElementById('welcomeScreen').classList.add('hidden');
                        document.getElementById('connectionTabContainer').style.display = 'block';
                        updateConnectionStatus('Waiting for approval...', false);
                    }, 2000);
                });
                
                conn.on('error', (err) => {
                    document.getElementById('playerError').textContent = 'Connection failed: ' + err.type;
                    document.getElementById('playerError').classList.add('show');
                });
            });
        }

        // === MULTIPLAYER ===
        function createRoom(existingId = null) {
            console.log('üé≠ createRoom called with existingId:', existingId);
            isDM = true;
            myName = 'Dungeon Master';
            
            // Use existing peer ID if provided
            if (existingId) {
                console.log('Creating peer with existing ID:', existingId);
                peer = new Peer(existingId);
            } else {
                console.log('Creating peer with new ID');
                peer = new Peer();
            }
            
            console.log('Peer object created:', peer);
            
            peer.on('open', (id) => {
                console.log('‚úÖ Peer connection opened! ID:', id);
                myId = id;
                roomCode = id;
                savedPeerId = id;
                
                // Save to localStorage for easy recovery
                localStorage.setItem('fracturedSkySessionId', id);
                console.log('üíæ Saved session ID to localStorage');
                
                document.getElementById('welcomeScreen').classList.add('hidden');
                document.getElementById('connectionTabContainer').style.display = 'block';
                document.getElementById('roomCodeSection').style.display = 'block';
                document.getElementById('roomCode').textContent = roomCode;
                document.getElementById('dmControlsBtn').style.display = 'block';
                document.getElementById('stagingZone').style.display = 'flex';
                
                console.log('UI updated, calling updateConnectionStatus');
                updateConnectionStatus('Connected as DM', true);
                updateUserList();
                loadSavedCloudLink();
                
                // Show success if rejoining
                if (existingId) {
                    alert('‚úÖ Rejoined session: ' + id.substring(0, 12) + '...');
                }
                
                toggleConnectionPanel();
                setTimeout(() => {
                    if (document.getElementById('connectionPanel').classList.contains('open')) {
                        toggleConnectionPanel();
                    }
                }, 5000);
                
                console.log('‚úÖ createRoom complete!');
            });
            
            peer.on('connection', (conn) => {
                console.log('üë• Incoming connection from:', conn.peer);
                setupConnection(conn);
            });
            
            peer.on('error', (err) => {
                console.error('‚ùå Peer error:', err);
                console.error('Error type:', err.type);
                console.error('Error message:', err.message);
                
                if (err.type === 'unavailable-id') {
                    alert('‚ö†Ô∏è Session ID unavailable or in use. Creating new session...');
                    createRoom(); // Fallback to new session
                } else if (err.type === 'network') {
                    alert('‚ö†Ô∏è Network error. Check your internet connection.');
                } else if (err.type === 'peer-unavailable') {
                    alert('‚ö†Ô∏è Could not connect to PeerJS server. Try again.');
                } else {
                    alert('‚ùå Connection error: ' + err.type + ' - ' + err.message);
                }
            });
            
            console.log('Peer event listeners set up');
        }

        function setupConnection(conn, isPlayer = false) {
            conn.on('data', (data) => handleMessage(conn, data));
            
            conn.on('open', () => {
                if (!isPlayer) {
                    connections.set(conn.peer, { conn, name: 'Unknown', role: 'player', approved: false });
                } else {
                    connections.set(conn.peer, { conn, name: 'Dungeon Master', role: 'dm', approved: true });
                }
                updateUserList();
            });
            
            conn.on('close', () => {
                connections.delete(conn.peer);
                updateUserList();
            });
        }

        function handleMessage(conn, data) {
            console.log('Message received:', data.type);
            
            switch (data.type) {
                case 'playerJoinRequest':
                    if (isDM) {
                        pendingRequests.push({
                            peerId: conn.peer,
                            name: data.name,
                            conn: conn
                        });
                        renderPendingRequests();
                    }
                    break;
                    
                case 'playerApproved':
                    myName = data.name;
                    updateConnectionStatus('Approved! Connected to room', true);
                    requestGameState(conn);
                    break;
                    
                case 'playerRejected':
                    alert('Your join request was denied by the DM.');
                    break;
                    
                case 'tokenRequest':
                    if (isDM) {
                        // Add to pending requests
                        pendingRequests.push({
                            type: 'token',
                            peerId: conn.peer,
                            name: data.playerName,
                            tokenData: data.tokenData,
                            conn: conn
                        });
                        renderPendingRequests();
                    }
                    break;
                    
                case 'tokenApproved':
                    // Token was approved, add to staging
                    stagingTokens.push(data.token);
                    renderStagingTokens();
                    break;
                    
                case 'gameState':
                    loadGameState(data.state);
                    break;
                    
                case 'gridUpdate':
                    updateGridFromNetwork(data);
                    break;
                    
                case 'tokenUpdate':
                    placedTokens = data.tokens;
                    draw();
                    break;
                    
                case 'fogUpdate':
                    updateFogFromNetwork(data);
                    break;
            }
        }

        function sendToPeer(conn, data) {
            try {
                conn.send(data);
            } catch (err) {
                console.error('Send error:', err);
            }
        }

        function broadcast(data) {
            connections.forEach(({ conn, approved }) => {
                if (approved) sendToPeer(conn, data);
            });
        }

        function approvePlayer(index) {
            const request = pendingRequests[index];
            if (!request || request.type === 'token') return;
            
            const connData = connections.get(request.peerId);
            if (connData) {
                connData.approved = true;
                connData.name = request.name;
                
                sendToPeer(request.conn, {
                    type: 'playerApproved',
                    name: request.name
                });
                
                sendGameState(request.conn);
            }
            
            pendingRequests.splice(index, 1);
            renderPendingRequests();
            updateUserList();
        }

        function rejectPlayer(index) {
            const request = pendingRequests[index];
            if (!request || request.type === 'token') return;
            
            sendToPeer(request.conn, { type: 'playerRejected' });
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function approveToken(index) {
            const request = pendingRequests[index];
            if (!request || request.type !== 'token') return;
            
            const token = {
                ...request.tokenData,
                owner: request.name,
                approved: true
            };
            
            stagingTokens.push(token);
            renderStagingTokens();
            
            sendToPeer(request.conn, {
                type: 'tokenApproved',
                token: token
            });
            
            broadcast({
                type: 'tokenUpdate',
                tokens: [...stagingTokens, ...placedTokens]
            });
            
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function rejectToken(index) {
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function renderPendingRequests() {
            const container = document.getElementById('pendingRequests');
            
            if (pendingRequests.length === 0) {
                container.innerHTML = '<p style="font-size: 0.85rem; color: var(--text-dim);">No pending requests</p>';
                return;
            }
            
            container.innerHTML = pendingRequests.map((req, idx) => {
                if (req.type === 'token') {
                    return `
                        <div class="request-item">
                            <div class="request-info">
                                <div class="request-name">${req.name}</div>
                                <div class="request-detail">Token: ${req.tokenData.icon}</div>
                            </div>
                            <div class="request-actions">
                                <button class="btn btn-small btn-success" onclick="approveToken(${idx})">‚úì</button>
                                <button class="btn btn-small btn-danger" onclick="rejectToken(${idx})">‚úï</button>
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="request-item">
                            <div class="request-info">
                                <div class="request-name">${req.name}</div>
                                <div class="request-detail">Wants to join</div>
                            </div>
                            <div class="request-actions">
                                <button class="btn btn-small btn-success" onclick="approvePlayer(${idx})">‚úì</button>
                                <button class="btn btn-small btn-danger" onclick="rejectPlayer(${idx})">‚úï</button>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }

        function sendGameState(conn) {
            const gridData = {};
            for (let key in gridCells) {
                gridData[key] = gridCells[key].toDataURL();
            }
            
            const fogData = {};
            for (let group in fogGroups) {
                fogData[group] = fogGroups[group].canvas.toDataURL();
            }
            
            sendToPeer(conn, {
                type: 'gameState',
                state: {
                    gridCells: gridData,
                    lockedCells,
                    fogGroups: fogData,
                    tokens: [...stagingTokens, ...placedTokens],
                    zoom,
                    panX,
                    panY
                }
            });
        }

        function requestGameState(conn) {
            sendToPeer(conn, { type: 'requestState' });
        }

        function loadGameState(state) {
            // Load grid
            gridCells = {};
            for (let key in state.gridCells) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = CELL_SIZE;
                    canvas.height = CELL_SIZE;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    gridCells[key] = canvas;
                    draw();
                };
                img.src = state.gridCells[key];
            }
            
            // Load fog
            for (let group in state.fogGroups) {
                if (!fogGroups[group]) {
                    fogGroups[group] = { name: group, canvas: document.createElement('canvas') };
                    fogGroups[group].canvas.width = GRID_SIZE * 3;
                    fogGroups[group].canvas.height = GRID_SIZE * 3;
                }
                const img = new Image();
                img.onload = () => {
                    const ctx = fogGroups[group].canvas.getContext('2d');
                    ctx.clearRect(0, 0, fogGroups[group].canvas.width, fogGroups[group].canvas.height);
                    ctx.drawImage(img, 0, 0);
                    draw();
                };
                img.src = state.fogGroups[group];
            }
            
            lockedCells = state.lockedCells || {};
            zoom = state.zoom || 1;
            panX = state.panX || 0;
            panY = state.panY || 0;
            
            document.getElementById('zoomSlider').value = zoom * 100;
            document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
            
            draw();
            updateMinimap();
        }

        function updateGridFromNetwork(data) {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = CELL_SIZE;
                canvas.height = CELL_SIZE;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                gridCells[`${data.cellX},${data.cellY}`] = canvas;
                draw();
                updateMinimap();
            };
            img.src = data.imageData;
        }

        function updateFogFromNetwork(data) {
            if (fogGroups[data.group]) {
                const img = new Image();
                img.onload = () => {
                    const ctx = fogGroups[data.group].canvas.getContext('2d');
                    ctx.clearRect(0, 0, fogGroups[data.group].canvas.width, fogGroups[data.group].canvas.height);
                    ctx.drawImage(img, 0, 0);
                    draw();
                };
                img.src = data.fogData;
            }
        }

        function toggleConnectionPanel() {
            const panel = document.getElementById('connectionPanel');
            const tab = document.getElementById('connectionTab');
            const arrow = document.getElementById('tabArrow');
            
            if (panel.classList.contains('open')) {
                panel.classList.remove('open');
                tab.classList.remove('open');
                arrow.textContent = '‚ñº';
            } else {
                panel.classList.add('open');
                tab.classList.add('open');
                arrow.textContent = '‚ñ≤';
            }
        }

        function updateConnectionStatus(text, connected) {
            document.getElementById('statusText').textContent = text;
            const indicators = [document.getElementById('statusIndicator'), document.getElementById('tabIndicator')];
            indicators.forEach(ind => {
                if (connected) ind.classList.add('connected');
                else ind.classList.remove('connected');
            });
        }

        function updateUserList() {
            const container = document.getElementById('userList');
            const users = [];
            
            if (isDM) users.push({ name: myName, role: 'DM' });
            
            connections.forEach(({ name, role, approved }) => {
                if (approved) {
                    users.push({ name, role: role === 'dm' ? 'DM' : 'Player' });
                }
            });
            
            if (users.length === 0) {
                container.innerHTML = '<p style="font-size: 0.85rem; color: var(--text-dim);">No users</p>';
                return;
            }
            
            container.innerHTML = users.map(u => `
                <div class="user-item">
                    <span>${u.name}</span>
                    <span class="user-role">${u.role}</span>
                </div>
            `).join('');
        }

        function copyRoomCode() {
            navigator.clipboard.writeText(roomCode).then(() => {
                const elem = document.getElementById('roomCode');
                const old = elem.textContent;
                elem.textContent = '‚úì Copied!';
                elem.style.background = 'var(--accent)';
                setTimeout(() => {
                    elem.textContent = old;
                    elem.style.background = 'var(--bg-dark)';
                }, 2000);
            });
        }

        // === TOKENS ===
        function showTokenModal() {
            document.getElementById('tokenRequestModal').classList.add('active');
        }

        function closeTokenModal() {
            document.getElementById('tokenRequestModal').classList.remove('active');
        }

        function createToken() {
            const emoji = document.getElementById('tokenEmoji').value || '‚öîÔ∏è';
            const color = document.getElementById('tokenColor').value;
            
            if (isDM) {
                const token = {
                    id: Date.now(),
                    icon: emoji,
                    color: color,
                    owner: 'DM',
                    approved: true
                };
                
                stagingTokens.push(token);
                renderStagingTokens();
                closeTokenModal();
                
                broadcast({
                    type: 'tokenUpdate',
                    tokens: [...stagingTokens, ...placedTokens]
                });
            } else {
                // Player requests token
                connections.forEach(({ conn, role }) => {
                    if (role === 'dm') {
                        sendToPeer(conn, {
                            type: 'tokenRequest',
                            playerName: myName,
                            tokenData: {
                                id: Date.now(),
                                icon: emoji,
                                color: color
                            }
                        });
                    }
                });
                
                closeTokenModal();
                alert('Token request sent to DM for approval!');
            }
        }

        function renderStagingTokens() {
            const container = document.getElementById('stagingTokens');
            container.innerHTML = stagingTokens.map(t => `
                <div class="token-item" draggable="true" ondragstart="dragTokenStart(event, ${t.id})" style="background: ${t.color};">
                    ${t.icon}
                    <div class="token-owner">${t.owner}</div>
                </div>
            `).join('');
            
            if (stagingTokens.length > 0) {
                document.getElementById('stagingZone').style.display = 'flex';
            }
        }

        function dragTokenStart(e, tokenId) {
            const token = stagingTokens.find(t => t.id === tokenId);
            e.dataTransfer.setData('application/json', JSON.stringify(token));
            draggedToken = token;
        }

        function toggleGridSnap() {
            gridSnapEnabled = document.getElementById('gridSnap').checked;
        }

        function snapToGrid(value) {
            if (!gridSnapEnabled) return value;
            return Math.round(value / GRID_SNAP_SIZE) * GRID_SNAP_SIZE;
        }

        // === DRAWING ===
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);

            // Grid cells
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const x = col * GRID_SIZE;
                    const y = row * GRID_SIZE;
                    const key = `${col},${row}`;
                    
                    ctx.fillStyle = '#1a1f2e';
                    ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                    
                    if (gridCells[key]) {
                        ctx.drawImage(gridCells[key], x, y, GRID_SIZE, GRID_SIZE);
                    }
                    
                    ctx.strokeStyle = '#2a2f3e';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                    
                    if (col === currentCellX && row === currentCellY && isDM) {
                        ctx.strokeStyle = lockedCells[key] ? '#fbbf24' : '#8b5cf6';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                    }
                }
            }

            // Grid snap lines
            if (gridSnapEnabled) {
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.15)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= GRID_SIZE * 3; x += GRID_SNAP_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, GRID_SIZE * 3);
                    ctx.stroke();
                }
                for (let y = 0; y <= GRID_SIZE * 3; y += GRID_SNAP_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(GRID_SIZE * 3, y);
                    ctx.stroke();
                }
            }

            // Placed tokens
            placedTokens.forEach(t => {
                ctx.fillStyle = t.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(t.icon, t.x, t.y);
            });

            ctx.restore();

            // Fog - FULLY OPAQUE for players, semi-transparent for DM
            if (fogGroups[activeFogGroup]) {
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoom, zoom);
                
                // DM sees through fog, players see full black
                if (isDM) {
                    ctx.globalAlpha = dmFogOpacity;
                } else {
                    ctx.globalAlpha = 1.0; // Full opacity for players
                }
                
                ctx.drawImage(fogGroups[activeFogGroup].canvas, 0, 0, GRID_SIZE * 3, GRID_SIZE * 3);
                ctx.restore();
            }

            updateMinimap();
        }

        // === MAP BUILDER ===
        function selectCell(x, y) {
            if (!isDM) return;
            currentCellX = x;
            currentCellY = y;
            
            const key = `${x},${y}`;
            if (gridCells[key]) {
                mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                mapCtx.drawImage(gridCells[key], 0, 0);
            } else {
                mapCtx.fillStyle = '#f5f5dc';
                mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            }
            
            updateGridDisplay();
            draw();
        }

        function updateGridDisplay() {
            document.getElementById('currentCell').textContent = gridNames[currentCellY][currentCellX];
        }

        function setTool(t) {
            // Track last tool before switching to eraser
            if (tool !== 'eraser' && t === 'eraser') {
                lastToolBeforeEraser = tool;
                // Show eraser options
                document.getElementById('eraserOptions').style.display = 'block';
                updateEraserModeUI();
            } else if (t !== 'eraser') {
                // Hide eraser options
                document.getElementById('eraserOptions').style.display = 'none';
            }
            
            tool = t;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(t + 'Btn').classList.add('active');
            
            const assetNames = {
                brush: 'Brush',
                eraser: eraserMode === 'content' ? 
                       (lastToolBeforeEraser === 'brush' ? 'Brush Strokes' : 
                        lastToolBeforeEraser === 'texture' ? 'Textures' : 
                        lastToolBeforeEraser === 'image' ? 'Images' : 'Content') :
                       'Everything',
                texture: 'Texture',
                image: 'Image'
            };
            currentAsset = assetNames[t] || t;
            document.getElementById('currentAsset').textContent = currentAsset;
        }

        function setEraserMode(mode) {
            eraserMode = mode;
            updateEraserModeUI();
            
            // Update asset indicator
            if (tool === 'eraser') {
                const assetNames = {
                    content: lastToolBeforeEraser === 'brush' ? 'Brush Strokes' : 
                             lastToolBeforeEraser === 'texture' ? 'Textures' : 
                             lastToolBeforeEraser === 'image' ? 'Images' : 'Content',
                    all: 'Everything'
                };
                currentAsset = assetNames[mode];
                document.getElementById('currentAsset').textContent = currentAsset;
            }
        }

        function updateEraserModeUI() {
            // Update button states
            document.getElementById('eraseContentBtn').classList.remove('btn-primary');
            document.getElementById('eraseAllBtn').classList.remove('btn-primary');
            
            if (eraserMode === 'content') {
                document.getElementById('eraseContentBtn').classList.add('btn-primary');
                document.getElementById('eraserModeDesc').textContent = 'Erases drawn content without touching background';
            } else {
                document.getElementById('eraseAllBtn').classList.add('btn-primary');
                document.getElementById('eraserModeDesc').textContent = 'Erases everything including background color';
            }
        }

        function setSize(v) {
            size = v;
            document.getElementById('sizeValue').textContent = v + 'px';
        }

        function saveHistory() {
            const imageData = mapCtx.getImageData(0, 0, mapCanvas.width, mapCanvas.height);
            
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            history.push(imageData);
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
            
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                mapCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                mapCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
        }

        function clearMapCanvas() {
            mapCtx.fillStyle = '#f5f5dc';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            saveHistory();
        }

        function submitCell() {
            const key = `${currentCellX},${currentCellY}`;
            const cellCanvas = document.createElement('canvas');
            cellCanvas.width = CELL_SIZE;
            cellCanvas.height = CELL_SIZE;
            const cellCtx = cellCanvas.getContext('2d');
            cellCtx.drawImage(mapCanvas, 0, 0);
            gridCells[key] = cellCanvas;
            
            draw();
            
            broadcast({
                type: 'gridUpdate',
                cellX: currentCellX,
                cellY: currentCellY,
                imageData: cellCanvas.toDataURL()
            });
        }

        function deselectAllTools() {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            tool = null;
            currentAsset = 'None';
            document.getElementById('currentAsset').textContent = currentAsset;
        }

        // Map canvas drawing
        mapCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = mapCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
            lastX = x;
            lastY = y;
            
            if (tool === 'brush') {
                mapCtx.beginPath();
                mapCtx.moveTo(x, y);
                mapCtx.strokeStyle = color;
                mapCtx.lineWidth = size;
                mapCtx.lineCap = 'round';
                mapCtx.lineJoin = 'round';
            } else if (tool === 'eraser') {
                mapCtx.save();
                
                if (eraserMode === 'content') {
                    // Erase only drawn content, not background
                    mapCtx.globalCompositeOperation = 'destination-out';
                    mapCtx.strokeStyle = 'rgba(0,0,0,1)';
                } else {
                    // Erase everything including background
                    mapCtx.globalCompositeOperation = 'source-over';
                    mapCtx.strokeStyle = '#f5f5dc'; // Match background color
                }
                
                mapCtx.beginPath();
                mapCtx.moveTo(x, y);
                mapCtx.lineWidth = size;
                mapCtx.lineCap = 'round';
                mapCtx.lineJoin = 'round';
            }
        });

        mapCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = mapCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
            
            if (tool === 'brush' || tool === 'eraser') {
                mapCtx.lineTo(x, y);
                mapCtx.stroke();
            }
        });

        mapCanvas.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                if (tool === 'eraser') {
                    mapCtx.restore(); // Restore composite operation
                }
                saveHistory();
            }
        });

        mapCanvas.addEventListener('mouseleave', () => {
            if (isDrawing) {
                isDrawing = false;
                if (tool === 'eraser') {
                    mapCtx.restore(); // Restore composite operation
                }
                saveHistory();
            }
        });

        document.getElementById('colorPicker').addEventListener('change', (e) => {
            color = e.target.value;
        });

        // Main canvas interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX;
            const screenY = e.clientY;
            const mx = (screenX - rect.left - panX) / zoom;
            const my = (screenY - rect.top - panY) / zoom;
            
            // Check if fog mode is enabled
            if (isDM && fogMode) {
                isFogDrawing = true;
                
                if (fogPaintMode === 'brush') {
                    paintFog(mx, my);
                } else if (fogPaintMode === 'rect') {
                    fogRectStart = { x: mx, y: my };
                }
                return;
            }
            
            lastX = screenX;
            lastY = screenY;
            isDrawing = true;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX;
            const screenY = e.clientY;
            const mx = (screenX - rect.left - panX) / zoom;
            const my = (screenY - rect.top - panY) / zoom;
            
            // Fog painting
            if (isDM && isFogDrawing) {
                if (fogPaintMode === 'brush') {
                    paintFog(mx, my);
                } else if (fogPaintMode === 'rect' && fogRectStart) {
                    // Just update for preview, actual painting on mouseup
                    draw();
                    
                    // Draw preview rectangle
                    ctx.save();
                    const reveal = document.getElementById('revealMode').checked;
                    ctx.strokeStyle = reveal ? '#10b981' : '#ef4444';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 5 / zoom]);
                    ctx.translate(panX, panY);
                    ctx.scale(zoom, zoom);
                    ctx.strokeRect(fogRectStart.x, fogRectStart.y, mx - fogRectStart.x, my - fogRectStart.y);
                    ctx.restore();
                }
                return;
            }
            
            // Normal panning (only when fog mode is OFF)
            if (!isDrawing || fogMode) return;
            panX += screenX - lastX;
            panY += screenY - lastY;
            lastX = screenX;
            lastY = screenY;
            draw();
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isFogDrawing && fogPaintMode === 'rect' && fogRectStart) {
                const rect = canvas.getBoundingClientRect();
                const mx = (e.clientX - rect.left - panX) / zoom;
                const my = (e.clientY - rect.top - panY) / zoom;
                
                paintFogRect(fogRectStart.x, fogRectStart.y, mx, my);
                fogRectStart = null;
            }
            
            isFogDrawing = false;
            isDrawing = false;
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!draggedToken) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = snapToGrid((e.clientX - rect.left - panX) / zoom);
            const y = snapToGrid((e.clientY - rect.top - panY) / zoom);
            
            const placedToken = {
                ...draggedToken,
                x,
                y
            };
            
            placedTokens.push(placedToken);
            stagingTokens = stagingTokens.filter(t => t.id !== draggedToken.id);
            
            renderStagingTokens();
            draw();
            
            broadcast({
                type: 'tokenUpdate',
                tokens: [...stagingTokens, ...placedTokens]
            });
            
            draggedToken = null;
        });

        // === FOG ===
        function showFogGroupModal() {
            document.getElementById('fogGroupModal').classList.add('active');
        }

        function closeFogGroupModal() {
            document.getElementById('fogGroupModal').classList.remove('active');
        }

        function createFogGroup() {
            const name = document.getElementById('fogGroupName').value.trim();
            if (!name) return;
            
            const id = 'group_' + Date.now();
            const fogCanvas = document.createElement('canvas');
            fogCanvas.width = GRID_SIZE * 3;
            fogCanvas.height = GRID_SIZE * 3;
            const fogCtx = fogCanvas.getContext('2d');
            fogCtx.fillStyle = 'rgba(0,0,0,0.9)';
            fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
            
            fogGroups[id] = { name, canvas: fogCanvas };
            renderFogGroups();
            closeFogGroupModal();
            
            document.getElementById('fogGroupName').value = '';
        }

        function renderFogGroups() {
            const container = document.getElementById('fogGroups');
            container.innerHTML = Object.keys(fogGroups).map(id => `
                <div class="fog-group-item ${activeFogGroup === id ? 'active' : ''}">
                    <span class="fog-group-name">${fogGroups[id].name}</span>
                    <button class="btn btn-small ${activeFogGroup === id ? 'btn-primary' : ''}" onclick="setActiveFogGroup('${id}')">
                        ${activeFogGroup === id ? 'Active' : 'Select'}
                    </button>
                </div>
            `).join('');
        }

        function setActiveFogGroup(groupId) {
            activeFogGroup = groupId;
            renderFogGroups();
            draw();
        }

        function setFogPaintMode(mode) {
            fogPaintMode = mode;
            document.getElementById('fogBrushBtn').classList.remove('btn-primary');
            document.getElementById('fogRectBtn').classList.remove('btn-primary');
            
            if (mode === 'brush') {
                document.getElementById('fogBrushBtn').classList.add('btn-primary');
            } else {
                document.getElementById('fogRectBtn').classList.add('btn-primary');
            }
        }

        function toggleFogMode() {
            if (!isDM) return;
            
            fogMode = !fogMode;
            const btn = document.getElementById('fogModeToggle');
            const controls = document.getElementById('fogControls');
            
            if (fogMode) {
                // FOG MODE ON - Orange button
                btn.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
                btn.style.borderColor = '#f97316';
                btn.textContent = 'üå´Ô∏è Fog Paint Mode: ON';
                controls.style.opacity = '1';
                controls.style.pointerEvents = 'all';
            } else {
                // FOG MODE OFF - Purple button
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.classList.add('btn-primary');
                btn.textContent = 'üå´Ô∏è Fog Paint Mode: OFF';
                controls.style.opacity = '0.5';
                controls.style.pointerEvents = 'none';
            }
        }

        function updateFogSize(value) {
            fogBrushSize = parseInt(value);
            document.getElementById('fogSizeValue').textContent = value + 'px';
        }

        function resetFog() {
            if (!isDM) return;
            if (!confirm('Reset all fog for the active group?')) return;
            
            if (fogGroups[activeFogGroup]) {
                const ctx = fogGroups[activeFogGroup].canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0.9)';
                ctx.fillRect(0, 0, fogGroups[activeFogGroup].canvas.width, fogGroups[activeFogGroup].canvas.height);
                draw();
                
                broadcast({
                    type: 'fogUpdate',
                    group: activeFogGroup,
                    fogData: fogGroups[activeFogGroup].canvas.toDataURL()
                });
            }
        }

        function paintFog(x, y) {
            if (!isDM || !fogGroups[activeFogGroup]) return;
            
            const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
            const reveal = document.getElementById('revealMode').checked;
            
            fogCtx.save();
            
            if (reveal) {
                // Erase fog (reveal map)
                fogCtx.globalCompositeOperation = 'destination-out';
                fogCtx.fillStyle = 'rgba(0,0,0,1)';
            } else {
                // Add fog (hide map)
                fogCtx.globalCompositeOperation = 'source-over';
                fogCtx.fillStyle = 'rgba(0,0,0,0.9)';
            }
            
            fogCtx.beginPath();
            fogCtx.arc(x, y, fogBrushSize, 0, Math.PI * 2);
            fogCtx.fill();
            fogCtx.restore();
            
            draw();
        }

        function paintFogRect(x1, y1, x2, y2) {
            if (!isDM || !fogGroups[activeFogGroup]) return;
            
            const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
            const reveal = document.getElementById('revealMode').checked;
            
            fogCtx.save();
            
            if (reveal) {
                fogCtx.globalCompositeOperation = 'destination-out';
                fogCtx.fillStyle = 'rgba(0,0,0,1)';
            } else {
                fogCtx.globalCompositeOperation = 'source-over';
                fogCtx.fillStyle = 'rgba(0,0,0,0.9)';
            }
            
            const width = x2 - x1;
            const height = y2 - y1;
            fogCtx.fillRect(x1, y1, width, height);
            fogCtx.restore();
            
            draw();
            
            broadcast({
                type: 'fogUpdate',
                group: activeFogGroup,
                fogData: fogGroups[activeFogGroup].canvas.toDataURL()
            });
        }

        // Initialize fog mode buttons
        setFogPaintMode('brush');

        // === CAMPAIGN EXPORT/IMPORT ===
        function exportCampaign() {
            if (!isDM) return;
            
            // Serialize grid cells
            const gridData = {};
            for (let key in gridCells) {
                gridData[key] = gridCells[key].toDataURL();
            }
            
            // Serialize fog groups
            const fogData = {};
            for (let group in fogGroups) {
                fogData[group] = {
                    name: fogGroups[group].name,
                    canvas: fogGroups[group].canvas.toDataURL()
                };
            }
            
            const campaignData = {
                version: '3.0',
                name: prompt('Campaign name:', 'My Campaign') || 'Untitled Campaign',
                sessionId: roomCode,
                exported: new Date().toISOString(),
                gridCells: gridData,
                lockedCells: lockedCells,
                fogGroups: fogData,
                activeFogGroup: activeFogGroup,
                stagingTokens: stagingTokens,
                placedTokens: placedTokens,
                zoom: zoom,
                panX: panX,
                panY: panY,
                currentCellX: currentCellX,
                currentCellY: currentCellY
            };
            
            // Create downloadable file
            const dataStr = JSON.stringify(campaignData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `${campaignData.name.replace(/[^a-z0-9]/gi, '_')}_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            document.getElementById('exportSuccess').classList.add('show');
            setTimeout(() => {
                document.getElementById('exportSuccess').classList.remove('show');
            }, 3000);
            
            console.log('‚úÖ Campaign exported:', campaignData.name);
        }
        
        function importCampaign(event) {
            if (!isDM) return;
            
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (!data.version || !data.gridCells) {
                        throw new Error('Invalid campaign file format');
                    }
                    
                    // Load grid cells
                    gridCells = {};
                    let cellsLoaded = 0;
                    const totalCells = Object.keys(data.gridCells).length;
                    
                    for (let key in data.gridCells) {
                        const img = new Image();
                        img.onload = () => {
                            const cellCanvas = document.createElement('canvas');
                            cellCanvas.width = CELL_SIZE;
                            cellCanvas.height = CELL_SIZE;
                            const cellCtx = cellCanvas.getContext('2d');
                            cellCtx.drawImage(img, 0, 0);
                            gridCells[key] = cellCanvas;
                            
                            cellsLoaded++;
                            if (cellsLoaded === totalCells) {
                                draw();
                                updateMinimap();
                            }
                        };
                        img.src = data.gridCells[key];
                    }
                    
                    // Load fog groups
                    fogGroups = {};
                    for (let group in data.fogGroups) {
                        const fogCanvas = document.createElement('canvas');
                        fogCanvas.width = GRID_SIZE * 3;
                        fogCanvas.height = GRID_SIZE * 3;
                        const fogCtx = fogCanvas.getContext('2d');
                        
                        const img = new Image();
                        img.onload = () => {
                            fogCtx.drawImage(img, 0, 0);
                            draw();
                        };
                        img.src = data.fogGroups[group].canvas;
                        
                        fogGroups[group] = {
                            name: data.fogGroups[group].name,
                            canvas: fogCanvas
                        };
                    }
                    
                    // Load other data
                    lockedCells = data.lockedCells || {};
                    activeFogGroup = data.activeFogGroup || 'everyone';
                    stagingTokens = data.stagingTokens || [];
                    placedTokens = data.placedTokens || [];
                    zoom = data.zoom || 1;
                    panX = data.panX || 0;
                    panY = data.panY || 0;
                    currentCellX = data.currentCellX || 1;
                    currentCellY = data.currentCellY || 1;
                    
                    // Update UI
                    document.getElementById('zoomSlider').value = zoom * 100;
                    document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
                    
                    updateGridDisplay();
                    renderFogGroups();
                    renderStagingTokens();
                    draw();
                    updateMinimap();
                    
                    // Broadcast to all connected players
                    connections.forEach(({conn, approved}) => {
                        if (approved) sendGameState(conn);
                    });
                    
                    document.getElementById('importSuccess').classList.add('show');
                    setTimeout(() => {
                        document.getElementById('importSuccess').classList.remove('show');
                    }, 3000);
                    
                    alert('‚úÖ Campaign imported: ' + (data.name || 'Untitled'));
                    console.log('‚úÖ Campaign imported:', data.name);
                    
                } catch (err) {
                    console.error('Import error:', err);
                    document.getElementById('importError').textContent = 'Import failed: ' + err.message;
                    document.getElementById('importError').classList.add('show');
                    setTimeout(() => {
                        document.getElementById('importError').classList.remove('show');
                    }, 5000);
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        function saveCloudLink() {
            if (!isDM) return;
            
            const link = document.getElementById('cloudLink').value.trim();
            if (!link) {
                alert('Please enter a cloud link first');
                return;
            }
            
            // Save to session storage
            const key = 'fracturedSky_cloudLink_' + roomCode;
            localStorage.setItem(key, link);
            
            document.getElementById('linkSuccess').classList.add('show');
            setTimeout(() => {
                document.getElementById('linkSuccess').classList.remove('show');
            }, 3000);
            
            console.log('‚úÖ Cloud link saved for session:', roomCode);
        }
        
        function openCloudLink() {
            const link = document.getElementById('cloudLink').value.trim();
            if (!link) {
                // Try to load saved link
                const key = 'fracturedSky_cloudLink_' + roomCode;
                const saved = localStorage.getItem(key);
                if (saved) {
                    window.open(saved, '_blank');
                } else {
                    alert('No cloud link saved. Paste a link first.');
                }
            } else {
                window.open(link, '_blank');
            }
        }
        
        // Load saved cloud link on DM connect
        function loadSavedCloudLink() {
            if (isDM && roomCode) {
                const key = 'fracturedSky_cloudLink_' + roomCode;
                const saved = localStorage.getItem(key);
                if (saved) {
                    document.getElementById('cloudLink').value = saved;
                }
            }
        }

        // === MINIMAP ===
        function updateMinimap() {
            const grid = document.getElementById('minimapGrid');
            let html = '';
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const key = `${col},${row}`;
                    const classes = ['minimap-cell'];
                    if (gridCells[key]) classes.push('has-content');
                    if (lockedCells[key]) classes.push('locked');
                    if (col === currentCellX && row === currentCellY) classes.push('current');
                    
                    html += `<div class="${classes.join(' ')}" onclick="minimapNavigate(${col}, ${row})"></div>`;
                }
            }
            
            grid.innerHTML = html;
        }

        function minimapNavigate(col, row) {
            const centerX = (col + 0.5) * GRID_SIZE;
            const centerY = (row + 0.5) * GRID_SIZE;
            panX = canvas.width / 2 - centerX * zoom;
            panY = canvas.height / 2 - centerY * zoom;
            draw();
        }

        function recenterView() {
            panX = (canvas.width - GRID_SIZE * 3 * zoom) / 2;
            panY = (canvas.height - GRID_SIZE * 3 * zoom) / 2;
            draw();
        }

        function resetZoom() {
            zoom = 1;
            document.getElementById('zoomSlider').value = 100;
            document.getElementById('zoomValue').textContent = '100%';
            recenterView();
        }

        function setZoom(v) {
            zoom = v / 100;
            document.getElementById('zoomValue').textContent = Math.round(v) + '%';
            draw();
        }

        function toggleMinimapCollapse() {
            document.getElementById('minimap').classList.toggle('collapsed');
        }

        function toggleMinimapDock() {
            minimapDocked = !minimapDocked;
            const container = document.getElementById('minimapContainer');
            const btn = document.getElementById('dockBtn');
            
            if (minimapDocked) {
                container.classList.add('docked');
                btn.textContent = 'üîí';
            } else {
                container.classList.remove('docked');
                btn.textContent = 'üîì';
            }
        }

        // Minimap dragging
        const minimapContainer = document.getElementById('minimapContainer');
        minimapContainer.addEventListener('mousedown', (e) => {
            if (minimapDocked) return;
            if (e.target.closest('.minimap-btn') || e.target.closest('.minimap-cell')) return;
            
            minimapDragOffset = {
                x: e.clientX - minimapContainer.offsetLeft,
                y: e.clientY - minimapContainer.offsetTop
            };
        });

        document.addEventListener('mousemove', (e) => {
            if (!minimapDragOffset || minimapDocked) return;
            
            minimapContainer.style.left = (e.clientX - minimapDragOffset.x) + 'px';
            minimapContainer.style.top = (e.clientY - minimapDragOffset.y) + 'px';
            minimapContainer.style.bottom = 'auto';
        });

        document.addEventListener('mouseup', () => {
            minimapDragOffset = null;
        });

        // === UI ===
        function toggleDMPanel() {
            document.getElementById('dmPanel').classList.toggle('open');
        }

        // Global error handler
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('üö® JavaScript Error:', msg);
            console.error('Line:', lineNo, 'Column:', columnNo);
            console.error('Error object:', error);
            return false;
        };

        // Wrap init in try-catch
        try {
            console.log('Calling init()...');
            init();
            console.log('‚úÖ Init complete, functions should be available');
            console.log('showDMLogin type:', typeof showDMLogin);
            console.log('showPlayerLogin type:', typeof showPlayerLogin);
        } catch (err) {
            console.error('‚ùå Init failed:', err);
            alert('Error loading VTT: ' + err.message);
        }
    </script>
</body>
</html>
