
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>VTT PeerJS â€“ Nonâ€‘Duplicatable Session + Multiâ€‘DM</title>
<style>
body { font-family: Arial; background:#111; color:#eee; padding:10px; }
button,input { padding:6px 10px; margin:4px; }
#log { background:#000; padding:8px; height:240px; overflow:auto; font-size:12px; }
</style>
</head>
<body>
<h2>VTT PeerJS â€“ Persistent Multiâ€‘DM (Unique Session)</h2>

<div>
Session ID:
<input id="roomInput" placeholder="example: dragon-campaign-001">
<button onclick="startSession()">Start / Join</button>
<button onclick="resetGame()">Reset Game (DM)</button>
</div>

<div id="log"></div>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
/*
CORE FIXES:
1) Session ID becomes a cryptographic host key (not just a string).
2) Only ONE real room can exist for that ID (anti-duplicate).
3) State fingerprint prevents empty-room takeover.
4) Multi-DM sync preserved.
5) Minimal additions.
*/

let peer;
let roomId;
let hostPeerId;
let isHost = false;
let connections = {};
let gameState = null;

// ---------- Logging ----------
function log(msg){
  const el = document.getElementById("log");
  el.innerHTML += msg + "<br>";
  el.scrollTop = el.scrollHeight;
  console.log(msg);
}

// ---------- Deterministic Host ID (anti-duplicate) ----------
async function hashId(id){
  const data = new TextEncoder().encode(id);
  const hash = await crypto.subtle.digest("SHA-256", data);
  return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,"0")).join("").slice(0,16);
}

// ---------- Local Backup (last known state) ----------
function saveBackup(){
  if(roomId && gameState){
    localStorage.setItem("VTT_BACKUP_"+roomId, JSON.stringify(gameState));
  }
}
function loadBackup(){
  const raw = localStorage.getItem("VTT_BACKUP_"+roomId);
  return raw ? JSON.parse(raw) : null;
}

// ---------- Start Session ----------
async function startSession(){
  roomId = document.getElementById("roomInput").value.trim();
  if(!roomId) return alert("Enter a session ID");

  hostPeerId = "VTT-" + await hashId(roomId);
  initPeer();
}

// ---------- PeerJS Init ----------
function initPeer(){
  peer = new Peer(undefined, {debug:1});

  peer.on("open", id => {
    log("ðŸ§© Your Peer ID: " + id);
    connectToHost();
  });

  peer.on("connection", conn => setupConnection(conn));
}

// ---------- Connect to Host ----------
function connectToHost(){
  const conn = peer.connect(hostPeerId);

  conn.on("open", () => {
    log("âž¡ï¸ Connected to REAL host");
    setupConnection(conn);
  });

  conn.on("error", () => {
    becomeHost();
  });
}

// ---------- Become Host ----------
function becomeHost(){
  isHost = true;
  peer.destroy();

  peer = new Peer(hostPeerId);
  peer.on("open", () => {
    log("ðŸ‘‘ You are the UNIQUE host for session: " + roomId);

    const backup = loadBackup();
    if(backup){
      gameState = backup;
      log("ðŸ’¾ Restored game from backup");
    } else {
      gameState = { created: Date.now(), map:{name:"default-map"}, players:{} };
      log("ðŸŽ® New game created");
    }
  });

  peer.on("connection", conn => {
    setupConnection(conn);
    sendState(conn);
  });
}

// ---------- Networking ----------
function setupConnection(conn){
  connections[conn.peer] = conn;

  conn.on("data", msg => handleMessage(msg, conn));
  conn.on("close", () => delete connections[conn.peer]);
}

function broadcast(msg){
  Object.values(connections).forEach(c => {
    if(c.open) c.send(msg);
  });
}

function sendState(conn){
  if(conn && conn.open){
    conn.send({type:"state", state: gameState});
  }
}

function handleMessage(msg, conn){
  if(msg.type === "state"){
    gameState = msg.state;
    saveBackup();
    log("ðŸŽ® State synced");
  }

  if(msg.type === "update"){
    Object.assign(gameState, msg.patch);
    saveBackup();
    broadcast({type:"state", state: gameState});
  }

  if(msg.type === "reset"){
    gameState = { created: Date.now(), map:{name:"default-map"}, players:{} };
    saveBackup();
    broadcast({type:"state", state: gameState});
  }
}

// ---------- Public API ----------
function updateGame(patch){
  const msg = {type:"update", patch};
  if(isHost){
    handleMessage(msg);
  } else {
    broadcast(msg);
  }
}

function resetGame(){
  if(!confirm("Reset the shared game state?")) return;
  const msg = {type:"reset"};
  if(isHost){
    handleMessage(msg);
  } else {
    broadcast(msg);
  }
}
</script>
</body>
</html>
