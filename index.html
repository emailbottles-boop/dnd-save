<!-- VTT v4.1 PART 2 OF 2 - CONTINUATION OF JAVASCRIPT -->
<!-- PASTE THIS AFTER THE "// CONTINUE IN PART 2..." LINE IN PART 1 -->

<script>
// TOKENS
function approveToken(index) {
    const req = pendingRequests[index];
    if (!req || req.type !== 'token') return;
    const token = { ...req.tokenData, owner: req.name, approved: true };
    stagingTokens.push(token);
    renderStagingTokens();
    sendToPeer(req.conn, { type: 'tokenApproved', token });
    broadcast({ type: 'tokenUpdate', tokens: [...stagingTokens, ...placedTokens] });
    pendingRequests.splice(index, 1);
    renderPendingRequests();
}

function rejectToken(index) {
    pendingRequests.splice(index, 1);
    renderPendingRequests();
}

function showTokenModal() {
    document.getElementById('tokenRequestModal').classList.add('active');
    setTokenType('emoji');
}

function closeTokenModal() {
    document.getElementById('tokenRequestModal').classList.remove('active');
    tokenImageData = null;
}

function setTokenType(type) {
    tokenType = type;
    document.getElementById('emojiTokenBtn').classList.toggle('btn-primary', type === 'emoji');
    document.getElementById('imageTokenBtn').classList.toggle('btn-primary', type === 'image');
    document.getElementById('emojiTokenInputs').style.display = type === 'emoji' ? 'block' : 'none';
    document.getElementById('imageTokenInputs').style.display = type === 'image' ? 'block' : 'none';
}

function createToken() {
    const color = document.getElementById('tokenColor').value;
    if (tokenType === 'emoji') {
        const emoji = document.getElementById('tokenEmoji').value || 'âš”ï¸';
        if (isDM) {
            const token = { id: Date.now(), type: 'emoji', icon: emoji, color, size: 12, owner: 'DM', approved: true };
            stagingTokens.push(token);
            renderStagingTokens();
            closeTokenModal();
            broadcast({ type: 'tokenUpdate', tokens: [...stagingTokens, ...placedTokens] });
        }
    } else {
        const file = document.getElementById('tokenImageFile').files[0];
        if (!file) return alert('Select image file');
        const reader = new FileReader();
        reader.onload = function(e) {
            if (isDM) {
                const token = { id: Date.now(), type: 'image', imageData: e.target.result, color, size: 12, owner: 'DM', approved: true };
                stagingTokens.push(token);
                renderStagingTokens();
                closeTokenModal();
                broadcast({ type: 'tokenUpdate', tokens: [...stagingTokens, ...placedTokens] });
            }
        };
        reader.readAsDataURL(file);
    }
}

function renderStagingTokens() {
    const container = document.getElementById('stagingTokens');
    container.innerHTML = stagingTokens.map(t => {
        if (t.type === 'image') {
            return `<div class="token-item" draggable="true" ondragstart="dragTokenStart(event, ${t.id})" style="background: ${t.color}; background-image: url('${t.imageData}'); background-size: cover;"><div class="token-owner">${t.owner}</div></div>`;
        }
        return `<div class="token-item" draggable="true" ondragstart="dragTokenStart(event, ${t.id})" style="background: ${t.color};">${t.icon}<div class="token-owner">${t.owner}</div></div>`;
    }).join('');
    if (stagingTokens.length > 0) document.getElementById('stagingZone').style.display = 'flex';
}

function dragTokenStart(e, tokenId) {
    const token = stagingTokens.find(t => t.id === tokenId);
    e.dataTransfer.setData('application/json', JSON.stringify(token));
    draggedToken = token;
}

function toggleGridSnap() {
    gridSnapEnabled = document.getElementById('gridSnap').checked;
}

function snapToGrid(value) {
    if (!gridSnapEnabled) return value;
    const gridCenter = GRID_SNAP_SIZE / 2;
    return Math.round((value - gridCenter) / GRID_SNAP_SIZE) * GRID_SNAP_SIZE + gridCenter;
}

// DRAWING
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(panX, panY);
    ctx.scale(zoom, zoom);

    for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
            const x = col * GRID_SIZE;
            const y = row * GRID_SIZE;
            const key = `${col},${row}`;
            ctx.fillStyle = '#1a1f2e';
            ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
            if (gridCells[key]) ctx.drawImage(gridCells[key], x, y, GRID_SIZE, GRID_SIZE);
            ctx.strokeStyle = '#2a2f3e';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
            if (col === currentCellX && row === currentCellY && isDM) {
                ctx.strokeStyle = lockedCells[key] ? '#fbbf24' : '#8b5cf6';
                ctx.lineWidth = 4;
                ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
            }
        }
    }

    if (gridSnapEnabled) {
        ctx.strokeStyle = 'rgba(139, 92, 246, 0.15)';
        ctx.lineWidth = 1;
        for (let x = 0; x <= GRID_SIZE * 3; x += GRID_SNAP_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, GRID_SIZE * 3);
            ctx.stroke();
        }
        for (let y = 0; y <= GRID_SIZE * 3; y += GRID_SNAP_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(GRID_SIZE * 3, y);
            ctx.stroke();
        }
    }

    placedImages.forEach(pi => {
        ctx.save();
        ctx.translate(pi.x + pi.width / 2, pi.y + pi.height / 2);
        ctx.rotate(pi.rotation * Math.PI / 180);
        ctx.drawImage(pi.img, -pi.width / 2, -pi.height / 2, pi.width, pi.height);
        ctx.restore();
        if (isDM && selectedImage === pi) {
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(pi.x, pi.y, pi.width, pi.height);
            ctx.setLineDash([]);
            const handleSize = 8;
            ctx.fillStyle = '#8b5cf6';
            ctx.fillRect(pi.x - handleSize/2, pi.y - handleSize/2, handleSize, handleSize);
            ctx.fillRect(pi.x + pi.width - handleSize/2, pi.y - handleSize/2, handleSize, handleSize);
            ctx.fillRect(pi.x - handleSize/2, pi.y + pi.height - handleSize/2, handleSize, handleSize);
            ctx.fillRect(pi.x + pi.width - handleSize/2, pi.y + pi.height - handleSize/2, handleSize, handleSize);
            ctx.beginPath();
            ctx.arc(pi.x + pi.width / 2, pi.y - 20, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#fbbf24';
            ctx.fill();
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    });

    placedTokens.forEach(t => {
        const tokenSize = t.size || 12;
        const borderWidth = Math.max(2, tokenSize / 6);
        const fontSize = Math.max(12, tokenSize * 1.5);
        ctx.fillStyle = t.color;
        ctx.beginPath();
        ctx.arc(t.x, t.y, tokenSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = borderWidth;
        ctx.stroke();
        if (t.type === 'image' && t.imageData) {
            const img = new Image();
            img.src = t.imageData;
            ctx.save();
            ctx.beginPath();
            ctx.arc(t.x, t.y, tokenSize - 1, 0, Math.PI * 2);
            ctx.clip();
            const imgSize = (tokenSize - 1) * 2;
            ctx.drawImage(img, t.x - (tokenSize - 1), t.y - (tokenSize - 1), imgSize, imgSize);
            ctx.restore();
        } else {
            ctx.fillStyle = '#fff';
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(t.icon || 'âš”ï¸', t.x, t.y);
        }
    });

    ctx.restore();

    if (fogGroups[activeFogGroup]) {
        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(zoom, zoom);
        ctx.globalAlpha = isDM ? dmFogOpacity : 1.0;
        ctx.drawImage(fogGroups[activeFogGroup].canvas, 0, 0, GRID_SIZE * 3, GRID_SIZE * 3);
        ctx.restore();
    }

    updateMinimap();
}

// MAP BUILDER
function selectCell(x, y) {
    if (!isDM) return;
    currentCellX = x;
    currentCellY = y;
    const key = `${x},${y}`;
    if (gridCells[key]) {
        mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
        mapCtx.drawImage(gridCells[key], 0, 0);
    } else {
        mapCtx.fillStyle = '#f5f5dc';
        mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
    }
    updateGridDisplay();
    draw();
}

function updateGridDisplay() {
    document.getElementById('currentCell').textContent = gridNames[currentCellY][currentCellX];
}

function setTool(t) {
    if (tool !== 'eraser' && t === 'eraser') {
        lastToolBeforeEraser = tool;
        document.getElementById('eraserOptions').style.display = 'block';
        updateEraserModeUI();
    } else if (t !== 'eraser') {
        document.getElementById('eraserOptions').style.display = 'none';
    }
    if (t === 'stamp') {
        document.getElementById('stampLibraryToggle').style.display = 'block';
    } else {
        document.getElementById('stampLibraryToggle').style.display = 'none';
    }
    if (t !== 'select') {
        selectedImage = null;
        draw();
    }
    tool = t;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    const toolBtn = document.getElementById(t + 'Btn');
    if (toolBtn) toolBtn.classList.add('active');
    const assetNames = {
        brush: 'Brush', fill: 'Fill', stamp: 'Stamp: ' + currentStamp,
        image: 'Place Image', select: 'Select & Move',
        eraser: eraserMode === 'content' ? 'Content' : 'Everything'
    };
    currentAsset = assetNames[t] || t;
    document.getElementById('currentAsset').textContent = currentAsset;
}

function selectStamp(emoji) {
    currentStamp = emoji;
    currentAsset = 'Stamp: ' + emoji;
    document.getElementById('currentAsset').textContent = currentAsset;
    setTool('stamp');
}

function updateColor(value) {
    color = value;
}

function importImageToCanvas(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            const cellX = currentCellX * GRID_SIZE + GRID_SIZE / 2;
            const cellY = currentCellY * GRID_SIZE + GRID_SIZE / 2;
            const maxSize = GRID_SIZE * 0.8;
            let width = img.width;
            let height = img.height;
            if (width > maxSize || height > maxSize) {
                const scale = Math.min(maxSize / width, maxSize / height);
                width *= scale;
                height *= scale;
            }
            const placedImg = { img, x: cellX - width / 2, y: cellY - height / 2, width, height, rotation: 0, gridX: currentCellX, gridY: currentCellY };
            placedImages.push(placedImg);
            selectedImage = placedImg;
            setTool('select');
            draw();
            broadcastImages();
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
    event.target.value = '';
}

function broadcastImages() {
    const imageData = placedImages.map(pi => ({ src: pi.img.src, x: pi.x, y: pi.y, width: pi.width, height: pi.height, rotation: pi.rotation, gridX: pi.gridX, gridY: pi.gridY }));
    broadcast({ type: 'imagesUpdate', images: imageData });
}

function setEraserMode(mode) {
    eraserMode = mode;
    updateEraserModeUI();
    if (tool === 'eraser') {
        currentAsset = mode === 'content' ? 'Content' : 'Everything';
        document.getElementById('currentAsset').textContent = currentAsset;
    }
}

function updateEraserModeUI() {
    document.getElementById('eraseContentBtn').classList.toggle('btn-primary', eraserMode === 'content');
    document.getElementById('eraseAllBtn').classList.toggle('btn-primary', eraserMode === 'all');
    document.getElementById('eraserModeDesc').textContent = eraserMode === 'content' ? 'Erases content only' : 'Erases everything';
}

function setSize(v) {
    size = v;
    document.getElementById('sizeValue').textContent = v + 'px';
}

function saveHistory() {
    const imageData = mapCtx.getImageData(0, 0, mapCanvas.width, mapCanvas.height);
    if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
    }
    history.push(imageData);
    if (history.length > MAX_HISTORY) {
        history.shift();
    } else {
        historyIndex++;
    }
    updateHistoryButtons();
}

function undo() {
    if (historyIndex > 0) {
        historyIndex--;
        mapCtx.putImageData(history[historyIndex], 0, 0);
        updateHistoryButtons();
    }
}

function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        mapCtx.putImageData(history[historyIndex], 0, 0);
        updateHistoryButtons();
    }
}

function updateHistoryButtons() {
    document.getElementById('undoBtn').disabled = historyIndex <= 0;
    document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
}

function clearMapCanvas() {
    mapCtx.fillStyle = '#f5f5dc';
    mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
    saveHistory();
}

function submitCell() {
    const key = `${currentCellX},${currentCellY}`;
    const cellCanvas = document.createElement('canvas');
    cellCanvas.width = CELL_SIZE;
    cellCanvas.height = CELL_SIZE;
    const cellCtx = cellCanvas.getContext('2d');
    cellCtx.drawImage(mapCanvas, 0, 0);
    gridCells[key] = cellCanvas;
    draw();
    broadcast({ type: 'gridUpdate', cellX: currentCellX, cellY: currentCellY, imageData: cellCanvas.toDataURL() });
}

function deselectAllTools() {
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    tool = null;
    currentAsset = 'None';
    document.getElementById('currentAsset').textContent = currentAsset;
}

// MAP CANVAS DRAWING
mapCanvas.addEventListener('mousedown', (e) => {
    isDrawing = true;
    const rect = mapCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
    const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
    lastX = x;
    lastY = y;
    if (tool === 'brush') {
        mapCtx.beginPath();
        mapCtx.moveTo(x, y);
        mapCtx.strokeStyle = color;
        mapCtx.lineWidth = size;
        mapCtx.lineCap = 'round';
        mapCtx.lineJoin = 'round';
    } else if (tool === 'fill') {
        mapCtx.fillStyle = color;
        mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
        saveHistory();
        isDrawing = false;
    } else if (tool === 'stamp') {
        mapCtx.font = '48px Arial';
        mapCtx.textAlign = 'center';
        mapCtx.textBaseline = 'middle';
        mapCtx.fillText(currentStamp, x, y);
        saveHistory();
        isDrawing = false;
    } else if (tool === 'eraser') {
        mapCtx.save();
        if (eraserMode === 'content') {
            mapCtx.globalCompositeOperation = 'destination-out';
            mapCtx.strokeStyle = 'rgba(0,0,0,1)';
        } else {
            mapCtx.globalCompositeOperation = 'source-over';
            mapCtx.strokeStyle = '#f5f5dc';
        }
        mapCtx.beginPath();
        mapCtx.moveTo(x, y);
        mapCtx.lineWidth = size;
        mapCtx.lineCap = 'round';
        mapCtx.lineJoin = 'round';
    }
});

mapCanvas.addEventListener('mousemove', (e) => {
    if (!isDrawing) return;
    const rect = mapCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
    const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
    if (tool === 'brush' || tool === 'eraser') {
        mapCtx.lineTo(x, y);
        mapCtx.stroke();
    }
});

mapCanvas.addEventListener('mouseup', () => {
    if (isDrawing) {
        isDrawing = false;
        if (tool === 'eraser') mapCtx.restore();
        saveHistory();
    }
});

mapCanvas.addEventListener('mouseleave', () => {
    if (isDrawing) {
        isDrawing = false;
        if (tool === 'eraser') mapCtx.restore();
        saveHistory();
    }
});

// MAIN CANVAS INTERACTION
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left - panX) / zoom;
    const my = (e.clientY - rect.top - panY) / zoom;
    
    if (!fogMode && tool !== 'select') {
        for (let i = placedTokens.length - 1; i >= 0; i--) {
            const token = placedTokens[i];
            const tokenSize = token.size || 25;
            const dist = Math.hypot(mx - token.x, my - token.y);
            if (dist < tokenSize) {
                if (isDM || token.owner === myName) {
                    draggedPlacedToken = token;
                    tokenDragOffset = { x: mx - token.x, y: my - token.y };
                    return;
                }
            }
        }
    }
    
    if (isDM && tool === 'select') {
        if (selectedImage) {
            const rotX = selectedImage.x + selectedImage.width / 2;
            const rotY = selectedImage.y - 20;
            if (Math.hypot(mx - rotX, my - rotY) < 10) {
                imageResizeHandle = 'rotate';
                imageDragStart = { x: mx, y: my };
                return;
            }
            const handleSize = 8;
            const handles = [
                { type: 'nw', x: selectedImage.x, y: selectedImage.y },
                { type: 'ne', x: selectedImage.x + selectedImage.width, y: selectedImage.y },
                { type: 'sw', x: selectedImage.x, y: selectedImage.y + selectedImage.height },
                { type: 'se', x: selectedImage.x + selectedImage.width, y: selectedImage.y + selectedImage.height }
            ];
            for (let h of handles) {
                if (Math.abs(mx - h.x) < handleSize && Math.abs(my - h.y) < handleSize) {
                    imageResizeHandle = h.type;
                    imageDragStart = { x: mx, y: my, origWidth: selectedImage.width, origHeight: selectedImage.height, origX: selectedImage.x, origY: selectedImage.y };
                    return;
                }
            }
        }
        for (let i = placedImages.length - 1; i >= 0; i--) {
            const pi = placedImages[i];
            if (mx >= pi.x && mx <= pi.x + pi.width && my >= pi.y && my <= pi.y + pi.height) {
                selectedImage = pi;
                imageDragStart = { x: mx, y: my, imgX: pi.x, imgY: pi.y };
                draw();
                return;
            }
        }
        selectedImage = null;
        draw();
        return;
    }
    
    if (isDM && fogMode) {
        isFogDrawing = true;
        if (fogPaintMode === 'brush') {
            paintFog(mx, my);
        } else if (fogPaintMode === 'rect') {
            fogRectStart = { x: mx, y: my };
        }
        return;
    }
    
    lastX = e.clientX;
    lastY = e.clientY;
    isDrawing = true;
});

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left - panX) / zoom;
    const my = (e.clientY - rect.top - panY) / zoom;
    
    if (draggedPlacedToken) {
        draggedPlacedToken.x = snapToGrid(mx - tokenDragOffset.x);
        draggedPlacedToken.y = snapToGrid(my - tokenDragOffset.y);
        draw();
        return;
    }
    
    if (isDM && tool === 'select' && selectedImage && imageDragStart) {
        if (imageResizeHandle === 'rotate') {
            const centerX = selectedImage.x + selectedImage.width / 2;
            const centerY = selectedImage.y + selectedImage.height / 2;
            const angle = Math.atan2(my - centerY, mx - centerX) * 180 / Math.PI + 90;
            selectedImage.rotation = angle;
            draw();
            return;
        } else if (imageResizeHandle) {
            const dx = mx - imageDragStart.x;
            const dy = my - imageDragStart.y;
            if (imageResizeHandle === 'se') {
                selectedImage.width = imageDragStart.origWidth + dx;
                selectedImage.height = imageDragStart.origHeight + dy;
            } else if (imageResizeHandle === 'nw') {
                selectedImage.width = imageDragStart.origWidth - dx;
                selectedImage.height = imageDragStart.origHeight - dy;
                selectedImage.x = imageDragStart.origX + dx;
                selectedImage.y = imageDragStart.origY + dy;
            } else if (imageResizeHandle === 'ne') {
                selectedImage.width = imageDragStart.origWidth + dx;
                selectedImage.height = imageDragStart.origHeight - dy;
                selectedImage.y = imageDragStart.origY + dy;
            } else if (imageResizeHandle === 'sw') {
                selectedImage.width = imageDragStart.origWidth - dx;
                selectedImage.height = imageDragStart.origHeight + dy;
                selectedImage.x = imageDragStart.origX + dx;
            }
            if (selectedImage.width < 50) selectedImage.width = 50;
            if (selectedImage.height < 50) selectedImage.height = 50;
            draw();
            return;
        } else {
            selectedImage.x = imageDragStart.imgX + (mx - imageDragStart.x);
            selectedImage.y = imageDragStart.imgY + (my - imageDragStart.y);
            draw();
            return;
        }
    }
    
    if (isDM && isFogDrawing) {
        if (fogPaintMode === 'brush') {
            paintFog(mx, my);
        } else if (fogPaintMode === 'rect' && fogRectStart) {
            draw();
            ctx.save();
            const reveal = document.getElementById('revealMode').checked;
            ctx.strokeStyle = reveal ? '#10b981' : '#ef4444';
            ctx.lineWidth = 2 / zoom;
            ctx.setLineDash([5 / zoom, 5 / zoom]);
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);
            ctx.strokeRect(fogRectStart.x, fogRectStart.y, mx - fogRectStart.x, my - fogRectStart.y);
            ctx.restore();
        }
        return;
    }
    
    if (!isDrawing || fogMode || (isDM && tool === 'select') || draggedPlacedToken) return;
    panX += e.clientX - lastX;
    panY += e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;
    draw();
});

canvas.addEventListener('mouseup', (e) => {
    if (draggedPlacedToken) {
        broadcast({ type: 'tokenUpdate', tokens: [...stagingTokens, ...placedTokens] });
        draggedPlacedToken = null;
        tokenDragOffset = { x: 0, y: 0 };
    }
    if (imageDragStart) {
        imageDragStart = null;
        imageResizeHandle = null;
        broadcastImages();
    }
    if (isFogDrawing && fogPaintMode === 'rect' && fogRectStart) {
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left - panX) / zoom;
        const my = (e.clientY - rect.top - panY) / zoom;
        paintFogRect(fogRectStart.x, fogRectStart.y, mx, my);
        fogRectStart = null;
    }
    isFogDrawing = false;
    isDrawing = false;
});

canvas.addEventListener('dragover', (e) => e.preventDefault());

canvas.addEventListener('drop', (e) => {
    e.preventDefault();
    if (!draggedToken) return;
    const rect = canvas.getBoundingClientRect();
    const x = snapToGrid((e.clientX - rect.left - panX) / zoom);
    const y = snapToGrid((e.clientY - rect.top - panY) / zoom);
    const placedToken = { ...draggedToken, x, y };
    placedTokens.push(placedToken);
    stagingTokens = stagingTokens.filter(t => t.id !== draggedToken.id);
    renderStagingTokens();
    draw();
    broadcast({ type: 'tokenUpdate', tokens: [...stagingTokens, ...placedTokens] });
    draggedToken = null;
});

document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' && selectedImage && isDM) {
        const index = placedImages.indexOf(selectedImage);
        if (index > -1) {
            placedImages.splice(index, 1);
            selectedImage = null;
            draw();
            broadcastImages();
        }
    }
});

// FOG
function showFogGroupModal() {
    document.getElementById('fogGroupModal').classList.add('active');
}

function closeFogGroupModal() {
    document.getElementById('fogGroupModal').classList.remove('active');
}

function createFogGroup() {
    const name = document.getElementById('fogGroupName').value.trim();
    if (!name) return;
    const id = 'group_' + Date.now();
    const fogCanvas = document.createElement('canvas');
    fogCanvas.width = GRID_SIZE * 3;
    fogCanvas.height = GRID_SIZE * 3;
    const fogCtx = fogCanvas.getContext('2d');
    fogCtx.fillStyle = 'rgba(0,0,0,1)';
    fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
    fogGroups[id] = { name, canvas: fogCanvas };
    renderFogGroups();
    closeFogGroupModal();
    document.getElementById('fogGroupName').value = '';
}

function renderFogGroups() {
    const container = document.getElementById('fogGroups');
    container.innerHTML = Object.keys(fogGroups).map(id => `
        <div class="fog-group-item ${activeFogGroup === id ? 'active' : ''}">
            <span class="fog-group-name">${fogGroups[id].name}</span>
            <button class="btn btn-small ${activeFogGroup === id ? 'btn-primary' : ''}" onclick="setActiveFogGroup('${id}')">
                ${activeFogGroup === id ? 'Active' : 'Select'}
            </button>
        </div>
    `).join('');
}

function setActiveFogGroup(groupId) {
    activeFogGroup = groupId;
    renderFogGroups();
    draw();
}

function setFogPaintMode(mode) {
    fogPaintMode = mode;
    document.getElementById('fogBrushBtn').classList.toggle('btn-primary', mode === 'brush');
    document.getElementById('fogRectBtn').classList.toggle('btn-primary', mode === 'rect');
}

function toggleFogMode() {
    if (!isDM) return;
    fogMode = !fogMode;
    const btn = document.getElementById('fogModeToggle');
    const controls = document.getElementById('fogControls');
    if (fogMode) {
        btn.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
        btn.style.borderColor = '#f97316';
        btn.textContent = 'ðŸŒ«ï¸ Fog Paint Mode: ON';
        controls.style.opacity = '1';
        controls.style.pointerEvents = 'all';
    } else {
        btn.style.background = '';
        btn.style.borderColor = '';
        btn.classList.add('btn-primary');
        btn.textContent = 'ðŸŒ«ï¸ Fog Paint Mode: OFF';
        controls.style.opacity = '0.5';
        controls.style.pointerEvents = 'none';
    }
}

function updateFogSize(value) {
    fogBrushSize = parseInt(value);
    document.getElementById('fogSizeValue').textContent = value + 'px';
}

function resetFog() {
    if (!isDM || !confirm('Reset fog?')) return;
    if (fogGroups[activeFogGroup]) {
        const ctx = fogGroups[activeFogGroup].canvas.getContext('2d');
        ctx.fillStyle = 'rgba(0,0,0,0.9)';
        ctx.fillRect(0, 0, fogGroups[activeFogGroup].canvas.width, fogGroups[activeFogGroup].canvas.height);
        draw();
        broadcast({ type: 'fogUpdate', group: activeFogGroup, fogData: fogGroups[activeFogGroup].canvas.toDataURL() });
    }
}

function paintFog(x, y) {
    if (!isDM || !fogGroups[activeFogGroup]) return;
    const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
    const reveal = document.getElementById('revealMode').checked;
    fogCtx.save();
    if (reveal) {
        fogCtx.globalCompositeOperation = 'destination-out';
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
    } else {
        fogCtx.globalCompositeOperation = 'source-over';
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
    }
    fogCtx.beginPath();
    fogCtx.arc(x, y, fogBrushSize, 0, Math.PI * 2);
    fogCtx.fill();
    fogCtx.restore();
    draw();
    broadcastFog();
}

function paintFogRect(x1, y1, x2, y2) {
    if (!isDM || !fogGroups[activeFogGroup]) return;
    const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
    const reveal = document.getElementById('revealMode').checked;
    fogCtx.save();
    if (reveal) {
        fogCtx.globalCompositeOperation = 'destination-out';
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
    } else {
        fogCtx.globalCompositeOperation = 'source-over';
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
    }
    fogCtx.fillRect(x1, y1, x2 - x1, y2 - y1);
    fogCtx.restore();
    draw();
    broadcastFog();
}

function broadcastFog() {
    if (!isDM) return;
    if (fogBroadcastTimeout) clearTimeout(fogBroadcastTimeout);
    fogBroadcastTimeout = setTimeout(() => {
        broadcast({ type: 'fogUpdate', group: activeFogGroup, fogData: fogGroups[activeFogGroup].canvas.toDataURL() });
        fogBroadcastTimeout = null;
    }, 100);
}

setFogPaintMode('brush');

// GAME STATE
function sendGameState(conn) {
    const gridData = {};
    for (let key in gridCells) gridData[key] = gridCells[key].toDataURL();
    const fogData = {};
    for (let group in fogGroups) fogData[group] = fogGroups[group].canvas.toDataURL();
    const imagesData = placedImages.map(pi => ({ src: pi.img.src, x: pi.x, y: pi.y, width: pi.width, height: pi.height, rotation: pi.rotation, gridX: pi.gridX, gridY: pi.gridY }));
    sendToPeer(conn, {
        type: 'gameState',
        state: { gridCells: gridData, lockedCells, fogGroups: fogData, tokens: [...stagingTokens, ...placedTokens], placedImages: imagesData, zoom, panX, panY }
    });
}

function requestGameState(conn) {
    sendToPeer(conn, { type: 'requestState' });
}

function loadGameState(state) {
    gridCells = {};
    for (let key in state.gridCells) {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = CELL_SIZE;
            canvas.height = CELL_SIZE;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            gridCells[key] = canvas;
            draw();
        };
        img.src = state.gridCells[key];
    }
    for (let group in state.fogGroups) {
        if (!fogGroups[group]) {
            fogGroups[group] = { name: group, canvas: document.createElement('canvas') };
            fogGroups[group].canvas.width = GRID_SIZE * 3;
            fogGroups[group].canvas.height = GRID_SIZE * 3;
        }
        const img = new Image();
        img.onload = () => {
            const ctx = fogGroups[group].canvas.getContext('2d');
            ctx.clearRect(0, 0, fogGroups[group].canvas.width, fogGroups[group].canvas.height);
            ctx.drawImage(img, 0, 0);
            draw();
        };
        img.src = state.fogGroups[group];
    }
    if (state.tokens) {
        stagingTokens = [];
        placedTokens = [];
        state.tokens.forEach(token => {
            if (token.x !== undefined) placedTokens.push(token);
            else stagingTokens.push(token);
        });
        renderStagingTokens();
    }
    if (state.placedImages) {
        placedImages = [];
        state.placedImages.forEach(imgData => {
            const img = new Image();
            img.onload = () => {
                placedImages.push({ img, x: imgData.x, y: imgData.y, width: imgData.width, height: imgData.height, rotation: imgData.rotation, gridX: imgData.gridX, gridY: imgData.gridY });
                draw();
            };
            img.src = imgData.src;
        });
    }
    lockedCells = state.lockedCells || {};
    zoom = state.zoom || 1;
    panX = state.panX || 0;
    panY = state.panY || 0;
    document.getElementById('zoomSlider').value = zoom * 100;
    document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
    draw();
    updateMinimap();
}

function updateGridFromNetwork(data) {
    const img = new Image();
    img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = CELL_SIZE;
        canvas.height = CELL_SIZE;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        gridCells[`${data.cellX},${data.cellY}`] = canvas;
        draw();
        updateMinimap();
    };
    img.src = data.imageData;
}

function updateFogFromNetwork(data) {
    if (fogGroups[data.group]) {
        const img = new Image();
        img.onload = () => {
            const ctx = fogGroups[data.group].canvas.getContext('2d');
            ctx.clearRect(0, 0, fogGroups[data.group].canvas.width, fogGroups[data.group].canvas.height);
            ctx.drawImage(img, 0, 0);
            draw();
        };
        img.src = data.fogData;
    }
}

// UI
function toggleConnectionPanel() {
    const panel = document.getElementById('connectionPanel');
    const tab = document.getElementById('connectionTab');
    const arrow = document.getElementById('tabArrow');
    if (panel.classList.contains('open')) {
        panel.classList.remove('open');
        tab.classList.remove('open');
        arrow.textContent = 'â–¼';
    } else {
        panel.classList.add('open');
        tab.classList.add('open');
        arrow.textContent = 'â–²';
    }
}

function updateConnectionStatus(text, connected) {
    document.getElementById('statusText').textContent = text;
    const indicators = [document.getElementById('statusIndicator'), document.getElementById('tabIndicator')];
    indicators.forEach(ind => {
        if (connected) ind.classList.add('connected');
        else ind.classList.remove('connected');
    });
}

function updateUserList() {
    const container = document.getElementById('userList');
    const users = [];
    if (isDM) users.push({ name: myName, role: 'DM' });
    connections.forEach(({ name, role, approved }) => {
        if (approved) users.push({ name, role: role === 'dm' ? 'DM' : 'Player' });
    });
    if (users.length === 0) {
        container.innerHTML = '<p style="font-size: 0.85rem; color: var(--text-dim);">No users</p>';
        return;
    }
    container.innerHTML = users.map(u => `<div class="user-item"><span>${u.name}</span><span class="user-role">${u.role}</span></div>`).join('');
}

function copyRoomCode() {
    if (!roomCode) return;
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(roomCode).then(() => {
            const elem = document.getElementById('roomCode');
            const old = elem.textContent;
            elem.textContent = 'âœ“ Copied!';
            elem.style.background = 'var(--accent)';
            elem.style.color = 'white';
            setTimeout(() => {
                elem.textContent = old;
                elem.style.background = 'var(--bg-dark)';
                elem.style.color = 'var(--accent)';
            }, 2000);
        });
    }
}

function toggleDMPanel() {
    document.getElementById('dmPanel').classList.toggle('open');
}

function updateMinimap() {
    const grid = document.getElementById('minimapGrid');
    let html = '';
    for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
            const key = `${col},${row}`;
            const classes = ['minimap-cell'];
            if (gridCells[key]) classes.push('has-content');
            if (lockedCells[key]) classes.push('locked');
            if (col === currentCellX && row === currentCellY) classes.push('current');
            html += `<div class="${classes.join(' ')}" onclick="minimapNavigate(${col}, ${row})"></div>`;
        }
    }
    grid.innerHTML = html;
}

function minimapNavigate(col, row) {
    const centerX = (col + 0.5) * GRID_SIZE;
    const centerY = (row + 0.5) * GRID_SIZE;
    panX = canvas.width / 2 - centerX * zoom;
    panY = canvas.height / 2 - centerY * zoom;
    draw();
}

function recenterView() {
    panX = (canvas.width - GRID_SIZE * 3 * zoom) / 2;
    panY = (canvas.height - GRID_SIZE * 3 * zoom) / 2;
    draw();
}

function resetZoom() {
    zoom = 1;
    document.getElementById('zoomSlider').value = 100;
    document.getElementById('zoomValue').textContent = '100%';
    recenterView();
}

function setZoom(v) {
    zoom = v / 100;
    document.getElementById('zoomValue').textContent = Math.round(v) + '%';
    draw();
}

function toggleMinimapCollapse() {
    document.getElementById('minimap').classList.toggle('collapsed');
}

function toggleMinimapDock() {
    minimapDocked = !minimapDocked;
    const container = document.getElementById('minimapContainer');
    const btn = document.getElementById('dockBtn');
    if (minimapDocked) {
        container.classList.add('docked');
        btn.textContent = 'ðŸ”’';
    } else {
        container.classList.remove('docked');
        btn.textContent = 'ðŸ”“';
    }
}

const minimapContainer = document.getElementById('minimapContainer');
minimapContainer.addEventListener('mousedown', (e) => {
    if (minimapDocked || e.target.closest('.minimap-btn') || e.target.closest('.minimap-cell')) return;
    minimapDragOffset = { x: e.clientX - minimapContainer.offsetLeft, y: e.clientY - minimapContainer.offsetTop };
});

document.addEventListener('mousemove', (e) => {
    if (!minimapDragOffset || minimapDocked) return;
    minimapContainer.style.left = (e.clientX - minimapDragOffset.x) + 'px';
    minimapContainer.style.top = (e.clientY - minimapDragOffset.y) + 'px';
    minimapContainer.style.bottom = 'auto';
});

document.addEventListener('mouseup', () => {
    minimapDragOffset = null;
});

try {
    init();
    console.log('âœ… VTT v4.1 initialized!');
} catch (err) {
    console.error('Init error:', err);
}
</script>
