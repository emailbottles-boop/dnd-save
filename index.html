<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Fractured Sky VTT v4.1 - Session Persistence FIXED</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-dark: #0a0e1a; --bg-card: #151928; --bg-hover: #1f2537;
            --accent: #8b5cf6; --accent-secondary: #ec4899; --gold: #fbbf24;
            --text: #e5e7eb; --text-dim: #9ca3af; --border: rgba(139, 92, 246, 0.2);
            --success: #10b981; --danger: #ef4444;
        }
        body { font-family: 'Inter', sans-serif; background: var(--bg-dark); color: var(--text); overflow: hidden; height: 100vh; user-select: none; }
        .header { background: var(--bg-card); border-bottom: 1px solid var(--border); padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 100; }
        .title { font-family: 'Cinzel', serif; font-size: 1.5rem; font-weight: 700; background: linear-gradient(135deg, var(--gold), var(--accent)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header-actions { display: flex; gap: 0.75rem; align-items: center; }
        .btn { padding: 0.6rem 1.2rem; background: var(--bg-hover); border: 1px solid var(--border); color: var(--text); border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.2s; font-family: 'Inter', sans-serif; }
        .btn:hover { background: var(--accent); border-color: var(--accent); transform: translateY(-1px); }
        .btn-primary { background: linear-gradient(135deg, var(--accent), var(--accent-secondary)); border: none; color: white; }
        .btn-small { padding: 0.4rem 0.8rem; font-size: 0.8rem; }
        .btn-success { background: var(--success); border-color: var(--success); color: white; }
        .btn-danger { background: var(--danger); border-color: var(--danger); color: white; }
        .welcome-screen { position: fixed; inset: 0; background: linear-gradient(135deg, #0a0e1a 0%, #1a1f3a 100%); display: flex; align-items: center; justify-content: center; z-index: 10000; transition: opacity 0.5s; }
        .welcome-screen.hidden { opacity: 0; pointer-events: none; }
        .welcome-content { text-align: center; padding: 3rem; }
        .welcome-title { font-family: 'Cinzel', serif; font-size: 4rem; font-weight: 700; background: linear-gradient(135deg, var(--gold), var(--accent)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 1rem; }
        .welcome-subtitle { font-size: 1.2rem; color: var(--text-dim); margin-bottom: 3rem; }
        .welcome-buttons { display: flex; gap: 1rem; justify-content: center; }
        .welcome-btn { padding: 1rem 2rem; font-size: 1.1rem; border-radius: 12px; cursor: pointer; border: none; font-weight: 600; transition: all 0.3s; font-family: 'Inter', sans-serif; }
        .welcome-btn-primary { background: linear-gradient(135deg, var(--accent), var(--accent-secondary)); color: white; }
        .welcome-btn-primary:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(139, 92, 246, 0.5); }
        .welcome-btn-secondary { background: var(--bg-card); color: var(--text); border: 2px solid var(--border); }
        .welcome-btn-secondary:hover { border-color: var(--accent); background: var(--bg-hover); }
        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 99999; opacity: 0; visibility: hidden; pointer-events: none; transition: all 0.3s; }
        .modal.active { opacity: 1; visibility: visible; pointer-events: all; }
        .modal-content { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; max-width: 450px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.5); max-height: 80vh; overflow-y: auto; }
        .modal-header { text-align: center; margin-bottom: 1.5rem; }
        .modal-icon { font-size: 3rem; margin-bottom: 1rem; }
        .modal-title { font-family: 'Cinzel', serif; font-size: 1.5rem; color: var(--gold); }
        .form-group { margin-bottom: 1rem; }
        .form-group label { display: block; margin-bottom: 0.5rem; font-size: 0.9rem; color: var(--text-dim); font-weight: 500; }
        .form-group input, .form-group select { width: 100%; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 0.95rem; font-family: 'Inter', sans-serif; }
        .form-group input:focus, .form-group select:focus { outline: none; border-color: var(--accent); }
        .error, .success, .info { padding: 0.75rem; border-radius: 6px; margin: 1rem 0; display: none; }
        .error { background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); color: var(--danger); }
        .success { background: rgba(16, 185, 129, 0.1); border: 1px solid var(--success); color: var(--success); }
        .info { background: rgba(139, 92, 246, 0.1); border: 1px solid var(--accent); color: var(--accent); }
        .error.show, .success.show, .info.show { display: block; }
        .connection-tab-container { position: fixed; top: 70px; left: 20px; z-index: 501; display: none; }
        .connection-tab { background: var(--bg-card); border: 2px solid var(--border); border-top: none; padding: 0.5rem 1.5rem; border-radius: 0 0 8px 8px; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; transition: all 0.2s; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .connection-tab:hover { background: var(--bg-hover); border-color: var(--accent); }
        .connection-tab.open { background: var(--accent); color: white; border-color: var(--accent); }
        .connection-indicator { width: 8px; height: 8px; border-radius: 50%; background: var(--danger); }
        .connection-indicator.connected { background: var(--success); animation: pulse-dot 2s infinite; }
        @keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .connection-panel { position: fixed; top: 70px; left: 0; right: 0; background: var(--bg-card); border-bottom: 2px solid var(--border); padding: 0; max-height: 0; overflow: hidden; transition: all 0.3s; z-index: 500; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
        .connection-panel.open { max-height: 400px; padding: 1.5rem; }
        .connection-content { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; max-width: 1200px; margin: 0 auto; }
        .connection-section { background: var(--bg-hover); border: 1px solid var(--border); border-radius: 10px; padding: 1rem; }
        .connection-section h3 { color: var(--gold); margin-bottom: 0.75rem; font-size: 1rem; }
        .room-code { background: var(--bg-dark); padding: 0.75rem; border-radius: 8px; border: 1px solid var(--border); font-family: monospace; font-size: 0.85rem; word-break: break-all; cursor: pointer; transition: all 0.2s; text-align: center; color: var(--accent); }
        .room-code:hover { border-color: var(--accent); transform: scale(1.02); }
        .user-list { display: flex; flex-direction: column; gap: 0.5rem; }
        .user-item { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px; }
        .user-role { font-size: 0.75rem; padding: 0.25rem 0.5rem; border-radius: 4px; background: var(--accent); color: white; }
        .container { display: flex; height: calc(100vh - 70px); }
        .main-area { flex: 1; padding: 1rem; display: flex; flex-direction: column; }
        .tabletop { flex: 1; background: var(--bg-card); border-radius: 12px; border: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
        .tabletop-header { padding: 1rem 1.5rem; background: var(--bg-hover); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .session-name { font-family: 'Cinzel', serif; font-size: 1.3rem; background: linear-gradient(135deg, var(--gold), var(--accent)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .zoom-controls { display: flex; align-items: center; gap: 0.75rem; }
        .slider { width: 120px; height: 4px; background: var(--bg-dark); border-radius: 2px; outline: none; -webkit-appearance: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; cursor: pointer; }
        .canvas-container { flex: 1; position: relative; background: radial-gradient(circle at center, #1a1f2e 0%, var(--bg-dark) 100%); overflow: hidden; }
        #mainCanvas { display: block; cursor: grab; }
        #mainCanvas:active { cursor: grabbing; }
        .staging-zone { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: var(--bg-card); border: 2px solid var(--gold); border-radius: 12px; padding: 1rem; display: none; gap: 0.75rem; align-items: center; box-shadow: 0 8px 24px rgba(0,0,0,0.6); max-width: 80%; overflow-x: auto; z-index: 50; }
        .staging-label { font-size: 0.85rem; color: var(--gold); font-weight: 600; white-space: nowrap; }
        .staging-tokens { display: flex; gap: 0.5rem; }
        .token-item { width: 60px; height: 60px; border-radius: 50%; border: 3px solid var(--border); cursor: move; display: flex; align-items: center; justify-content: center; font-size: 2rem; flex-shrink: 0; transition: all 0.2s; position: relative; }
        .token-item:hover { transform: scale(1.1); border-color: var(--accent); z-index: 10; }
        .token-owner { position: absolute; bottom: -20px; font-size: 0.65rem; color: var(--text-dim); white-space: nowrap; }
        .dm-panel { width: 420px; background: var(--bg-card); border-left: 1px solid var(--border); overflow-y: auto; transform: translateX(100%); transition: transform 0.3s; box-shadow: -4px 0 24px rgba(0,0,0,0.4); }
        .dm-panel.open { transform: translateX(0); }
        .dm-header { position: sticky; top: 0; background: var(--bg-hover); padding: 1rem; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; z-index: 10; }
        .dm-header h2 { font-family: 'Cinzel', serif; color: var(--gold); }
        .dm-content { padding: 1rem; }
        .section { background: var(--bg-hover); border: 1px solid var(--border); border-radius: 10px; padding: 1rem; margin-bottom: 1rem; transition: all 0.3s; }
        .section h3 { margin-bottom: 0.75rem; color: var(--gold); font-size: 1rem; display: flex; align-items: center; gap: 0.5rem; }
        .tool-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin: 0.75rem 0; }
        .tool-btn { padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; text-align: center; font-size: 0.8rem; transition: all 0.2s; }
        .tool-btn:hover { background: var(--bg-hover); border-color: var(--accent); }
        .tool-btn.active { background: var(--accent); border-color: var(--accent); color: white; }
        .control-row { display: flex; align-items: center; gap: 0.75rem; margin: 0.75rem 0; }
        .control-row label { min-width: 60px; font-size: 0.85rem; color: var(--text-dim); }
        input[type="color"] { width: 50px; height: 36px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--bg-dark); }
        .grid-selector { background: var(--bg-dark); padding: 1rem; border-radius: 8px; margin: 1rem 0; border: 2px solid var(--border); }
        .grid-info { font-size: 0.9rem; color: var(--text-dim); margin-bottom: 0.5rem; text-align: center; }
        .grid-info .current { color: var(--accent); font-weight: 600; font-size: 1.1rem; }
        .grid-nav { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem; }
        .map-canvas-wrapper { position: relative; width: 100%; margin: 0.5rem 0; }
        #mapCanvas { width: 100%; height: 250px; border-radius: 8px; border: 1px solid var(--border); background: white; cursor: crosshair; display: block; }
        .ruler-top, .ruler-left { position: absolute; background: var(--bg-hover); border: 1px solid var(--border); display: flex; font-size: 0.6rem; color: var(--text-dim); }
        .ruler-top { top: -20px; left: 0; right: 0; height: 18px; }
        .ruler-left { left: -20px; top: 0; bottom: 0; width: 18px; flex-direction: column; }
        .ruler-mark { flex: 1; border-right: 1px solid var(--border); display: flex; align-items: center; justify-content: center; }
        .ruler-left .ruler-mark { border-right: none; border-bottom: 1px solid var(--border); }
        .ruler-mark:last-child { border: none; }
        .btn-group { display: flex; gap: 0.5rem; margin-top: 0.75rem; }
        .minimap-container { position: fixed; bottom: 20px; left: 20px; z-index: 600; cursor: move; }
        .minimap { background: var(--bg-card); border: 2px solid var(--border); border-radius: 12px; padding: 0.75rem; box-shadow: 0 8px 24px rgba(0,0,0,0.4); width: 180px; transition: all 0.3s; }
        .minimap-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .minimap-title { font-size: 0.75rem; color: var(--gold); font-weight: 600; }
        .minimap-controls { display: flex; gap: 0.25rem; }
        .minimap-btn { background: var(--bg-hover); border: 1px solid var(--border); width: 20px; height: 20px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; transition: all 0.2s; }
        .minimap-btn:hover { background: var(--accent); color: white; }
        .minimap-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; padding: 2px; margin-bottom: 0.5rem; }
        .minimap-cell { aspect-ratio: 1; background: var(--bg-hover); border: 1px solid var(--border); cursor: pointer; border-radius: 2px; transition: all 0.2s; }
        .minimap-cell:hover { border-color: var(--accent); transform: scale(1.1); z-index: 1; }
        .minimap-cell.has-content { background: var(--accent); opacity: 0.6; }
        .minimap-cell.current { border: 2px solid var(--gold); box-shadow: 0 0 10px rgba(251, 191, 36, 0.5); }
        .minimap-actions { display: flex; gap: 0.25rem; }
        .minimap-action-btn { flex: 1; padding: 0.4rem; background: var(--bg-hover); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.7rem; transition: all 0.2s; color: var(--text); text-align: center; }
        .minimap-action-btn:hover { background: var(--accent); color: white; }
        .fog-groups { display: flex; flex-direction: column; gap: 0.5rem; margin: 0.75rem 0; }
        .fog-group-item { background: var(--bg-dark); border: 1px solid var(--border); padding: 0.75rem; border-radius: 6px; display: flex; justify-content: space-between; align-items: center; }
        .fog-group-item.active { border-color: var(--accent); background: rgba(139, 92, 246, 0.1); }
        .fog-group-name { font-weight: 600; color: var(--text); }
        .pending-requests { display: flex; flex-direction: column; gap: 0.5rem; }
        .request-item { background: var(--bg-dark); padding: 0.75rem; border-radius: 6px; display: flex; justify-content: space-between; align-items: center; border: 1px solid var(--border); }
        .request-info { display: flex; flex-direction: column; gap: 0.25rem; }
        .request-name { font-weight: 600; color: var(--text); }
        .request-detail { font-size: 0.75rem; color: var(--text-dim); }
        .request-actions { display: flex; gap: 0.5rem; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 4px; }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-content">
            <div class="welcome-title">‚öîÔ∏è THE FRACTURED SKY</div>
            <div class="welcome-subtitle">VTT v4.1 - Session Persistence Fixed</div>
            <div class="welcome-buttons">
                <button class="welcome-btn welcome-btn-primary" onclick="showDMLogin()">üé≠ Create Room (DM)</button>
                <button class="welcome-btn welcome-btn-secondary" onclick="showPlayerLogin()">üë§ Join Room (Player)</button>
            </div>
        </div>
    </div>

    <div class="modal" id="dmModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üßô</div>
                <div class="modal-title">Dungeon Master</div>
            </div>
            <form onsubmit="dmLogin(event)">
                <div class="form-group">
                    <label>USERNAME</label>
                    <input type="text" id="dmUser" placeholder="Wizard" required>
                </div>
                <div class="form-group">
                    <label>PASSWORD</label>
                    <input type="password" id="dmPass" placeholder="FracturedSky2025!" required>
                </div>
                <div class="form-group">
                    <label>SESSION ID (Optional)</label>
                    <input type="text" id="sessionId" placeholder="Leave blank for new">
                </div>
                <div class="error" id="dmError">Invalid credentials</div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">LOGIN</button>
                <button type="button" class="btn" onclick="closeDMModal()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <div class="modal" id="playerModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üë§</div>
                <div class="modal-title">Join as Player</div>
            </div>
            <form onsubmit="playerLogin(event)">
                <div class="form-group">
                    <label>YOUR NAME</label>
                    <input type="text" id="playerName" placeholder="Character name" required>
                </div>
                <div class="form-group">
                    <label>ROOM CODE</label>
                    <input type="text" id="roomCodeInput" placeholder="Paste room code" required>
                </div>
                <div class="error" id="playerError">Connection failed</div>
                <div class="success" id="playerSuccess">Connecting...</div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">JOIN</button>
                <button type="button" class="btn" onclick="closePlayerModal()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <div class="modal" id="tokenRequestModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üé≤</div>
                <div class="modal-title">Create Token</div>
            </div>
            <div class="form-group">
                <label>TOKEN EMOJI</label>
                <input type="text" id="tokenEmoji" placeholder="‚öîÔ∏è" maxlength="2">
            </div>
            <div class="form-group">
                <label>TOKEN COLOR</label>
                <input type="color" id="tokenColor" value="#e74c3c">
            </div>
            <div class="btn-group">
                <button type="button" class="btn btn-primary" onclick="createToken()" style="flex: 1;">Create</button>
                <button type="button" class="btn" onclick="closeTokenModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="fogGroupModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üë•</div>
                <div class="modal-title">Create Fog Group</div>
            </div>
            <div class="form-group">
                <label>GROUP NAME</label>
                <input type="text" id="fogGroupName" placeholder="e.g., Party A" required>
            </div>
            <div class="info">Players in this group share fog visibility</div>
            <div class="btn-group">
                <button type="button" class="btn btn-primary" onclick="createFogGroup()" style="flex: 1;">Create</button>
                <button type="button" class="btn" onclick="closeFogGroupModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="header">
        <div class="title">‚öîÔ∏è THE FRACTURED SKY</div>
        <div class="header-actions">
            <button class="btn" id="dmControlsBtn" onclick="toggleDMPanel()" style="display: none;">üéõÔ∏è DM Controls</button>
        </div>
    </div>

    <div class="connection-tab-container" id="connectionTabContainer">
        <div class="connection-tab" id="connectionTab" onclick="toggleConnectionPanel()">
            <div class="connection-indicator" id="tabIndicator"></div>
            <span id="statusText">Disconnected</span>
            <span id="tabArrow">‚ñº</span>
        </div>
    </div>

    <div class="connection-panel" id="connectionPanel">
        <div class="connection-content">
            <div class="connection-section" id="roomCodeSection" style="display: none;">
                <h3>üîë Room Code</h3>
                <div class="room-code" id="roomCode" onclick="copyRoomCode()">-</div>
                <p style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem; text-align: center;">Click to copy</p>
            </div>
            <div class="connection-section">
                <h3>üë• Connected Users</h3>
                <div class="user-list" id="userList">
                    <p style="font-size: 0.85rem; color: var(--text-dim);">No users</p>
                </div>
            </div>
            <div class="connection-section">
                <h3>‚è±Ô∏è Connection Status</h3>
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                    <div class="connection-indicator" id="statusIndicator"></div>
                    <span>Ready to connect</span>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="main-area">
            <div class="tabletop">
                <div class="tabletop-header">
                    <div class="session-name">Active Session</div>
                    <div class="zoom-controls">
                        <button class="btn btn-small" onclick="resetZoom()">Reset</button>
                        <span style="font-size: 0.85rem; min-width: 45px;" id="zoomValue">100%</span>
                        <input type="range" class="slider" id="zoomSlider" min="25" max="200" value="100" oninput="setZoom(this.value)">
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                    <div class="staging-zone" id="stagingZone">
                        <div class="staging-label">TOKEN STAGING</div>
                        <div class="staging-tokens" id="stagingTokens"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="dm-panel" id="dmPanel">
            <div class="dm-header">
                <h2>üéõÔ∏è DM Controls</h2>
                <button class="btn btn-small" onclick="toggleDMPanel()">‚úï</button>
            </div>
            <div class="dm-content">
                <div class="section">
                    <h3>üìã Join Requests</h3>
                    <div class="pending-requests" id="pendingRequests">
                        <p style="font-size: 0.85rem; color: var(--text-dim);">No requests</p>
                    </div>
                </div>

                <div class="section">
                    <h3>üó∫Ô∏è Map Builder</h3>
                    <div class="grid-selector">
                        <div class="grid-info">
                            Building: <span class="current" id="currentCell">Center</span>
                        </div>
                        <div class="grid-nav">
                            <button class="btn btn-small" onclick="selectCell(0, 0)">TL</button>
                            <button class="btn btn-small" onclick="selectCell(1, 0)">TC</button>
                            <button class="btn btn-small" onclick="selectCell(2, 0)">TR</button>
                            <button class="btn btn-small" onclick="selectCell(0, 1)">ML</button>
                            <button class="btn btn-small" onclick="selectCell(1, 1)">C</button>
                            <button class="btn btn-small" onclick="selectCell(2, 1)">MR</button>
                            <button class="btn btn-small" onclick="selectCell(0, 2)">BL</button>
                            <button class="btn btn-small" onclick="selectCell(1, 2)">BC</button>
                            <button class="btn btn-small" onclick="selectCell(2, 2)">BR</button>
                        </div>
                    </div>

                    <div class="control-row">
                        <span style="font-size: 0.85rem; color: var(--text-dim);">Active:</span>
                        <span style="font-size: 0.85rem; font-weight: 600;" id="currentAsset">None</span>
                    </div>

                    <div class="tool-grid">
                        <button class="tool-btn" id="brushBtn" onclick="setTool('brush')">üñåÔ∏è Brush</button>
                        <button class="tool-btn" id="fillBtn" onclick="setTool('fill')">ü™£ Fill</button>
                        <button class="tool-btn" id="stampBtn" onclick="setTool('stamp')">üìå Stamp</button>
                        <button class="tool-btn" id="eraserBtn" onclick="setTool('eraser')">üßπ Eraser</button>
                        <button class="tool-btn" id="imageBtn" onclick="document.getElementById('imageUpload').click()">üñºÔ∏è Image</button>
                        <button class="tool-btn" id="selectBtn" onclick="setTool('select')">üëÜ Select</button>
                    </div>

                    <input type="file" id="imageUpload" accept="image/*" onchange="importImageToCanvas(event)" style="display: none;">

                    <div class="control-row">
                        <label>Color:</label>
                        <input type="color" id="colorPicker" value="#4a7c59" onchange="updateColor(this.value)">
                    </div>
                    <div class="control-row">
                        <label>Size:</label>
                        <input type="range" class="slider" id="brushSize" min="1" max="50" value="8" oninput="setSize(this.value)" style="flex: 1;">
                        <span id="sizeValue" style="min-width: 40px; font-size: 0.85rem;">8px</span>
                    </div>

                    <div class="map-canvas-wrapper">
                        <div class="ruler-top" id="rulerTop"></div>
                        <div class="ruler-left" id="rulerLeft"></div>
                        <canvas id="mapCanvas" width="400" height="400"></canvas>
                    </div>

                    <div class="btn-group">
                        <button class="btn btn-small" onclick="undo()" id="undoBtn">‚Ü∂ Undo</button>
                        <button class="btn btn-small" onclick="redo()" id="redoBtn">‚Ü∑ Redo</button>
                        <button class="btn btn-small btn-danger" onclick="clearMapCanvas()">üóëÔ∏è Clear</button>
                    </div>

                    <button class="btn btn-primary" onclick="submitCell()" style="width: 100%; margin-top: 0.75rem;">‚úÖ Submit to Grid</button>
                    <button class="btn" onclick="deselectAllTools()" style="width: 100%; margin-top: 0.5rem;">‚ùå Deselect Tools</button>
                    <button class="btn btn-success" onclick="exportCampaign()" style="width: 100%; margin-top: 0.5rem;">üíæ Export Campaign</button>
                </div>

                <div class="section">
                    <h3>üé≤ Tokens</h3>
                    <button class="btn btn-primary" onclick="showTokenModal()" style="width: 100%;">+ Create Token</button>
                    <div class="control-row" style="margin-top: 0.75rem;">
                        <input type="checkbox" id="gridSnap" checked onchange="toggleGridSnap()">
                        <label style="min-width: auto;">Grid Snap</label>
                    </div>
                </div>

                <div class="section">
                    <h3>üå´Ô∏è Fog of War</h3>
                    <div class="fog-groups" id="fogGroups"></div>
                    <button class="btn" onclick="showFogGroupModal()" style="width: 100%; margin-bottom: 0.75rem;">+ New Group</button>
                    
                    <button class="btn btn-primary" id="fogModeToggle" onclick="toggleFogMode()" style="width: 100%; margin-bottom: 0.75rem;">üå´Ô∏è Fog Paint Mode: OFF</button>
                    
                    <div id="fogControls" style="opacity: 0.5; pointer-events: none;">
                        <div class="control-row">
                            <label>Size:</label>
                            <input type="range" class="slider" min="10" max="150" value="60" oninput="updateFogSize(this.value)" style="flex: 1;">
                            <span id="fogSizeValue" style="min-width: 50px; font-size: 0.85rem;">60px</span>
                        </div>
                        
                        <div class="control-row">
                            <input type="checkbox" id="revealMode" checked>
                            <label style="min-width: auto;">Reveal Mode</label>
                        </div>
                        
                        <button class="btn btn-danger" onclick="resetFog()" style="width: 100%;">Reset Fog</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="minimap-container" id="minimapContainer">
        <div class="minimap" id="minimap">
            <div class="minimap-header">
                <div class="minimap-title">üó∫Ô∏è MINIMAP</div>
                <div class="minimap-controls">
                    <button class="minimap-btn" onclick="toggleMinimapDock()">üîì</button>
                    <button class="minimap-btn" onclick="toggleMinimapCollapse()">‚àí</button>
                </div>
            </div>
            <div class="minimap-content">
                <div class="minimap-grid" id="minimapGrid"></div>
                <div class="minimap-actions">
                    <button class="minimap-action-btn" onclick="recenterView()">‚äô Center</button>
                    <button class="minimap-action-btn" onclick="resetZoom()">‚ä° Reset</button>
                </div>
            </div>
        </div>
    </div>

<script>
// STATE VARIABLES
let peer = null, isDM = false, myId = null, myName = null, roomCode = null;
let connections = new Map();
let zoom = 1, panX = 0, panY = 0, gridSnapEnabled = true;
const GRID_SNAP_SIZE = 25, GRID_SIZE = 400, CELL_SIZE = 400;
let currentCellX = 1, currentCellY = 1, gridCells = {}, lockedCells = {};
let tool = 'brush', color = '#4a7c59', size = 8, currentAsset = 'Brush';
let eraserMode = 'content', currentStamp = 'üè∞';
let placedImages = [], selectedImage = null, imageResizeHandle = null, imageDragStart = null;
let history = [], historyIndex = -1;
const MAX_HISTORY = 50;
let isDrawing = false, lastX = 0, lastY = 0;
let stagingTokens = [], placedTokens = [], draggedToken = null, draggedPlacedToken = null;
let tokenDragOffset = { x: 0, y: 0 };
let activeFogGroup = 'everyone', fogGroups = { everyone: { name: 'Everyone', canvas: null } };
let fogMode = false, fogPaintMode = 'brush', fogBrushSize = 60, fogRectStart = null;
let isFogDrawing = false, dmFogOpacity = 0.3, fogBroadcastTimeout = null;
let pendingRequests = [];
let minimapDocked = false, minimapDragOffset = null;
const gridNames = [
    ['Top-Left', 'Top-Center', 'Top-Right'],
    ['Middle-Left', 'Center', 'Middle-Right'],
    ['Bottom-Left', 'Bottom-Center', 'Bottom-Right']
];

let canvas, ctx, mapCanvas, mapCtx;

function initCanvases() {
    canvas = document.getElementById('mainCanvas');
    ctx = canvas.getContext('2d');
    mapCanvas = document.getElementById('mapCanvas');
    mapCtx = mapCanvas.getContext('2d');

    for (let group in fogGroups) {
        const fogCanvas = document.createElement('canvas');
        fogCanvas.width = GRID_SIZE * 3;
        fogCanvas.height = GRID_SIZE * 3;
        const fogCtx = fogCanvas.getContext('2d');
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
        fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
        fogGroups[group].canvas = fogCanvas;
    }
}

// SESSION PERSISTENCE - THIS IS THE KEY FIX!
function saveSessionState() {
    const state = { isDM, myName, roomCode, myId, timestamp: Date.now() };
    localStorage.setItem('vtt_session', JSON.stringify(state));
    console.log('‚úÖ Session saved:', state);
}

function loadSessionState() {
    const saved = localStorage.getItem('vtt_session');
    if (!saved) return null;
    try {
        const state = JSON.parse(saved);
        const age = Date.now() - state.timestamp;
        if (age > 5 * 60 * 1000) { // 5 minutes
            localStorage.removeItem('vtt_session');
            return null;
        }
        return state;
    } catch (err) {
        return null;
    }
}

// AUTO-RECONNECT ON PAGE LOAD
window.addEventListener('load', () => {
    const session = loadSessionState();
    if (session) {
        console.log('üîÑ Auto-reconnecting...', session);
        isDM = session.isDM;
        myName = session.myName;
        roomCode = session.roomCode;
        
        if (isDM) {
            createRoom(session.myId);
        } else {
            reconnectAsPlayer(session);
        }
    }
});

function reconnectAsPlayer(session) {
    peer = new Peer();
    peer.on('open', (id) => {
        myId = id;
        const conn = peer.connect(session.roomCode);
        setupConnection(conn, true);
        conn.on('open', () => {
            sendToPeer(conn, { type: 'playerReconnect', name: session.myName, peerId: id });
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('connectionTabContainer').style.display = 'block';
            updateConnectionStatus('Reconnected!', true);
        });
    });
}

// INIT
function init() {
    initCanvases();
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    mapCtx.fillStyle = '#f5f5dc';
    mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
    updateGridDisplay();
    updateMinimap();
    saveHistory();
    createRulers();
    renderFogGroups();
}

function createRulers() {
    const rulerTop = document.getElementById('rulerTop');
    const rulerLeft = document.getElementById('rulerLeft');
    for (let i = 0; i < 16; i++) {
        const mark = document.createElement('div');
        mark.className = 'ruler-mark';
        mark.textContent = i % 4 === 0 ? (i / 4) : '';
        rulerTop.appendChild(mark);
    }
    for (let i = 0; i < 16; i++) {
        const mark = document.createElement('div');
        mark.className = 'ruler-mark';
        mark.textContent = i % 4 === 0 ? (i / 4) : '';
        rulerLeft.appendChild(mark);
    }
}

function resizeCanvas() {
    const container = document.querySelector('.canvas-container');
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;
    panX = (canvas.width - GRID_SIZE * 3) / 2;
    panY = (canvas.height - GRID_SIZE * 3) / 2;
    draw();
}

// AUTH
function showDMLogin() {
    const saved = localStorage.getItem('fracturedSkySessionId');
    if (saved) document.getElementById('sessionId').value = saved;
    document.getElementById('dmModal').classList.add('active');
}

function closeDMModal() {
    document.getElementById('dmModal').classList.remove('active');
}

function dmLogin(e) {
    e.preventDefault();
    const user = document.getElementById('dmUser').value;
    const pass = document.getElementById('dmPass').value;
    const sessionId = document.getElementById('sessionId').value.trim();
    if (user === 'Wizard' && pass === 'FracturedSky2025!') {
        closeDMModal();
        createRoom(sessionId || null);
    } else {
        document.getElementById('dmError').classList.add('show');
    }
}

function showPlayerLogin() {
    document.getElementById('playerModal').classList.add('active');
}

function closePlayerModal() {
    document.getElementById('playerModal').classList.remove('active');
}

function playerLogin(e) {
    e.preventDefault();
    myName = document.getElementById('playerName').value;
    const code = document.getElementById('roomCodeInput').value.trim();
    roomCode = code;
    peer = new Peer();
    peer.on('open', (id) => {
        myId = id;
        const conn = peer.connect(code);
        setupConnection(conn, true);
        conn.on('open', () => {
            sendToPeer(conn, { type: 'playerJoinRequest', name: myName, peerId: myId });
            document.getElementById('playerSuccess').classList.add('show');
            setTimeout(() => {
                closePlayerModal();
                document.getElementById('welcomeScreen').classList.add('hidden');
                document.getElementById('connectionTabContainer').style.display = 'block';
                updateConnectionStatus('Waiting...', false);
                saveSessionState();
            }, 2000);
        });
    });
}

// MULTIPLAYER
function createRoom(existingId) {
    isDM = true;
    myName = 'Dungeon Master';
    peer = existingId ? new Peer(existingId) : new Peer();
    peer.on('open', (id) => {
        myId = id;
        roomCode = id;
        localStorage.setItem('fracturedSkySessionId', id);
        saveSessionState();
        document.getElementById('welcomeScreen').classList.add('hidden');
        document.getElementById('connectionTabContainer').style.display = 'block';
        document.getElementById('roomCodeSection').style.display = 'block';
        document.getElementById('roomCode').textContent = roomCode;
        document.getElementById('dmControlsBtn').style.display = 'block';
        document.getElementById('stagingZone').style.display = 'flex';
        updateConnectionStatus('Connected as DM', true);
        updateUserList();
    });
    peer.on('connection', (conn) => setupConnection(conn));
    peer.on('error', (err) => {
        if (err.type === 'unavailable-id') createRoom();
    });
}

function setupConnection(conn, isPlayer = false) {
    conn.on('data', (data) => handleMessage(conn, data));
    conn.on('open', () => {
        if (!isPlayer) {
            connections.set(conn.peer, { conn, name: 'Unknown', role: 'player', approved: false });
        } else {
            connections.set(conn.peer, { conn, name: 'DM', role: 'dm', approved: true });
        }
        updateUserList();
    });
    conn.on('close', () => {
        connections.delete(conn.peer);
        updateUserList();
    });
}

function handleMessage(conn, data) {
    switch (data.type) {
        case 'playerJoinRequest':
            if (isDM) {
                pendingRequests.push({ peerId: conn.peer, name: data.name, conn });
                renderPendingRequests();
            }
            break;
        case 'playerReconnect':
            if (isDM) {
                const connData = connections.get(conn.peer);
                if (connData) {
                    connData.approved = true;
                    connData.name = data.name;
                    sendToPeer(conn, { type: 'playerApproved', name: data.name });
                    sendGameState(conn);
                    updateUserList();
                }
            }
            break;
        case 'playerApproved':
            myName = data.name;
            updateConnectionStatus('Connected!', true);
            requestGameState(conn);
            saveSessionState();
            break;
        case 'tokenRequest':
            if (isDM) {
                pendingRequests.push({ type: 'token', peerId: conn.peer, name: data.playerName, tokenData: data.tokenData, conn });
                renderPendingRequests();
            }
            break;
        case 'tokenApproved':
            stagingTokens.push(data.token);
            renderStagingTokens();
            break;
        case 'gameState':
            loadGameState(data.state);
            break;
        case 'gridUpdate':
            updateGridFromNetwork(data);
            break;
        case 'tokenUpdate':
            stagingTokens = [];
            placedTokens = [];
            data.tokens.forEach(token => {
                if (token.x !== undefined) placedTokens.push(token);
                else stagingTokens.push(token);
            });
            renderStagingTokens();
            draw();
            break;
        case 'fogUpdate':
            updateFogFromNetwork(data);
            break;
        case 'imagesUpdate':
            placedImages = [];
            data.images.forEach(imgData => {
                const img = new Image();
                img.onload = () => {
                    placedImages.push({ img, x: imgData.x, y: imgData.y, width: imgData.width, height: imgData.height, rotation: imgData.rotation, gridX: imgData.gridX, gridY: imgData.gridY });
                    draw();
                };
                img.src = imgData.src;
            });
            break;
    }
}

function sendToPeer(conn, data) {
    try { conn.send(data); } catch (err) {}
}

function broadcast(data) {
    connections.forEach(({ conn, approved }) => {
        if (approved) sendToPeer(conn, data);
    });
}

function approvePlayer(index) {
    const req = pendingRequests[index];
    if (!req || req.type === 'token') return;
    const connData = connections.get(req.peerId);
    if (connData) {
        connData.approved = true;
        connData.name = req.name;
        sendToPeer(req.conn, { type: 'playerApproved', name: req.name });
        sendGameState(req.conn);
    }
    pendingRequests.splice(index, 1);
    renderPendingRequests();
    updateUserList();
}

function rejectPlayer(index) {
    const req = pendingRequests[index];
    sendToPeer(req.conn, { type: 'playerRejected' });
    pendingRequests.splice(index, 1);
    renderPendingRequests();
}

function renderPendingRequests() {
    const container = document.getElementById('pendingRequests');
    if (pendingRequests.length === 0) {
        container.innerHTML = '<p style="font-size: 0.85rem; color: var(--text-dim);">No requests</p>';
        return;
    }
    container.innerHTML = pendingRequests.map((req, idx) => {
        if (req.type === 'token') {
            return `<div class="request-item"><div class="request-info"><div class="request-name">${req.name}</div><div class="request-detail">Token: ${req.tokenData.icon}</div></div><div class="request-actions"><button class="btn btn-small btn-success" onclick="approveToken(${idx})">‚úì</button><button class="btn btn-small btn-danger" onclick="rejectToken(${idx})">‚úï</button></div></div>`;
        }
        return `<div class="request-item"><div class="request-info"><div class="request-name">${req.name}</div><div class="request-detail">Join request</div></div><div class="request-actions"><button class="btn btn-small btn-success" onclick="approvePlayer(${idx})">‚úì</button><button class="btn btn-small btn-danger" onclick="rejectPlayer(${idx})">‚úï</button></div></div>`;
    }).join('');
}

// TOKENS
function approveToken(index) {
    const req = pendingRequests[index];
    if (!req || req.type !== 'token') return;
    const token = { ...req.tokenData, owner: req.name, approved: true };
    stagingTokens.push(token);
    renderStagingTokens();
    sendToPeer(req.conn, { type: 'tokenApproved', token });
    broadcast({ type: 'tokenUpdate', tokens: [...stagingTokens, ...placedTokens] });
    pendingRequests.splice(index, 1);
    renderPendingRequests();
}

function rejectToken(index) {
    pendingRequests.splice(index, 1);
    renderPendingRequests();
}

function showTokenModal() {
    document.getElementById('tokenRequestModal').classList.add('active');
}

function closeTokenModal() {
    document.getElementById('tokenRequestModal').classList.remove('active');
}

function createToken() {
    const color = document.getElementById('tokenColor').value;
    const emoji = document.getElementById('tokenEmoji').value || '‚öîÔ∏è';
    if (isDM) {
        const token = { id: Date.now(), type: 'emoji', icon: emoji, color, size: 12, owner: 'DM', approved: true };
        stagingTokens.push(token);
        renderStagingTokens();
        closeTokenModal();
        broadcast({ type: 'tokenUpdate', tokens: [...stagingTokens, ...placedTokens] });
    }
}

function renderStagingTokens() {
    const container = document.getElementById('stagingTokens');
    container.innerHTML = stagingTokens.map(t => 
        `<div class="token-item" draggable="true" ondragstart="dragTokenStart(event, ${t.id})" style="background: ${t.color};">${t.icon}<div class="token-owner">${t.owner}</div></div>`
    ).join('');
    if (stagingTokens.length > 0) document.getElementById('stagingZone').style.display = 'flex';
}

function dragTokenStart(e, tokenId) {
    const token = stagingTokens.find(t => t.id === tokenId);
    e.dataTransfer.setData('application/json', JSON.stringify(token));
    draggedToken = token;
}

function toggleGridSnap() {
    gridSnapEnabled = document.getElementById('gridSnap').checked;
}

function snapToGrid(value) {
    if (!gridSnapEnabled) return value;
    const gridCenter = GRID_SNAP_SIZE / 2;
    return Math.round((value - gridCenter) / GRID_SNAP_SIZE) * GRID_SNAP_SIZE + gridCenter;
}

// DRAWING
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(panX, panY);
    ctx.scale(zoom, zoom);

    for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
            const x = col * GRID_SIZE;
            const y = row * GRID_SIZE;
            const key = `${col},${row}`;
            ctx.fillStyle = '#1a1f2e';
            ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
            if (gridCells[key]) ctx.drawImage(gridCells[key], x, y, GRID_SIZE, GRID_SIZE);
            ctx.strokeStyle = '#2a2f3e';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
            if (col === currentCellX && row === currentCellY && isDM) {
                ctx.strokeStyle = lockedCells[key] ? '#fbbf24' : '#8b5cf6';
                ctx.lineWidth = 4;
                ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
            }
        }
    }

    if (gridSnapEnabled) {
        ctx.strokeStyle = 'rgba(139, 92, 246, 0.15)';
        ctx.lineWidth = 1;
        for (let x = 0; x <= GRID_SIZE * 3; x += GRID_SNAP_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, GRID_SIZE * 3);
            ctx.stroke();
        }
        for (let y = 0; y <= GRID_SIZE * 3; y += GRID_SNAP_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(GRID_SIZE * 3, y);
            ctx.stroke();
        }
    }

    placedImages.forEach(pi => {
        ctx.save();
        ctx.translate(pi.x + pi.width / 2, pi.y + pi.height / 2);
        ctx.rotate(pi.rotation * Math.PI / 180);
        ctx.drawImage(pi.img, -pi.width / 2, -pi.height / 2, pi.width, pi.height);
        ctx.restore();
        if (isDM && selectedImage === pi) {
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(pi.x, pi.y, pi.width, pi.height);
            ctx.setLineDash([]);
            const handleSize = 8;
            ctx.fillStyle = '#8b5cf6';
            ctx.fillRect(pi.x - handleSize/2, pi.y - handleSize/2, handleSize, handleSize);
            ctx.fillRect(pi.x + pi.width - handleSize/2, pi.y - handleSize/2, handleSize, handleSize);
            ctx.fillRect(pi.x - handleSize/2, pi.y + pi.height - handleSize/2, handleSize, handleSize);
            ctx.fillRect(pi.x + pi.width - handleSize/2, pi.y + pi.height - handleSize/2, handleSize, handleSize);
            ctx.beginPath();
            ctx.arc(pi.x + pi.width / 2, pi.y - 20, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#fbbf24';
            ctx.fill();
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    });

    placedTokens.forEach(t => {
        const tokenSize = t.size || 12;
        const borderWidth = Math.max(2, tokenSize / 6);
        const fontSize = Math.max(12, tokenSize * 1.5);
        ctx.fillStyle = t.color;
        ctx.beginPath();
        ctx.arc(t.x, t.y, tokenSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = borderWidth;
        ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(t.icon || '‚öîÔ∏è', t.x, t.y);
    });

    ctx.restore();

    if (fogGroups[activeFogGroup]) {
        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(zoom, zoom);
        ctx.globalAlpha = isDM ? dmFogOpacity : 1.0;
        ctx.drawImage(fogGroups[activeFogGroup].canvas, 0, 0, GRID_SIZE * 3, GRID_SIZE * 3);
        ctx.restore();
    }

    updateMinimap();
}

// MAP BUILDER
function selectCell(x, y) {
    if (!isDM) return;
    currentCellX = x;
    currentCellY = y;
    const key = `${x},${y}`;
    if (gridCells[key]) {
        mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
        mapCtx.drawImage(gridCells[key], 0, 0);
    } else {
        mapCtx.fillStyle = '#f5f5dc';
        mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
    }
    updateGridDisplay();
    draw();
}

function updateGridDisplay() {
    document.getElementById('currentCell').textContent = gridNames[currentCellY][currentCellX];
}

function setTool(t) {
    if (t !== 'select') {
        selectedImage = null;
        draw();
    }
    tool = t;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    const toolBtn = document.getElementById(t + 'Btn');
    if (toolBtn) toolBtn.classList.add('active');
    const assetNames = { brush: 'Brush', fill: 'Fill', stamp: 'Stamp: ' + currentStamp, image: 'Place Image', select: 'Select & Move', eraser: eraserMode === 'content' ? 'Content' : 'Everything' };
    currentAsset = assetNames[t] || t;
    document.getElementById('currentAsset').textContent = currentAsset;
}

function updateColor(value) {
    color = value;
}

function importImageToCanvas(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            const cellX = currentCellX * GRID_SIZE + GRID_SIZE / 2;
            const cellY = currentCellY * GRID_SIZE + GRID_SIZE / 2;
            const maxSize = GRID_SIZE * 0.8;
            let width = img.width;
            let height = img.height;
            if (width > maxSize || height > maxSize) {
                const scale = Math.min(maxSize / width, maxSize / height);
                width *= scale;
                height *= scale;
            }
            const placedImg = { img, x: cellX - width / 2, y: cellY - height / 2, width, height, rotation: 0, gridX: currentCellX, gridY: currentCellY };
            placedImages.push(placedImg);
            selectedImage = placedImg;
            setTool('select');
            draw();
            broadcastImages();
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
    event.target.value = '';
}

function broadcastImages() {
    const imageData = placedImages.map(pi => ({ src: pi.img.src, x: pi.x, y: pi.y, width: pi.width, height: pi.height, rotation: pi.rotation, gridX: pi.gridX, gridY: pi.gridY }));
    broadcast({ type: 'imagesUpdate', images: imageData });
}

function setSize(v) {
    size = v;
    document.getElementById('sizeValue').textContent = v + 'px';
}

function saveHistory() {
    const imageData = mapCtx.getImageData(0, 0, mapCanvas.width, mapCanvas.height);
    if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
    }
    history.push(imageData);
    if (history.length > MAX_HISTORY) {
        history.shift();
    } else {
        historyIndex++;
    }
    updateHistoryButtons();
}

function undo() {
    if (historyIndex > 0) {
        historyIndex--;
        mapCtx.putImageData(history[historyIndex], 0, 0);
        updateHistoryButtons();
    }
}

function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        mapCtx.putImageData(history[historyIndex], 0, 0);
        updateHistoryButtons();
    }
}

function updateHistoryButtons() {
    document.getElementById('undoBtn').disabled = historyIndex <= 0;
    document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
}

function clearMapCanvas() {
    mapCtx.fillStyle = '#f5f5dc';
    mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
    saveHistory();
}

function submitCell() {
    const key = `${currentCellX},${currentCellY}`;
    const cellCanvas = document.createElement('canvas');
    cellCanvas.width = CELL_SIZE;
    cellCanvas.height = CELL_SIZE;
    const cellCtx = cellCanvas.getContext('2d');
    cellCtx.drawImage(mapCanvas, 0, 0);
    gridCells[key] = cellCanvas;
    draw();
    broadcast({ type: 'gridUpdate', cellX: currentCellX, cellY: currentCellY, imageData: cellCanvas.toDataURL() });
}

function deselectAllTools() {
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    tool = null;
    currentAsset = 'None';
    document.getElementById('currentAsset').textContent = currentAsset;
}

// MAP CANVAS DRAWING
mapCanvas.addEventListener('mousedown', (e) => {
    isDrawing = true;
    const rect = mapCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
    const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
    lastX = x;
    lastY = y;
    if (tool === 'brush') {
        mapCtx.beginPath();
        mapCtx.moveTo(x, y);
        mapCtx.strokeStyle = color;
        mapCtx.lineWidth = size;
        mapCtx.lineCap = 'round';
        mapCtx.lineJoin = 'round';
    } else if (tool === 'fill') {
        mapCtx.fillStyle = color;
        mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
        saveHistory();
        isDrawing = false;
    } else if (tool === 'stamp') {
        mapCtx.font = '48px Arial';
        mapCtx.textAlign = 'center';
        mapCtx.textBaseline = 'middle';
        mapCtx.fillText(currentStamp, x, y);
        saveHistory();
        isDrawing = false;
    } else if (tool === 'eraser') {
        mapCtx.save();
        if (eraserMode === 'content') {
            mapCtx.globalCompositeOperation = 'destination-out';
            mapCtx.strokeStyle = 'rgba(0,0,0,1)';
        } else {
            mapCtx.globalCompositeOperation = 'source-over';
            mapCtx.strokeStyle = '#f5f5dc';
        }
        mapCtx.beginPath();
        mapCtx.moveTo(x, y);
        mapCtx.lineWidth = size;
        mapCtx.lineCap = 'round';
        mapCtx.lineJoin = 'round';
    }
});

mapCanvas.addEventListener('mousemove', (e) => {
    if (!isDrawing) return;
    const rect = mapCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
    const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
    if (tool === 'brush' || tool === 'eraser') {
        mapCtx.lineTo(x, y);
        mapCtx.stroke();
    }
});

mapCanvas.addEventListener('mouseup', () => {
    if (isDrawing) {
        isDrawing = false;
        if (tool === 'eraser') mapCtx.restore();
        saveHistory();
    }
});

mapCanvas.addEventListener('mouseleave', () => {
    if (isDrawing) {
        isDrawing = false;
        if (tool === 'eraser') mapCtx.restore();
        saveHistory();
    }
});

// MAIN CANVAS INTERACTION
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left - panX) / zoom;
    const my = (e.clientY - rect.top - panY) / zoom;
    
    if (!fogMode && tool !== 'select') {
        for (let i = placedTokens.length - 1; i >= 0; i--) {
            const token = placedTokens[i];
            const tokenSize = token.size || 25;
            const dist = Math.hypot(mx - token.x, my - token.y);
            if (dist < tokenSize) {
                if (isDM || token.owner === myName) {
                    draggedPlacedToken = token;
                    tokenDragOffset = { x: mx - token.x, y: my - token.y };
                    return;
                }
            }
        }
    }
    
    if (isDM && tool === 'select') {
        if (selectedImage) {
            const rotX = selectedImage.x + selectedImage.width / 2;
            const rotY = selectedImage.y - 20;
            if (Math.hypot(mx - rotX, my - rotY) < 10) {
                imageResizeHandle = 'rotate';
                imageDragStart = { x: mx, y: my };
                return;
            }
            const handleSize = 8;
            const handles = [
                { type: 'nw', x: selectedImage.x, y: selectedImage.y },
                { type: 'ne', x: selectedImage.x + selectedImage.width, y: selectedImage.y },
                { type: 'sw', x: selectedImage.x, y: selectedImage.y + selectedImage.height },
                { type: 'se', x: selectedImage.x + selectedImage.width, y: selectedImage.y + selectedImage.height }
            ];
            for (let h of handles) {
                if (Math.abs(mx - h.x) < handleSize && Math.abs(my - h.y) < handleSize) {
                    imageResizeHandle = h.type;
                    imageDragStart = { x: mx, y: my, origWidth: selectedImage.width, origHeight: selectedImage.height, origX: selectedImage.x, origY: selectedImage.y };
                    return;
                }
            }
        }
        for (let i = placedImages.length - 1; i >= 0; i--) {
            const pi = placedImages[i];
            if (mx >= pi.x && mx <= pi.x + pi.width && my >= pi.y && my <= pi.y + pi.height) {
                selectedImage = pi;
                imageDragStart = { x: mx, y: my, imgX: pi.x, imgY: pi.y };
                draw();
                return;
            }
        }
        selectedImage = null;
        draw();
        return;
    }
    
    if (isDM && fogMode) {
        isFogDrawing = true;
        if (fogPaintMode === 'brush') {
            paintFog(mx, my);
        } else if (fogPaintMode === 'rect') {
            fogRectStart = { x: mx, y: my };
        }
        return;
    }
    
    lastX = e.clientX;
    lastY = e.clientY;
    isDrawing = true;
});

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left - panX) / zoom;
    const my = (e.clientY - rect.top - panY) / zoom;
    
    if (draggedPlacedToken) {
        draggedPlacedToken.x = snapToGrid(mx - tokenDragOffset.x);
        draggedPlacedToken.y = snapToGrid(my - tokenDragOffset.y);
        draw();
        return;
    }
    
    if (isDM && tool === 'select' && selectedImage && imageDragStart) {
        if (imageResizeHandle === 'rotate') {
            const centerX = selectedImage.x + selectedImage.width / 2;
            const centerY = selectedImage.y + selectedImage.height / 2;
            const angle = Math.atan2(my - centerY, mx - centerX) * 180 / Math.PI + 90;
            selectedImage.rotation = angle;
            draw();
            return;
        } else if (imageResizeHandle) {
            const dx = mx - imageDragStart.x;
            const dy = my - imageDragStart.y;
            if (imageResizeHandle === 'se') {
                selectedImage.width = imageDragStart.origWidth + dx;
                selectedImage.height = imageDragStart.origHeight + dy;
            } else if (imageResizeHandle === 'nw') {
                selectedImage.width = imageDragStart.origWidth - dx;
                selectedImage.height = imageDragStart.origHeight - dy;
                selectedImage.x = imageDragStart.origX + dx;
                selectedImage.y = imageDragStart.origY + dy;
            } else if (imageResizeHandle === 'ne') {
                selectedImage.width = imageDragStart.origWidth + dx;
                selectedImage.height = imageDragStart.origHeight - dy;
                selectedImage.y = imageDragStart.origY + dy;
            } else if (imageResizeHandle === 'sw') {
                selectedImage.width = imageDragStart.origWidth - dx;
                selectedImage.height = imageDragStart.origHeight + dy;
                selectedImage.x = imageDragStart.origX + dx;
            }
            if (selectedImage.width < 50) selectedImage.width = 50;
            if (selectedImage.height < 50) selectedImage.height = 50;
            draw();
            return;
        } else {
            selectedImage.x = imageDragStart.imgX + (mx - imageDragStart.x);
            selectedImage.y = imageDragStart.imgY + (my - imageDragStart.y);
            draw();
            return;
        }
    }
    
    if (isDM && isFogDrawing) {
        if (fogPaintMode === 'brush') {
            paintFog(mx, my);
        } else if (fogPaintMode === 'rect' && fogRectStart) {
            draw();
            ctx.save();
            const reveal = document.getElementById('revealMode').checked;
            ctx.strokeStyle = reveal ? '#10b981' : '#ef4444';
            ctx.lineWidth = 2 / zoom;
            ctx.setLineDash([5 / zoom, 5 / zoom]);
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);
            ctx.strokeRect(fogRectStart.x, fogRectStart.y, mx - fogRectStart.x, my - fogRectStart.y);
            ctx.restore();
        }
        return;
    }
    
    if (!isDrawing || fogMode || (isDM && tool === 'select') || draggedPlacedToken) return;
    panX += e.clientX - lastX;
    panY += e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;
    draw();
});

canvas.addEventListener('mouseup', (e) => {
    if (draggedPlacedToken) {
        broadcast({ type: 'tokenUpdate', tokens: [...stagingTokens, ...placedTokens] });
        draggedPlacedToken = null;
        tokenDragOffset = { x: 0, y: 0 };
    }
    if (imageDragStart) {
        imageDragStart = null;
        imageResizeHandle = null;
        broadcastImages();
    }
    if (isFogDrawing && fogPaintMode === 'rect' && fogRectStart) {
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left - panX) / zoom;
        const my = (e.clientY - rect.top - panY) / zoom;
        paintFogRect(fogRectStart.x, fogRectStart.y, mx, my);
        fogRectStart = null;
    }
    isFogDrawing = false;
    isDrawing = false;
});

canvas.addEventListener('dragover', (e) => e.preventDefault());

canvas.addEventListener('drop', (e) => {
    e.preventDefault();
    if (!draggedToken) return;
    const rect = canvas.getBoundingClientRect();
    const x = snapToGrid((e.clientX - rect.left - panX) / zoom);
    const y = snapToGrid((e.clientY - rect.top - panY) / zoom);
    const placedToken = { ...draggedToken, x, y };
    placedTokens.push(placedToken);
    stagingTokens = stagingTokens.filter(t => t.id !== draggedToken.id);
    renderStagingTokens();
    draw();
    broadcast({ type: 'tokenUpdate', tokens: [...stagingTokens, ...placedTokens] });
    draggedToken = null;
});

document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' && selectedImage && isDM) {
        const index = placedImages.indexOf(selectedImage);
        if (index > -1) {
            placedImages.splice(index, 1);
            selectedImage = null;
            draw();
            broadcastImages();
        }
    }
});

// FOG
function showFogGroupModal() {
    document.getElementById('fogGroupModal').classList.add('active');
}

function closeFogGroupModal() {
    document.getElementById('fogGroupModal').classList.remove('active');
}

function createFogGroup() {
    const name = document.getElementById('fogGroupName').value.trim();
    if (!name) return;
    const id = 'group_' + Date.now();
    const fogCanvas = document.createElement('canvas');
    fogCanvas.width = GRID_SIZE * 3;
    fogCanvas.height = GRID_SIZE * 3;
    const fogCtx = fogCanvas.getContext('2d');
    fogCtx.fillStyle = 'rgba(0,0,0,1)';
    fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
    fogGroups[id] = { name, canvas: fogCanvas };
    renderFogGroups();
    closeFogGroupModal();
    document.getElementById('fogGroupName').value = '';
}

function renderFogGroups() {
    const container = document.getElementById('fogGroups');
    container.innerHTML = Object.keys(fogGroups).map(id => `
        <div class="fog-group-item ${activeFogGroup === id ? 'active' : ''}">
            <span class="fog-group-name">${fogGroups[id].name}</span>
            <button class="btn btn-small ${activeFogGroup === id ? 'btn-primary' : ''}" onclick="setActiveFogGroup('${id}')">
                ${activeFogGroup === id ? 'Active' : 'Select'}
            </button>
        </div>
    `).join('');
}

function setActiveFogGroup(groupId) {
    activeFogGroup = groupId;
    renderFogGroups();
    draw();
}

function setFogPaintMode(mode) {
    fogPaintMode = mode;
}

function toggleFogMode() {
    if (!isDM) return;
    fogMode = !fogMode;
    const btn = document.getElementById('fogModeToggle');
    const controls = document.getElementById('fogControls');
    if (fogMode) {
        btn.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
        btn.style.borderColor = '#f97316';
        btn.textContent = 'üå´Ô∏è Fog Paint Mode: ON';
        controls.style.opacity = '1';
        controls.style.pointerEvents = 'all';
    } else {
        btn.style.background = '';
        btn.style.borderColor = '';
        btn.classList.add('btn-primary');
        btn.textContent = 'üå´Ô∏è Fog Paint Mode: OFF';
        controls.style.opacity = '0.5';
        controls.style.pointerEvents = 'none';
    }
}

function updateFogSize(value) {
    fogBrushSize = parseInt(value);
    document.getElementById('fogSizeValue').textContent = value + 'px';
}

function resetFog() {
    if (!isDM || !confirm('Reset fog?')) return;
    if (fogGroups[activeFogGroup]) {
        const ctx = fogGroups[activeFogGroup].canvas.getContext('2d');
        ctx.fillStyle = 'rgba(0,0,0,0.9)';
        ctx.fillRect(0, 0, fogGroups[activeFogGroup].canvas.width, fogGroups[activeFogGroup].canvas.height);
        draw();
        broadcast({ type: 'fogUpdate', group: activeFogGroup, fogData: fogGroups[activeFogGroup].canvas.toDataURL() });
    }
}

function paintFog(x, y) {
    if (!isDM || !fogGroups[activeFogGroup]) return;
    const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
    const reveal = document.getElementById('revealMode').checked;
    fogCtx.save();
    if (reveal) {
        fogCtx.globalCompositeOperation = 'destination-out';
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
    } else {
        fogCtx.globalCompositeOperation = 'source-over';
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
    }
    fogCtx.beginPath();
    fogCtx.arc(x, y, fogBrushSize, 0, Math.PI * 2);
    fogCtx.fill();
    fogCtx.restore();
    draw();
    broadcastFog();
}

function paintFogRect(x1, y1, x2, y2) {
    if (!isDM || !fogGroups[activeFogGroup]) return;
    const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
    const reveal = document.getElementById('revealMode').checked;
    fogCtx.save();
    if (reveal) {
        fogCtx.globalCompositeOperation = 'destination-out';
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
    } else {
        fogCtx.globalCompositeOperation = 'source-over';
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
    }
    fogCtx.fillRect(x1, y1, x2 - x1, y2 - y1);
    fogCtx.restore();
    draw();
    broadcastFog();
}

function broadcastFog() {
    if (!isDM) return;
    if (fogBroadcastTimeout) clearTimeout(fogBroadcastTimeout);
    fogBroadcastTimeout = setTimeout(() => {
        broadcast({ type: 'fogUpdate', group: activeFogGroup, fogData: fogGroups[activeFogGroup].canvas.toDataURL() });
        fogBroadcastTimeout = null;
    }, 100);
}

// GAME STATE
function sendGameState(conn) {
    const gridData = {};
    for (let key in gridCells) gridData[key] = gridCells[key].toDataURL();
    const fogData = {};
    for (let group in fogGroups) fogData[group] = fogGroups[group].canvas.toDataURL();
    const imagesData = placedImages.map(pi => ({ src: pi.img.src, x: pi.x, y: pi.y, width: pi.width, height: pi.height, rotation: pi.rotation, gridX: pi.gridX, gridY: pi.gridY }));
    sendToPeer(conn, {
        type: 'gameState',
        state: { gridCells: gridData, lockedCells, fogGroups: fogData, tokens: [...stagingTokens, ...placedTokens], placedImages: imagesData, zoom, panX, panY }
    });
}

function requestGameState(conn) {
    sendToPeer(conn, { type: 'requestState' });
}

function loadGameState(state) {
    gridCells = {};
    for (let key in state.gridCells) {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = CELL_SIZE;
            canvas.height = CELL_SIZE;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            gridCells[key] = canvas;
            draw();
        };
        img.src = state.gridCells[key];
    }
    for (let group in state.fogGroups) {
        if (!fogGroups[group]) {
            fogGroups[group] = { name: group, canvas: document.createElement('canvas') };
            fogGroups[group].canvas.width = GRID_SIZE * 3;
            fogGroups[group].canvas.height = GRID_SIZE * 3;
        }
        const img = new Image();
        img.onload = () => {
            const ctx = fogGroups[group].canvas.getContext('2d');
            ctx.clearRect(0, 0, fogGroups[group].canvas.width, fogGroups[group].canvas.height);
            ctx.drawImage(img, 0, 0);
            draw();
        };
        img.src = state.fogGroups[group];
    }
    if (state.tokens) {
        stagingTokens = [];
        placedTokens = [];
        state.tokens.forEach(token => {
            if (token.x !== undefined) placedTokens.push(token);
            else stagingTokens.push(token);
        });
        renderStagingTokens();
    }
    if (state.placedImages) {
        placedImages = [];
        state.placedImages.forEach(imgData => {
            const img = new Image();
            img.onload = () => {
                placedImages.push({ img, x: imgData.x, y: imgData.y, width: imgData.width, height: imgData.height, rotation: imgData.rotation, gridX: imgData.gridX, gridY: imgData.gridY });
                draw();
            };
            img.src = imgData.src;
        });
    }
    lockedCells = state.lockedCells || {};
    zoom = state.zoom || 1;
    panX = state.panX || 0;
    panY = state.panY || 0;
    document.getElementById('zoomSlider').value = zoom * 100;
    document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
    draw();
    updateMinimap();
}

function updateGridFromNetwork(data) {
    const img = new Image();
    img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = CELL_SIZE;
        canvas.height = CELL_SIZE;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        gridCells[`${data.cellX},${data.cellY}`] = canvas;
        draw();
        updateMinimap();
    };
    img.src = data.imageData;
}

function updateFogFromNetwork(data) {
    if (fogGroups[data.group]) {
        const img = new Image();
        img.onload = () => {
            const ctx = fogGroups[data.group].canvas.getContext('2d');
            ctx.clearRect(0, 0, fogGroups[data.group].canvas.width, fogGroups[data.group].canvas.height);
            ctx.drawImage(img, 0, 0);
            draw();
        };
        img.src = data.fogData;
    }
}

// CAMPAIGN EXPORT
function exportCampaign() {
    if (!isDM) return;
    const gridData = {};
    for (let key in gridCells) gridData[key] = gridCells[key].toDataURL();
    const fogData = {};
    for (let group in fogGroups) fogData[group] = { name: fogGroups[group].name, canvas: fogGroups[group].canvas.toDataURL() };
    const imagesData = placedImages.map(pi => ({ src: pi.img.src, x: pi.x, y: pi.y, width: pi.width, height: pi.height, rotation: pi.rotation, gridX: pi.gridX, gridY: pi.gridY }));
    const campaignData = {
        version: '4.1',
        name: prompt('Campaign name:', 'My Campaign') || 'Untitled Campaign',
        sessionId: roomCode,
        exported: new Date().toISOString(),
        gridCells: gridData,
        lockedCells,
        fogGroups: fogData,
        activeFogGroup,
        stagingTokens,
        placedTokens,
        placedImages: imagesData,
        zoom, panX, panY,
        currentCellX, currentCellY,
        gridSnapEnabled
    };
    const dataStr = JSON.stringify(campaignData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${campaignData.name.replace(/[^a-z0-9]/gi, '_')}_${Date.now()}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    alert('‚úÖ Campaign exported!');
}

// UI
function toggleConnectionPanel() {
    const panel = document.getElementById('connectionPanel');
    const tab = document.getElementById('connectionTab');
    const arrow = document.getElementById('tabArrow');
    if (panel.classList.contains('open')) {
        panel.classList.remove('open');
        tab.classList.remove('open');
        arrow.textContent = '‚ñº';
    } else {
        panel.classList.add('open');
        tab.classList.add('open');
        arrow.textContent = '‚ñ≤';
    }
}

function updateConnectionStatus(text, connected) {
    document.getElementById('statusText').textContent = text;
    const indicators = [document.getElementById('statusIndicator'), document.getElementById('tabIndicator')];
    indicators.forEach(ind => {
        if (connected) ind.classList.add('connected');
        else ind.classList.remove('connected');
    });
}

function updateUserList() {
    const container = document.getElementById('userList');
    const users = [];
    if (isDM) users.push({ name: myName, role: 'DM' });
    connections.forEach(({ name, role, approved }) => {
        if (approved) users.push({ name, role: role === 'dm' ? 'DM' : 'Player' });
    });
    if (users.length === 0) {
        container.innerHTML = '<p style="font-size: 0.85rem; color: var(--text-dim);">No users</p>';
        return;
    }
    container.innerHTML = users.map(u => `<div class="user-item"><span>${u.name}</span><span class="user-role">${u.role}</span></div>`).join('');
}

function copyRoomCode() {
    if (!roomCode) return;
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(roomCode).then(() => {
            const elem = document.getElementById('roomCode');
            const old = elem.textContent;
            elem.textContent = '‚úì Copied!';
            elem.style.background = 'var(--accent)';
            elem.style.color = 'white';
            setTimeout(() => {
                elem.textContent = old;
                elem.style.background = 'var(--bg-dark)';
                elem.style.color = 'var(--accent)';
            }, 2000);
        });
    }
}

function toggleDMPanel() {
    document.getElementById('dmPanel').classList.toggle('open');
}

function updateMinimap() {
    const grid = document.getElementById('minimapGrid');
    let html = '';
    for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
            const key = `${col},${row}`;
            const classes = ['minimap-cell'];
            if (gridCells[key]) classes.push('has-content');
            if (lockedCells[key]) classes.push('locked');
            if (col === currentCellX && row === currentCellY) classes.push('current');
            html += `<div class="${classes.join(' ')}" onclick="minimapNavigate(${col}, ${row})"></div>`;
        }
    }
    grid.innerHTML = html;
}

function minimapNavigate(col, row) {
    const centerX = (col + 0.5) * GRID_SIZE;
    const centerY = (row + 0.5) * GRID_SIZE;
    panX = canvas.width / 2 - centerX * zoom;
    panY = canvas.height / 2 - centerY * zoom;
    draw();
}

function recenterView() {
    panX = (canvas.width - GRID_SIZE * 3 * zoom) / 2;
    panY = (canvas.height - GRID_SIZE * 3 * zoom) / 2;
    draw();
}

function resetZoom() {
    zoom = 1;
    document.getElementById('zoomSlider').value = 100;
    document.getElementById('zoomValue').textContent = '100%';
    recenterView();
}

function setZoom(v) {
    zoom = v / 100;
    document.getElementById('zoomValue').textContent = Math.round(v) + '%';
    draw();
}

function toggleMinimapCollapse() {
    document.getElementById('minimap').classList.toggle('collapsed');
}

function toggleMinimapDock() {
    minimapDocked = !minimapDocked;
    const container = document.getElementById('minimapContainer');
    const btn = document.getElementById('dockBtn');
    if (minimapDocked) {
        container.classList.add('docked');
        btn.textContent = 'üîí';
    } else {
        container.classList.remove('docked');
        btn.textContent = 'üîì';
    }
}

const minimapContainer = document.getElementById('minimapContainer');
minimapContainer.addEventListener('mousedown', (e) => {
    if (minimapDocked || e.target.closest('.minimap-btn') || e.target.closest('.minimap-cell')) return;
    minimapDragOffset = { x: e.clientX - minimapContainer.offsetLeft, y: e.clientY - minimapContainer.offsetTop };
});

document.addEventListener('mousemove', (e) => {
    if (!minimapDragOffset || minimapDocked) return;
    minimapContainer.style.left = (e.clientX - minimapDragOffset.x) + 'px';
    minimapContainer.style.top = (e.clientY - minimapDragOffset.y) + 'px';
    minimapContainer.style.bottom = 'auto';
});

document.addEventListener('mouseup', () => {
    minimapDragOffset = null;
});

document.addEventListener('DOMContentLoaded', () => {
    try {
        init();
        console.log('‚úÖ VTT v4.1 - Session Persistence Fixed - Ready!');
    } catch (err) {
        console.error('Init error:', err);
    }
});
</script>
</body>
</html>
