<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The Fractured Sky VTT v4.0 - FINAL BUILD</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Firebase v9 compat (matches existing firebase.X() call style) -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0e1a;
            --bg-card: #151928;
            --bg-hover: #1f2537;
            --accent: #8b5cf6;
            --accent-secondary: #ec4899;
            --gold: #fbbf24;
            --text: #e5e7eb;
            --text-dim: #9ca3af;
            --border: rgba(139, 92, 246, 0.2);
            --success: #10b981;
            --danger: #ef4444;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }

        /* HEADER */
        .header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            position: relative;
            z-index: 100;
        }

        .title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .campaign-badge {
            padding: 0.5rem 1rem;
            background: var(--bg-hover);
            border-radius: 8px;
            border: 1px solid var(--border);
            color: var(--gold);
            font-weight: 600;
            font-size: 0.9rem;
        }

        /* BUTTONS */
        .btn {
            padding: 0.6rem 1.2rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            font-family: 'Inter', sans-serif;
        }

        .btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            transform: translateY(-1px);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            border: none;
            color: white;
        }

        .btn-small {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        .btn-success {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }

        /* WELCOME SCREEN */
        .welcome-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f3a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        .welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .welcome-content {
            text-align: center;
            padding: 3rem;
        }

        .welcome-title {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            color: var(--text-dim);
            margin-bottom: 3rem;
        }

        .welcome-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .welcome-btn {
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: 12px;
            cursor: pointer;
            border: none;
            font-weight: 600;
            transition: all 0.3s;
            font-family: 'Inter', sans-serif;
        }

        .welcome-btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            color: white;
        }

        .welcome-btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.5);
        }

        .welcome-btn-secondary {
            background: var(--bg-card);
            color: var(--text);
            border: 2px solid var(--border);
        }

        .welcome-btn-secondary:hover {
            border-color: var(--accent);
            background: var(--bg-hover);
        }

        /* MODALS */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.3s;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .modal-content {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .modal-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-dim);
            font-weight: 500;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.95rem;
            font-family: 'Inter', sans-serif;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .error, .success, .info {
            padding: 0.75rem;
            border-radius: 6px;
            margin: 1rem 0;
            display: none;
        }

        .error { background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); color: var(--danger); }
        .success { background: rgba(16, 185, 129, 0.1); border: 1px solid var(--success); color: var(--success); }
        .info { background: rgba(139, 92, 246, 0.1); border: 1px solid var(--accent); color: var(--accent); }

        .error.show, .success.show, .info.show { display: block; }

        /* CONNECTION TAB */
        .connection-tab-container {
            position: fixed;
            top: 70px;
            left: 20px;
            z-index: 501;
            display: none;
        }

        .connection-tab {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-top: none;
            padding: 0.5rem 1.5rem;
            border-radius: 0 0 8px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .connection-tab:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .connection-tab.open {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .connection-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--danger);
        }

        .connection-indicator.connected {
            background: var(--success);
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* CONNECTION PANEL */
        .connection-panel {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border-bottom: 2px solid var(--border);
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s;
            z-index: 500;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }

        .connection-panel.open {
            max-height: 400px;
            padding: 1.5rem;
        }

        .connection-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .connection-section {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
        }

        .connection-section h3 {
            color: var(--gold);
            margin-bottom: 0.75rem;
            font-size: 1rem;
        }

        .room-code {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-family: monospace;
            font-size: 0.85rem;
            word-break: break-all;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            color: var(--accent);
        }

        .room-code:hover {
            border-color: var(--accent);
            transform: scale(1.02);
        }

        .user-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .user-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: var(--bg-dark);
            border-radius: 6px;
        }

        .user-role {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: var(--accent);
            color: white;
        }

        /* MAIN LAYOUT */
        .container {
            display: flex;
            height: calc(100vh - 70px);
        }

        .main-area {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .tabletop {
            flex: 1;
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }

        .tabletop-header {
            padding: 1rem 1.5rem;
            background: var(--bg-hover);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-name {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .slider {
            width: 120px;
            height: 4px;
            background: var(--bg-dark);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        /* CANVAS */
        .canvas-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a1f2e 0%, var(--bg-dark) 100%);
            overflow: hidden;
        }

        #mainCanvas {
            display: block;
            cursor: grab;
        }

        #mainCanvas:active {
            cursor: grabbing;
        }

        /* TOKEN STAGING ZONE */
        .staging-zone {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 2px solid var(--gold);
            border-radius: 12px;
            padding: 1rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            max-width: 80%;
            overflow-x: auto;
            z-index: 50;
        }

        .staging-label {
            font-size: 0.85rem;
            color: var(--gold);
            font-weight: 600;
            white-space: nowrap;
        }

        .staging-tokens {
            display: flex;
            gap: 0.5rem;
        }

        .token-item {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--border);
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            flex-shrink: 0;
            transition: all 0.2s;
            position: relative;
        }

        .token-item:hover {
            transform: scale(1.1);
            border-color: var(--accent);
            z-index: 10;
        }

        .token-owner {
            position: absolute;
            bottom: -20px;
            font-size: 0.65rem;
            color: var(--text-dim);
            white-space: nowrap;
        }

        /* MINIMAP NAVIGATOR */
        .minimap-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 600;
            cursor: move;
        }

        .minimap-container.docked {
            cursor: default;
        }

        .minimap {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 0.75rem;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            width: 180px;
            transition: all 0.3s;
        }

        .minimap.collapsed {
            width: auto;
            padding: 0.5rem 1rem;
        }

        .minimap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .minimap.collapsed .minimap-header {
            margin-bottom: 0;
        }

        .minimap-title {
            font-size: 0.75rem;
            color: var(--gold);
            font-weight: 600;
        }

        .minimap-controls {
            display: flex;
            gap: 0.25rem;
        }

        .minimap-btn {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            width: 20px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: all 0.2s;
        }

        .minimap-btn:hover {
            background: var(--accent);
            color: white;
        }

        .minimap-content {
            display: block;
        }

        .minimap.collapsed .minimap-content {
            display: none;
        }

        .minimap-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 2px;
            margin-bottom: 0.5rem;
        }

        .minimap-cell {
            aspect-ratio: 1;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s;
            position: relative;
        }

        .minimap-cell:hover {
            border-color: var(--accent);
            transform: scale(1.1);
            z-index: 1;
        }

        .minimap-cell.has-content {
            background: var(--accent);
            opacity: 0.6;
        }

        .minimap-cell.locked::after {
            content: 'üîí';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
        }

        .minimap-cell.current {
            border: 2px solid var(--gold);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        .minimap-actions {
            display: flex;
            gap: 0.25rem;
        }

        .minimap-action-btn {
            flex: 1;
            padding: 0.4rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.2s;
            color: var(--text);
            text-align: center;
        }

        .minimap-action-btn:hover {
            background: var(--accent);
            color: white;
        }

        /* DM PANEL */
        .dm-panel {
            width: 420px;
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s;
            box-shadow: -4px 0 24px rgba(0,0,0,0.4);
        }

        .dm-panel.open {
            transform: translateX(0);
        }

        .dm-header {
            position: sticky;
            top: 0;
            background: var(--bg-hover);
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .dm-header h2 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
        }

        .dm-content {
            padding: 1rem;
        }

        .section {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s;
        }

        .section.active {
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
            background: rgba(139, 92, 246, 0.05);
        }

        .section h3 {
            margin-bottom: 0.75rem;
            color: var(--gold);
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin: 0.75rem 0;
        }

        .tool-btn {
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .tool-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0.75rem 0;
        }

        .control-row label {
            min-width: 60px;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        input[type="color"] {
            width: 50px;
            height: 36px;
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            background: var(--bg-dark);
        }

        .grid-selector {
            background: var(--bg-dark);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border: 2px solid var(--border);
        }

        .grid-info {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .grid-info .current {
            color: var(--accent);
            font-weight: 600;
            font-size: 1.1rem;
        }

        .grid-nav {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.5rem;
        }

        #mapCanvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: white;
            cursor: crosshair;
            margin: 0.5rem 0;
        }

        .history-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .asset-indicator {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--text-dim);
            text-align: center;
            margin-top: 0.5rem;
        }

        .asset-indicator .current-asset {
            color: var(--accent);
            font-weight: 600;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .fog-groups {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin: 0.75rem 0;
        }

        .fog-group-item {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 0.75rem;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fog-group-item.active {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }

        .fog-group-name {
            font-weight: 600;
            color: var(--text);
        }

        .fog-group-controls {
            display: flex;
            gap: 0.5rem;
        }

        .pending-requests {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .request-item {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .request-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .request-name {
            font-weight: 600;
            color: var(--text);
        }

        .request-detail {
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .request-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }

        /* UTILITY */
        .hidden {
            display: none !important;
        }

        /* RESUME PROMPT */
        .resume-prompt {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            text-align: left;
        }
        .resume-prompt-title {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .resume-prompt-name {
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--gold);
            margin-bottom: 0.75rem;
        }
        .resume-buttons {
            display: flex;
            gap: 0.5rem;
        }
        .resume-btn {
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            border: none;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s;
        }
        .resume-btn-yes {
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            color: white;
        }
        .resume-btn-no {
            background: var(--bg-hover);
            color: var(--text-dim);
            border: 1px solid var(--border);
        }
        .resume-btn:hover { transform: translateY(-1px); }
        .welcome-divider {
            color: var(--text-dim);
            font-size: 0.8rem;
            margin: 1rem 0;
            position: relative;
        }
        .welcome-divider::before, .welcome-divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 80px;
            height: 1px;
            background: var(--border);
        }
        .welcome-divider::before { right: calc(50% + 1.5rem); }
        .welcome-divider::after { left: calc(50% + 1.5rem); }

        /* CHARACTER SHEET OVERLAY */
        .char-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f3a 100%);
            z-index: 20000;
            display: none;
            overflow-y: auto;
        }
        .char-overlay.active { display: block; }
        .char-header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .char-header h1 {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .char-body {
            max-width: 900px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        .char-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            margin-bottom: 1rem;
        }
        .char-section h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            margin-bottom: 1rem;
            font-size: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }
        .char-grid-6 {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.75rem;
        }
        .char-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
        }
        .char-grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        .ability-block {
            background: var(--bg-hover);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 0.75rem;
            text-align: center;
            transition: border-color 0.2s;
        }
        .ability-block:hover { border-color: var(--accent); }
        .ability-name {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
        }
        .ability-score {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text);
            line-height: 1.2;
        }
        .ability-score input {
            width: 100%;
            font-size: 2rem;
            font-weight: 700;
            color: var(--text);
            background: transparent;
            border: none;
            text-align: center;
            font-family: 'Inter', sans-serif;
            outline: none;
        }
        .ability-mod {
            font-size: 1.1rem;
            color: var(--accent);
            font-weight: 700;
        }
        .stat-block {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            text-align: center;
        }
        .stat-block label {
            display: block;
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }
        .stat-block input {
            width: 100%;
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text);
            background: transparent;
            border: none;
            text-align: center;
            font-family: 'Inter', sans-serif;
            outline: none;
        }
        .char-input {
            width: 100%;
            padding: 0.6rem 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }
        .char-input:focus { outline: none; border-color: var(--accent); }
        .char-label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 0.35rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .skill-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.4rem;
        }
        .skill-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem;
            border-radius: 5px;
            transition: background 0.15s;
        }
        .skill-item:hover { background: var(--bg-hover); }
        .skill-item input[type="checkbox"] { accent-color: var(--accent); width: 14px; height: 14px; }
        .skill-item .skill-mod {
            font-size: 0.75rem;
            color: var(--accent);
            font-weight: 700;
            min-width: 28px;
        }
        .skill-item .skill-name { font-size: 0.8rem; color: var(--text); }
        .skill-item .skill-attr { font-size: 0.7rem; color: var(--text-dim); }
        .hp-track {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .hp-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: var(--bg-hover);
            color: var(--text);
            cursor: pointer;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .hp-btn:hover { background: var(--accent); border-color: var(--accent); }
        .char-list-panel {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .char-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 0.75rem;
            background: var(--bg-dark);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .char-list-item:hover { border-color: var(--accent); }
        .char-list-item.active { border-color: var(--gold); background: rgba(251,191,36,0.05); }
        .char-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.75rem;
        }
        .char-tab {
            padding: 0.4rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            border: 1px solid transparent;
            transition: all 0.2s;
            color: var(--text-dim);
        }
        .char-tab.active { background: var(--accent); color: white; border-color: var(--accent); }
        .char-tab-content { display: none; }
        .char-tab-content.active { display: block; }
        .death-saves {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .death-save-pip {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.15s;
        }
        .death-save-pip.success.filled { background: var(--success); border-color: var(--success); }
        .death-save-pip.failure.filled { background: var(--danger); border-color: var(--danger); }
        .notes-textarea {
            width: 100%;
            min-height: 120px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            padding: 0.75rem;
            resize: vertical;
        }
        .notes-textarea:focus { outline: none; border-color: var(--accent); }

        /* MUSIC PLAYER */
        .music-panel {
            position: fixed;
            bottom: 20px;
            right: 220px;
            width: 300px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            z-index: 600;
            display: none;
            cursor: move;
            user-select: none;
        }
        .music-panel.visible { display: block; }
        .music-header {
            padding: 0.75rem 1rem;
            background: var(--bg-hover);
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }
        .music-header-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--gold);
        }
        .music-now-playing {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            color: var(--text-dim);
            border-bottom: 1px solid var(--border);
            min-height: 28px;
        }
        .music-now-playing .track-name { color: var(--accent); font-weight: 600; }
        .music-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            padding: 0.75rem;
        }
        .music-btn {
            padding: 0.6rem 0.5rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text);
            transition: all 0.2s;
            font-family: 'Inter', sans-serif;
        }
        .music-btn:hover { border-color: var(--accent); background: rgba(139,92,246,0.1); }
        .music-btn.playing { background: var(--accent); border-color: var(--accent); color: white; animation: pulse-glow 2s infinite; }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139,92,246,0.4); }
            50% { box-shadow: 0 0 0 6px rgba(139,92,246,0); }
        }
        .music-btn .music-emoji { font-size: 1.2rem; display: block; margin-bottom: 0.25rem; }
        .music-controls {
            padding: 0.5rem 0.75rem 0.75rem;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .music-vol {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            accent-color: var(--accent);
        }
        .music-stop-btn {
            padding: 0.35rem 0.75rem;
            background: var(--danger);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            transition: opacity 0.2s;
        }
        .music-stop-btn:hover { opacity: 0.8; }

        /* CO-DM BADGE */
        .user-role.co-dm { background: #f97316; }
    </style>
</head>
<body>
    <!-- WELCOME SCREEN -->
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-content" style="max-width: 520px; width: 90%;">
            <div class="welcome-title">‚öîÔ∏è THE FRACTURED SKY</div>
            <div class="welcome-subtitle">Ultimate Virtual Tabletop v4.0 FINAL</div>
            <div class="welcome-buttons" id="welcomeButtons" style="flex-wrap: wrap; gap: 0.75rem; justify-content: center;">
                <button class="welcome-btn welcome-btn-primary" onclick="showDMLogin()">üé≠ Create Room (DM)</button>
                <button class="welcome-btn" style="background:linear-gradient(135deg,#f97316,#ea580c);color:white;border:none;" onclick="showCoDMLogin()">üßô Join as Co-DM</button>
                <button class="welcome-btn welcome-btn-secondary" onclick="showPlayerLogin()">üë§ Join Room (Player)</button>
                <button class="welcome-btn welcome-btn-secondary" onclick="showCharSheet()">üìú My Characters</button>
            </div>
            <div id="welcomeReconnect" style="display:none; text-align:center;">
                <p id="welcomeReconnectMsg" style="color:var(--text-dim); margin-bottom:1rem; font-size:0.95rem;"></p>
                <div style="display:flex; gap:0.75rem; justify-content:center; flex-wrap:wrap;">
                    <button class="welcome-btn welcome-btn-secondary" onclick="cancelAutoReconnect()">‚úï Start Fresh Instead</button>
                </div>
            </div>
            <p style="position: absolute; bottom: 20px; width: 100%; text-align: center; font-size: 0.75rem; color: var(--text-dim);">
                v4.0 ‚Ä¢ Multi-DM ‚Ä¢ Character Sheets ‚Ä¢ Ambient Music
            </p>
        </div>
    </div>

    <!-- DM LOGIN MODAL -->
    <div class="modal" id="dmModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üßô</div>
                <div class="modal-title">Dungeon Master</div>
            </div>
            <form onsubmit="dmLogin(event)">
                <div class="form-group">
                    <label>USERNAME</label>
                    <input type="text" id="dmUser" placeholder="Wizard" required>
                </div>
                <div class="form-group">
                    <label>PASSWORD</label>
                    <input type="password" id="dmPass" placeholder="FracturedSky2025!" required>
                </div>
                <div class="form-group">
                    <label>SESSION ID (Optional - leave blank for new session)</label>
                    <input type="text" id="sessionId" placeholder="Paste previous session ID to rejoin">
                    <p style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.25rem;">üí° Save your session ID to rejoin this campaign later!</p>
                </div>
                <div class="error" id="dmError">Invalid credentials</div>
                <div class="info" id="dmInfo" style="display: none;">Rejoining previous session...</div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">LOGIN & CREATE ROOM</button>
                <button type="button" class="btn" onclick="closeDMModal()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <!-- PLAYER LOGIN MODAL -->
    <div class="modal" id="playerModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üë§</div>
                <div class="modal-title">Join as Player</div>
            </div>
            <form onsubmit="playerLogin(event)">
                <div class="form-group">
                    <label>YOUR NAME</label>
                    <input type="text" id="playerName" placeholder="Enter character name" required>
                </div>
                <div class="form-group">
                    <label>ROOM CODE</label>
                    <input type="text" id="roomCodeInput" placeholder="Paste full room code" required>
                </div>
                <div class="error" id="playerError">Connection failed</div>
                <div class="success" id="playerSuccess">Request sent! Waiting for DM approval...</div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">REQUEST TO JOIN</button>
                <button type="button" class="btn" onclick="closePlayerModal()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <!-- TOKEN REQUEST MODAL (DM) -->
    <div class="modal" id="tokenRequestModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üé≤</div>
                <div class="modal-title">Create Token</div>
            </div>
            <div class="form-group">
                <label>TOKEN TYPE</label>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <button class="btn btn-primary" onclick="setTokenType('emoji')" id="emojiTokenBtn" style="flex: 1;">Emoji</button>
                    <button class="btn" onclick="setTokenType('image')" id="imageTokenBtn" style="flex: 1;">Image</button>
                </div>
            </div>
            <div id="emojiTokenInputs">
                <div class="form-group">
                    <label>TOKEN EMOJI</label>
                    <input type="text" id="tokenEmoji" placeholder="‚öîÔ∏è" maxlength="2">
                </div>
            </div>
            <div id="imageTokenInputs" style="display: none;">
                <div class="form-group">
                    <label>TOKEN IMAGE</label>
                    <input type="file" id="tokenImageFile" accept="image/*" style="width: 100%; padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text);">
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-dim);">Upload PNG, JPG, or GIF (will be resized to 60x60)</div>
                </div>
            </div>
            <div class="form-group">
                <label>TOKEN COLOR</label>
                <input type="color" id="tokenColor" value="#e74c3c">
            </div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="createToken()" style="flex: 1;">Create</button>
                <button class="btn" onclick="closeTokenModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- FOG GROUP MODAL -->
    <div class="modal" id="fogGroupModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üë•</div>
                <div class="modal-title">Create Fog Group</div>
            </div>
            <div class="form-group">
                <label>GROUP NAME</label>
                <input type="text" id="fogGroupName" placeholder="e.g., Party A, Solo Explorer" required>
            </div>
            <div class="info">Players in this group will share fog visibility</div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="createFogGroup()" style="flex: 1;">Create Group</button>
                <button class="btn" onclick="closeFogGroupModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- CO-DM LOGIN MODAL -->
    <div class="modal" id="coDMModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üßô</div>
                <div class="modal-title">Join as Co-DM</div>
            </div>
            <p style="font-size:0.85rem;color:var(--text-dim);margin-bottom:1rem;text-align:center;">
                Co-DMs can edit the map, move tokens, and paint fog alongside the host DM.
            </p>
            <form onsubmit="coDMLogin(event)">
                <div class="form-group">
                    <label>YOUR NAME</label>
                    <input type="text" id="coDMName" placeholder="Second DM" required>
                </div>
                <div class="form-group">
                    <label>ROOM CODE</label>
                    <input type="text" id="coDMRoomCode" placeholder="Paste host DM's room code" required>
                </div>
                <div class="form-group">
                    <label>DM PASSWORD</label>
                    <input type="password" id="coDMPass" placeholder="FracturedSky2025!" required>
                </div>
                <div class="error" id="coDMError">Invalid password or connection failed</div>
                <button type="submit" class="btn btn-primary" style="width:100%;">JOIN AS CO-DM</button>
                <button type="button" class="btn" onclick="closeCoDMModal()" style="width:100%;margin-top:0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <!-- HEADER -->
    <div class="header">
        <div class="title">‚öîÔ∏è THE FRACTURED SKY</div>
        <div class="campaign-badge" id="campaignBadge" style="display: none;">Campaign Name</div>
        <div class="header-actions">
            <div id="firebaseSection" style="display: none; align-items: center; gap: 0.4rem;">
                <span id="firebaseStatus" style="font-size: 0.75rem; color: var(--text-dim);"></span>
            </div>
            <button class="btn" id="musicToggleBtn" onclick="toggleMusicPanel()" style="display:none;" title="Jukebox">üéµ Music</button>
            <button class="btn" id="charSheetBtn" onclick="showCharSheet()" title="Character Sheet">üìú Characters</button>
            <button class="btn" id="dmControlsBtn" onclick="toggleDMPanel()" style="display: none;">üé≠ DM Controls</button>
        </div>
    </div>

    <!-- CONNECTION TAB -->
    <div class="connection-tab-container" id="connectionTabContainer">
        <div class="connection-tab" onclick="toggleConnectionPanel()" id="connectionTab">
            <div class="connection-indicator" id="tabIndicator"></div>
            <span id="tabText">Connection</span>
            <span id="tabArrow">‚ñº</span>
        </div>
    </div>

    <!-- CONNECTION PANEL -->
    <div class="connection-panel" id="connectionPanel">
        <div class="connection-content">
            <div class="connection-section" id="roomCodeSection" style="display: none;">
                <h3>üé≠ Room Code</h3>
                <p style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Share this code with players:</p>
                <div class="room-code" id="roomCode" onclick="copyRoomCode()" style="user-select: text; cursor: pointer;" title="Click to copy">----</div>
                <p style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem; text-align: center;">
                    üí° Click to copy ‚Ä¢ Or select text manually (Ctrl+C)
                </p>
            </div>
            <div class="connection-section">
                <h3>üì° Status</h3>
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                    <div class="connection-indicator" id="statusIndicator"></div>
                    <span id="statusText">Disconnected</span>
                </div>
                <button id="startFreshBtn" onclick="cancelAutoReconnect()" style="display:none; margin-top:0.6rem; width:100%; padding:0.45rem 0.75rem; background:#6b7280; color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:0.85rem;">‚úï Start Fresh / Change Session</button>
            </div>
            <div class="connection-section" id="firebaseStatusSection" style="display: none;">
                <h3>üî• Cloud Sync</h3>
                <div style="padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                    <span id="firebaseStatusPanel" style="font-size: 0.85rem; color: var(--text-dim);">Connecting...</span>
                </div>
            </div>
            <div class="connection-section">
                <h3>üë• Connected Users</h3>
                <div class="user-list" id="userList">
                    <p style="font-size: 0.85rem; color: var(--text-dim);">No users</p>
                </div>
            </div>
            <div class="connection-section">
                <button onclick="cancelAutoReconnect()" style="width:100%; padding:0.55rem 0.75rem; background:#dc2626; color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:0.9rem; font-weight:600; letter-spacing:0.03em;">üö™ Leave Session</button>
            </div>
        </div>
    </div>
    <!-- Hidden stub so clearDMSession/clearPlayerSession never throw on missing element -->
    <div id="resumeArea" style="display:none;"></div>

    <!-- MAIN CONTAINER -->
    <div class="container">
        <div class="main-area">
            <div class="tabletop">
                <div class="tabletop-header">
                    <div class="session-name">Session</div>
                    <div class="zoom-controls">
                        <span style="font-size: 0.9rem; color: var(--text-dim);">Zoom:</span>
                        <input type="range" class="slider" id="zoomSlider" min="25" max="200" value="100" oninput="setZoom(this.value)">
                        <span id="zoomValue" style="min-width: 50px; font-size: 0.9rem;">100%</span>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                    
                    <!-- TOKEN STAGING ZONE -->
                    <div class="staging-zone" id="stagingZone" style="display: none;">
                        <div class="staging-label">üé≤ TOKENS</div>
                        <div class="staging-tokens" id="stagingTokens"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DM PANEL -->
        <div class="dm-panel" id="dmPanel">
            <div class="dm-header">
                <h2>üé≠ DM Controls</h2>
                <button class="btn btn-small" onclick="toggleDMPanel()">‚úï</button>
            </div>
            <div class="dm-content">
                <!-- PLAYER REQUESTS ‚Äî always at top so DM cannot miss them -->
                <div class="section" id="requestsSection">
                    <h3>üì¨ Player Requests</h3>
                    <div class="pending-requests" id="pendingRequests">
                        <p style="font-size: 0.85rem; color: var(--text-dim);">No pending requests</p>
                    </div>
                </div>

                <!-- CAMPAIGN MANAGER -->
                <div class="section" id="campaignSection">
                    <h3>üíæ Campaign Manager</h3>

                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Export/Import Campaign:</div>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="exportCampaign()" style="flex: 1;">üì• Export .JSON</button>
                            <button class="btn" onclick="document.getElementById('importFile').click()" style="flex: 1;">üì§ Import .JSON</button>
                        </div>
                        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importCampaign(event)">
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Cloud Campaign Link (Google Drive, Dropbox, etc.):</div>
                        <input type="text" id="cloudLink" placeholder="Paste shareable link here" style="width: 100%; padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 0.85rem; margin-bottom: 0.5rem;">
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="saveCloudLink()" style="flex: 1;">üíæ Save Link</button>
                            <button class="btn" onclick="openCloudLink()" style="flex: 1;">üîó Open Link</button>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                            üí° Upload exported .json to Google Drive ‚Üí Get shareable link ‚Üí Paste here ‚Üí Save<br>
                            Other DMs can use this link to access the campaign!
                        </div>
                    </div>

                    <div class="success" id="exportSuccess">Campaign exported!</div>
                    <div class="success" id="importSuccess">Campaign imported!</div>
                    <div class="success" id="linkSuccess">Cloud link saved!</div>
                    <div class="error" id="importError">Import failed. Check file format.</div>
                </div>

                <!-- MAP BUILDER -->
                <div class="section active" id="mapSection">
                    <h3>üó∫Ô∏è Map Builder</h3>
                    
                    <div class="grid-selector">
                        <div class="grid-info">
                            Cell: <span class="current" id="currentCell">Center</span>
                        </div>
                        <div class="grid-nav">
                            <button class="btn btn-small" onclick="selectCell(0,0)">‚Üñ</button>
                            <button class="btn btn-small" onclick="selectCell(1,0)">‚Üë</button>
                            <button class="btn btn-small" onclick="selectCell(2,0)">‚Üó</button>
                            <button class="btn btn-small" onclick="selectCell(0,1)">‚Üê</button>
                            <button class="btn btn-small" onclick="selectCell(1,1)">‚óè</button>
                            <button class="btn btn-small" onclick="selectCell(2,1)">‚Üí</button>
                            <button class="btn btn-small" onclick="selectCell(0,2)">‚Üô</button>
                            <button class="btn btn-small" onclick="selectCell(1,2)">‚Üì</button>
                            <button class="btn btn-small" onclick="selectCell(2,2)">‚Üò</button>
                        </div>
                    </div>

                    <div class="history-controls">
                        <button class="btn btn-small" onclick="undo()" id="undoBtn" disabled>‚Ü∂ Undo</button>
                        <button class="btn btn-small" onclick="redo()" id="redoBtn" disabled>‚Ü∑ Redo</button>
                    </div>

                    <div class="tool-grid">
                        <div class="tool-btn active" onclick="setTool('brush')" id="brushBtn">üñåÔ∏è<br>Brush</div>
                        <div class="tool-btn" onclick="setTool('fill')" id="fillBtn">ü™£<br>Fill</div>
                        <div class="tool-btn" onclick="setTool('eraser')" id="eraserBtn">üßπ<br>Erase</div>
                        <div class="tool-btn" onclick="setTool('stamp')" id="stampBtn">üè∞<br>Stamp</div>
                        <div class="tool-btn" onclick="setTool('image')" id="imageBtn">üñºÔ∏è<br>Image</div>
                        <div class="tool-btn" onclick="setTool('select')" id="selectBtn">üëÜ<br>Select</div>
                    </div>

                    <div class="asset-indicator">
                        Active: <span class="current-asset" id="currentAsset">Brush</span>
                    </div>

                    <!-- STAMP LIBRARY -->
                    <div id="stampLibraryToggle" style="display: none; margin: 0.75rem 0;">
                        <button class="btn" onclick="toggleStampLibrary()" style="width: 100%;">üìö Open Stamp Library</button>
                    </div>

                    <!-- ERASER MODE TOGGLE -->
                    <div id="eraserOptions" style="display: none; margin: 0.75rem 0; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Eraser Mode:</div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-small btn-primary" onclick="setEraserMode('content')" id="eraseContentBtn" style="flex: 1;">Content Only</button>
                            <button class="btn btn-small" onclick="setEraserMode('all')" id="eraseAllBtn" style="flex: 1;">Everything</button>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem;" id="eraserModeDesc">
                            Erases drawn content without touching background
                        </div>
                    </div>

                    <div class="control-row">
                        <label>Color:</label>
                        <input type="color" id="colorPicker" value="#4a7c59" onchange="updateColor(this.value)">
                    </div>
                    <div class="control-row">
                        <label>Size:</label>
                        <input type="range" class="slider" id="sizeSlider" min="1" max="30" value="8" oninput="setSize(this.value)" style="flex: 1;">
                        <span id="sizeValue">8px</span>
                    </div>

                    <canvas id="mapCanvas" width="400" height="400"></canvas>

                    <div class="btn-group">
                        <input type="file" id="mapImport" accept="image/*" style="display: none;" onchange="importMapImage(event)">
                        <input type="file" id="imageImport" accept="image/*" style="display: none;" onchange="importImageToCanvas(event)">
                        <button class="btn" onclick="document.getElementById('imageImport').click()">üñºÔ∏è Place Image</button>
                        <button class="btn btn-primary" onclick="submitCell()">‚úì Submit</button>
                        <button class="btn" onclick="clearMapCanvas()">Clear</button>
                    </div>
                    
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-dim); padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                        üí° <strong>Place Image:</strong> Upload images to main canvas - they can be moved, resized & rotated! Use Select tool (üëÜ) to manipulate them.
                    </div>
                </div>

                <!-- FOG OF WAR -->
                <div class="section" id="fogSection">
                    <h3>üå´Ô∏è Fog of War</h3>
                    
                    <button class="btn btn-primary" onclick="toggleFogMode()" id="fogModeToggle" style="width: 100%; margin-bottom: 1rem; transition: all 0.3s;">
                        üå´Ô∏è Fog Paint Mode: OFF
                    </button>
                    
                    <div id="fogControls" style="opacity: 0.5; pointer-events: none; transition: all 0.3s;">
                        <div class="fog-groups" id="fogGroups">
                            <div class="fog-group-item active">
                                <span class="fog-group-name">Everyone</span>
                                <button class="btn btn-small btn-primary" onclick="setActiveFogGroup('everyone')">Active</button>
                            </div>
                        </div>

                        <button class="btn" onclick="showFogGroupModal()" style="width: 100%; margin-bottom: 0.75rem;">+ New Group</button>

                        <div style="margin-bottom: 0.75rem;">
                            <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Fog Paint Mode:</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <button class="btn btn-small btn-primary" onclick="setFogPaintMode('brush')" id="fogBrushBtn">üñåÔ∏è Brush</button>
                                <button class="btn btn-small" onclick="setFogPaintMode('rect')" id="fogRectBtn">‚ñ≠ Rectangle</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Brush Size:</label>
                            <input type="range" class="slider" id="fogSize" min="20" max="150" value="60" oninput="updateFogSize(this.value)" style="flex: 1;">
                            <span id="fogSizeValue">60px</span>
                        </div>

                        <div class="control-row">
                            <label>
                                <input type="checkbox" id="revealMode" checked> Reveal Fog
                            </label>
                        </div>

                        <div class="btn-group">
                            <button class="btn" onclick="resetFog()">Reset All Fog</button>
                        </div>
                        
                        <div style="margin-top: 0.75rem; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; font-size: 0.75rem; color: var(--text-dim);">
                            üí° Hold Ctrl + Click on the map to paint fog
                        </div>
                    </div>
                </div>

                <!-- TOKENS -->
                <div class="section" id="tokenSection">
                    <h3>üé≤ Tokens</h3>
                    
                    <div class="control-row">
                        <label>
                            <input type="checkbox" id="gridSnap" onchange="toggleGridSnap()" checked> Grid Snap (25px)
                        </label>
                    </div>

                    <button class="btn btn-primary" onclick="showTokenModal()" style="width: 100%;">+ Create Token</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MINIMAP NAVIGATOR -->
    <div class="minimap-container" id="minimapContainer">
        <div class="minimap" id="minimap">
            <div class="minimap-header">
                <div class="minimap-title">üó∫Ô∏è Navigator</div>
                <div class="minimap-controls">
                    <div class="minimap-btn" onclick="toggleMinimapCollapse()" title="Collapse">‚àí</div>
                    <div class="minimap-btn" onclick="toggleMinimapDock()" title="Lock/Unlock" id="dockBtn">üîì</div>
                </div>
            </div>
            <div class="minimap-content">
                <div class="minimap-grid" id="minimapGrid"></div>
                <div class="minimap-actions">
                    <div class="minimap-action-btn" onclick="recenterView()">‚äô Center</div>
                    <div class="minimap-action-btn" onclick="resetZoom()">üîç Reset</div>
                </div>
            </div>
        </div>
    </div>

    <!-- STAMP LIBRARY PANEL -->
    <div class="minimap-container" id="stampLibraryContainer" style="display: none; left: 220px; cursor: move;">
        <div class="minimap" id="stampLibraryPanel" style="width: 280px;">
            <div class="minimap-header">
                <div class="minimap-title">üìö Stamp Library</div>
                <div class="minimap-controls">
                    <div class="minimap-btn" onclick="toggleStampLibraryCollapse()" title="Collapse" id="stampCollapseBtn">‚àí</div>
                    <div class="minimap-btn" onclick="toggleStampLibraryDock()" title="Lock/Unlock" id="stampDockBtn">üîì</div>
                    <div class="minimap-btn" onclick="closeStampLibrary()" title="Close">‚úï</div>
                </div>
            </div>
            <div class="minimap-content" id="stampLibraryContent">
                <!-- Nature & Terrain -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">üå≤ Nature & Terrain</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('üå≤')" style="padding: 0.5rem; font-size: 1.5rem;">üå≤</div>
                        <div class="tool-btn" onclick="selectStamp('üå≥')" style="padding: 0.5rem; font-size: 1.5rem;">üå≥</div>
                        <div class="tool-btn" onclick="selectStamp('üå¥')" style="padding: 0.5rem; font-size: 1.5rem;">üå¥</div>
                        <div class="tool-btn" onclick="selectStamp('üåø')" style="padding: 0.5rem; font-size: 1.5rem;">üåø</div>
                        <div class="tool-btn" onclick="selectStamp('üçÉ')" style="padding: 0.5rem; font-size: 1.5rem;">üçÉ</div>
                        <div class="tool-btn" onclick="selectStamp('‚õ∞Ô∏è')" style="padding: 0.5rem; font-size: 1.5rem;">‚õ∞Ô∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üèîÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üèîÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üóª')" style="padding: 0.5rem; font-size: 1.5rem;">üóª</div>
                        <div class="tool-btn" onclick="selectStamp('üèûÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üèûÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üåä')" style="padding: 0.5rem; font-size: 1.5rem;">üåä</div>
                    </div>
                </div>
                
                <!-- Buildings & Structures -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">üè∞ Buildings</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('üè∞')" style="padding: 0.5rem; font-size: 1.5rem;">üè∞</div>
                        <div class="tool-btn" onclick="selectStamp('üèõÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üèõÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üïå')" style="padding: 0.5rem; font-size: 1.5rem;">üïå</div>
                        <div class="tool-btn" onclick="selectStamp('‚õ™')" style="padding: 0.5rem; font-size: 1.5rem;">‚õ™</div>
                        <div class="tool-btn" onclick="selectStamp('üèöÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üèöÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üè†')" style="padding: 0.5rem; font-size: 1.5rem;">üè†</div>
                        <div class="tool-btn" onclick="selectStamp('üè°')" style="padding: 0.5rem; font-size: 1.5rem;">üè°</div>
                        <div class="tool-btn" onclick="selectStamp('üèòÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üèòÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('‚õ∫')" style="padding: 0.5rem; font-size: 1.5rem;">‚õ∫</div>
                        <div class="tool-btn" onclick="selectStamp('üóø')" style="padding: 0.5rem; font-size: 1.5rem;">üóø</div>
                    </div>
                </div>
                
                <!-- Items & Objects -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">‚öîÔ∏è Items</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('‚öîÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">‚öîÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üó°Ô∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üó°Ô∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üõ°Ô∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üõ°Ô∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üèπ')" style="padding: 0.5rem; font-size: 1.5rem;">üèπ</div>
                        <div class="tool-btn" onclick="selectStamp('ü™ì')" style="padding: 0.5rem; font-size: 1.5rem;">ü™ì</div>
                        <div class="tool-btn" onclick="selectStamp('üî•')" style="padding: 0.5rem; font-size: 1.5rem;">üî•</div>
                        <div class="tool-btn" onclick="selectStamp('üíé')" style="padding: 0.5rem; font-size: 1.5rem;">üíé</div>
                        <div class="tool-btn" onclick="selectStamp('üëë')" style="padding: 0.5rem; font-size: 1.5rem;">üëë</div>
                        <div class="tool-btn" onclick="selectStamp('üìú')" style="padding: 0.5rem; font-size: 1.5rem;">üìú</div>
                        <div class="tool-btn" onclick="selectStamp('ü™ô')" style="padding: 0.5rem; font-size: 1.5rem;">ü™ô</div>
                    </div>
                </div>
                
                <!-- Creatures & Monsters -->
                <div>
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">üêâ Creatures</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('üêâ')" style="padding: 0.5rem; font-size: 1.5rem;">üêâ</div>
                        <div class="tool-btn" onclick="selectStamp('üßô')" style="padding: 0.5rem; font-size: 1.5rem;">üßô</div>
                        <div class="tool-btn" onclick="selectStamp('üßõ')" style="padding: 0.5rem; font-size: 1.5rem;">üßõ</div>
                        <div class="tool-btn" onclick="selectStamp('üßü')" style="padding: 0.5rem; font-size: 1.5rem;">üßü</div>
                        <div class="tool-btn" onclick="selectStamp('üëª')" style="padding: 0.5rem; font-size: 1.5rem;">üëª</div>
                        <div class="tool-btn" onclick="selectStamp('ü¶á')" style="padding: 0.5rem; font-size: 1.5rem;">ü¶á</div>
                        <div class="tool-btn" onclick="selectStamp('üï∑Ô∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üï∑Ô∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üê∫')" style="padding: 0.5rem; font-size: 1.5rem;">üê∫</div>
                        <div class="tool-btn" onclick="selectStamp('ü¶Ö')" style="padding: 0.5rem; font-size: 1.5rem;">ü¶Ö</div>
                        <div class="tool-btn" onclick="selectStamp('üêç')" style="padding: 0.5rem; font-size: 1.5rem;">üêç</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- PLAYER PANEL (Dockable) -->
    <div class="minimap-container" id="playerPanelContainer" style="display: none; right: 20px; bottom: 20px; left: auto; cursor: move;">
        <div class="minimap" id="playerPanelDock" style="width: 240px;">
            <div class="minimap-header">
                <div class="minimap-title">üë§ Player Actions</div>
                <div class="minimap-controls">
                    <div class="minimap-btn" onclick="togglePlayerPanelCollapse()" title="Collapse" id="playerCollapseBtn">‚àí</div>
                    <div class="minimap-btn" onclick="togglePlayerPanelDock()" title="Lock/Unlock" id="playerDockBtn">üîì</div>
                </div>
            </div>
            <div class="minimap-content" id="playerPanelContent">
                <button class="btn btn-primary" onclick="showPlayerTokenModal()" style="width: 100%; margin-bottom: 0.75rem;">+ Create My Token</button>
                
                <div style="padding-top: 0.75rem; border-top: 1px solid var(--border);">
                    <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">My Token Size:</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <button class="btn btn-small" onclick="adjustPlayerTokenSize(-2)" style="flex: 0;">‚àí</button>
                        <input type="range" class="slider" id="playerTokenSize" min="8" max="30" value="12" oninput="updatePlayerTokenSize(this.value)" style="flex: 1;">
                        <button class="btn btn-small" onclick="adjustPlayerTokenSize(2)" style="flex: 0;">+</button>
                    </div>
                    <div style="text-align: center; font-size: 0.75rem; color: var(--text-dim); margin-top: 0.25rem;">
                        Size: <span id="playerTokenSizeValue">12</span>px
                    </div>
                    <div style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.5rem; text-align: center;">
                        üí° 12px fits perfectly in one grid square
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- PLAYER TOKEN MODAL -->
    <div class="modal" id="playerTokenModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üé≤</div>
                <div class="modal-title">Request Token</div>
            </div>
            <div class="form-group">
                <label>TOKEN TYPE</label>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <button class="btn btn-primary" onclick="setPlayerTokenType('emoji')" id="playerEmojiTokenBtn" style="flex: 1;">Emoji</button>
                    <button class="btn" onclick="setPlayerTokenType('image')" id="playerImageTokenBtn" style="flex: 1;">Image</button>
                </div>
            </div>
            <div id="playerEmojiTokenInputs">
                <div class="form-group">
                    <label>TOKEN EMOJI</label>
                    <input type="text" id="playerTokenEmoji" placeholder="‚öîÔ∏è" maxlength="2">
                </div>
            </div>
            <div id="playerImageTokenInputs" style="display: none;">
                <div class="form-group">
                    <label>TOKEN IMAGE</label>
                    <input type="file" id="playerTokenImageFile" accept="image/*" style="width: 100%; padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text);">
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-dim);">Upload PNG, JPG, or GIF</div>
                </div>
            </div>
            <div class="form-group">
                <label>TOKEN COLOR</label>
                <input type="color" id="playerTokenColor" value="#3b82f6">
            </div>
            <div class="info">Your token will be sent to the DM for approval</div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="requestPlayerToken()" style="flex: 1;">Request Token</button>
                <button class="btn" onclick="closePlayerTokenModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- MUSIC PLAYER PANEL -->
    <div class="music-panel" id="musicPanel">
        <div class="music-header">
            <span class="music-header-title">üéµ Jukebox</span>
            <div style="display:flex;gap:0.25rem;align-items:center;">
                <span id="musicBroadcastIcon" title="Broadcasting to players" style="font-size:0.8rem;display:none;">üì°</span>
                <div class="minimap-btn" onclick="toggleMusicPanel()" title="Close">‚úï</div>
            </div>
        </div>
        <div class="music-now-playing" id="musicNowPlaying">Nothing playing</div>
        <div class="music-grid" id="musicGrid">
            <!-- filled by JS -->
        </div>
        <div class="music-controls">
            <span style="font-size:0.75rem;color:var(--text-dim);">Vol</span>
            <input type="range" class="music-vol" id="musicVolume" min="0" max="100" value="70" oninput="setMusicVolume(this.value)">
            <label style="font-size:0.7rem;color:var(--text-dim);display:flex;align-items:center;gap:0.25rem;">
                <input type="checkbox" id="musicBroadcast" checked style="accent-color:var(--accent);"> Broadcast
            </label>
            <button class="music-stop-btn" onclick="stopMusic()">‚ñ† Stop</button>
        </div>
        <audio id="musicAudio" loop></audio>
    </div>

    <!-- CHARACTER SHEET OVERLAY -->
    <div class="char-overlay" id="charOverlay">
        <div class="char-header">
            <h1>üìú Characters</h1>
            <div style="display:flex;gap:0.5rem;align-items:center;">
                <button class="btn btn-primary btn-small" onclick="saveCharacter()">üíæ Save</button>
                <button class="btn btn-small" onclick="newCharacter()">+ New</button>
                <button class="btn btn-small" onclick="closeCharSheet()">‚úï Close</button>
            </div>
        </div>
        <div class="char-body">
            <!-- Character List -->
            <div class="char-list-panel">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;">
                    <span style="font-size:0.85rem;color:var(--gold);font-weight:600;">Your Characters</span>
                    <button class="btn btn-small btn-danger" onclick="deleteCharacter()" id="deleteCharBtn" style="display:none;">üóë Delete</button>
                </div>
                <div id="charListEl"><p style="font-size:0.85rem;color:var(--text-dim);">No characters yet. Click "+ New" to create one.</p></div>
            </div>

            <!-- Character Editor -->
            <div id="charEditor" style="display:none;">
                <!-- TABS -->
                <div class="char-tabs">
                    <div class="char-tab active" onclick="switchCharTab('basics')">‚öîÔ∏è Basics</div>
                    <div class="char-tab" onclick="switchCharTab('abilities')">üí™ Abilities</div>
                    <div class="char-tab" onclick="switchCharTab('combat')">üõ°Ô∏è Combat</div>
                    <div class="char-tab" onclick="switchCharTab('skills')">üé≤ Skills</div>
                    <div class="char-tab" onclick="switchCharTab('notes')">üìù Notes</div>
                </div>

                <!-- BASICS TAB -->
                <div class="char-tab-content active" id="tabBasics">
                    <div class="char-section">
                        <h3>Identity</h3>
                        <div class="char-grid-2" style="margin-bottom:0.75rem;">
                            <div><label class="char-label">Character Name</label><input class="char-input" id="cName" placeholder="Thorin Oakenshield"></div>
                            <div><label class="char-label">Player Name</label><input class="char-input" id="cPlayer" placeholder="Your name"></div>
                        </div>
                        <div class="char-grid-3">
                            <div><label class="char-label">Class</label>
                                <select class="char-input" id="cClass" onchange="updateProfBonus()">
                                    <option>Barbarian</option><option>Bard</option><option>Cleric</option>
                                    <option>Druid</option><option>Fighter</option><option>Monk</option>
                                    <option>Paladin</option><option>Ranger</option><option>Rogue</option>
                                    <option>Sorcerer</option><option>Warlock</option><option>Wizard</option>
                                </select>
                            </div>
                            <div><label class="char-label">Level</label><input class="char-input" id="cLevel" type="number" min="1" max="20" value="1" oninput="updateProfBonus()"></div>
                            <div><label class="char-label">Proficiency Bonus</label><input class="char-input" id="cProfBonus" readonly style="background:var(--bg-card);color:var(--accent);font-weight:700;"></div>
                        </div>
                        <div class="char-grid-3" style="margin-top:0.75rem;">
                            <div><label class="char-label">Race</label><input class="char-input" id="cRace" placeholder="Dwarf"></div>
                            <div><label class="char-label">Background</label><input class="char-input" id="cBackground" placeholder="Folk Hero"></div>
                            <div><label class="char-label">Alignment</label>
                                <select class="char-input" id="cAlignment">
                                    <option>Lawful Good</option><option>Neutral Good</option><option>Chaotic Good</option>
                                    <option>Lawful Neutral</option><option>True Neutral</option><option>Chaotic Neutral</option>
                                    <option>Lawful Evil</option><option>Neutral Evil</option><option>Chaotic Evil</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="char-section">
                        <h3>Personality</h3>
                        <div class="char-grid-2">
                            <div><label class="char-label">Personality Trait</label><textarea class="notes-textarea" id="cPersonality" style="min-height:70px;" placeholder="I always tell the truth..."></textarea></div>
                            <div><label class="char-label">Ideal</label><textarea class="notes-textarea" id="cIdeal" style="min-height:70px;" placeholder="Greater Good..."></textarea></div>
                            <div><label class="char-label">Bond</label><textarea class="notes-textarea" id="cBond" style="min-height:70px;" placeholder="I would die for my village..."></textarea></div>
                            <div><label class="char-label">Flaw</label><textarea class="notes-textarea" id="cFlaw" style="min-height:70px;" placeholder="I'm too proud..."></textarea></div>
                        </div>
                    </div>
                </div>

                <!-- ABILITIES TAB -->
                <div class="char-tab-content" id="tabAbilities">
                    <div class="char-section">
                        <h3>Ability Scores</h3>
                        <div class="char-grid-6">
                            <div class="ability-block">
                                <div class="ability-name">STR</div>
                                <div class="ability-score"><input type="number" id="aSTR" value="10" min="1" max="30" oninput="updateAbilityMod('STR')"></div>
                                <div class="ability-mod" id="mSTR">+0</div>
                            </div>
                            <div class="ability-block">
                                <div class="ability-name">DEX</div>
                                <div class="ability-score"><input type="number" id="aDEX" value="10" min="1" max="30" oninput="updateAbilityMod('DEX')"></div>
                                <div class="ability-mod" id="mDEX">+0</div>
                            </div>
                            <div class="ability-block">
                                <div class="ability-name">CON</div>
                                <div class="ability-score"><input type="number" id="aCON" value="10" min="1" max="30" oninput="updateAbilityMod('CON')"></div>
                                <div class="ability-mod" id="mCON">+0</div>
                            </div>
                            <div class="ability-block">
                                <div class="ability-name">INT</div>
                                <div class="ability-score"><input type="number" id="aINT" value="10" min="1" max="30" oninput="updateAbilityMod('INT')"></div>
                                <div class="ability-mod" id="mINT">+0</div>
                            </div>
                            <div class="ability-block">
                                <div class="ability-name">WIS</div>
                                <div class="ability-score"><input type="number" id="aWIS" value="10" min="1" max="30" oninput="updateAbilityMod('WIS')"></div>
                                <div class="ability-mod" id="mWIS">+0</div>
                            </div>
                            <div class="ability-block">
                                <div class="ability-name">CHA</div>
                                <div class="ability-score"><input type="number" id="aCHA" value="10" min="1" max="30" oninput="updateAbilityMod('CHA')"></div>
                                <div class="ability-mod" id="mCHA">+0</div>
                            </div>
                        </div>
                    </div>
                    <div class="char-section">
                        <h3>Saving Throws</h3>
                        <div class="skill-list" id="savingThrowList"></div>
                    </div>
                </div>

                <!-- COMBAT TAB -->
                <div class="char-tab-content" id="tabCombat">
                    <div class="char-section">
                        <h3>Hit Points</h3>
                        <div class="char-grid-3" style="margin-bottom:1rem;">
                            <div class="stat-block">
                                <label>Max HP</label>
                                <input type="number" id="cHPMax" value="10" min="0">
                            </div>
                            <div class="stat-block" style="border-color:var(--danger);">
                                <label style="color:var(--danger);">Current HP</label>
                                <div class="hp-track">
                                    <button class="hp-btn" onclick="changeHP(-1)">‚àí</button>
                                    <input type="number" id="cHP" value="10" min="0" style="flex:1;">
                                    <button class="hp-btn" onclick="changeHP(1)">+</button>
                                </div>
                            </div>
                            <div class="stat-block">
                                <label>Temp HP</label>
                                <input type="number" id="cTempHP" value="0" min="0">
                            </div>
                        </div>
                        <div style="margin-bottom:0.75rem;">
                            <label class="char-label">Death Saves</label>
                            <div style="display:flex;gap:1rem;margin-top:0.5rem;">
                                <div>
                                    <span style="font-size:0.75rem;color:var(--success);margin-right:0.5rem;">Successes</span>
                                    <div class="death-saves">
                                        <div class="death-save-pip success" onclick="toggleDeathSave(this)" data-index="0"></div>
                                        <div class="death-save-pip success" onclick="toggleDeathSave(this)" data-index="1"></div>
                                        <div class="death-save-pip success" onclick="toggleDeathSave(this)" data-index="2"></div>
                                    </div>
                                </div>
                                <div>
                                    <span style="font-size:0.75rem;color:var(--danger);margin-right:0.5rem;">Failures</span>
                                    <div class="death-saves">
                                        <div class="death-save-pip failure" onclick="toggleDeathSave(this)" data-index="0"></div>
                                        <div class="death-save-pip failure" onclick="toggleDeathSave(this)" data-index="1"></div>
                                        <div class="death-save-pip failure" onclick="toggleDeathSave(this)" data-index="2"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="char-section">
                        <h3>Combat Stats</h3>
                        <div class="char-grid-3">
                            <div class="stat-block"><label>Armor Class</label><input type="number" id="cAC" value="10" min="0"></div>
                            <div class="stat-block"><label>Initiative</label><input type="number" id="cInit" value="0" readonly style="color:var(--accent);" title="Equals DEX modifier"></div>
                            <div class="stat-block"><label>Speed (ft)</label><input type="number" id="cSpeed" value="30" min="0"></div>
                        </div>
                        <div class="char-grid-2" style="margin-top:0.75rem;">
                            <div><label class="char-label">Hit Dice</label><input class="char-input" id="cHitDice" placeholder="1d10" title="e.g. 1d10 for Fighter"></div>
                            <div><label class="char-label">Passive Perception</label><input class="char-input" id="cPassivePerception" readonly style="background:var(--bg-card);color:var(--accent);font-weight:700;"></div>
                        </div>
                    </div>
                    <div class="char-section">
                        <h3>Equipment & Inventory</h3>
                        <textarea class="notes-textarea" id="cInventory" placeholder="List weapons, armor, and items here..."></textarea>
                    </div>
                </div>

                <!-- SKILLS TAB -->
                <div class="char-tab-content" id="tabSkills">
                    <div class="char-section">
                        <h3>Skills</h3>
                        <div class="skill-list" id="skillListEl"></div>
                    </div>
                </div>

                <!-- NOTES TAB -->
                <div class="char-tab-content" id="tabNotes">
                    <div class="char-section">
                        <h3>Spells</h3>
                        <textarea class="notes-textarea" id="cSpells" placeholder="List your spells, cantrips, and spell slots here..."></textarea>
                    </div>
                    <div class="char-section">
                        <h3>Features & Traits</h3>
                        <textarea class="notes-textarea" id="cFeatures" placeholder="Class features, racial traits, feats..."></textarea>
                    </div>
                    <div class="char-section">
                        <h3>Campaign Notes</h3>
                        <textarea class="notes-textarea" id="cNotes" placeholder="Session notes, plot hooks, NPCs met..."></textarea>
                    </div>
                    <div class="char-section">
                        <h3>Backstory</h3>
                        <textarea class="notes-textarea" id="cBackstory" placeholder="Your character's backstory..."></textarea>
                    </div>
                </div>
            </div><!-- end charEditor -->
        </div>
    </div>

    <script>
        console.clear();
        console.log('%cüéÆ THE FRACTURED SKY VTT v4.0 FINAL', 'font-size: 24px; font-weight: bold; color: #8b5cf6; background: #1a1f2e; padding: 10px;');
        console.log('%c‚úÖ JavaScript Loading...', 'font-size: 16px; color: #10b981;');
        console.log('%cBuild: 1770523324', 'font-size: 14px; color: #fbbf24;');
        console.log('%cTime:', 'font-weight: bold;', new Date().toLocaleTimeString());
        console.log('%c--- If you see this, JavaScript is working! ---', 'color: #10b981; font-weight: bold;');

        // === CORE STATE ===
        let peer = null;
        let isDM = false;
        let myId = null;
        let myName = null;
        let roomCode = null;
        let connections = new Map();
        let savedPeerId = null; // For DM session persistence

        // === CO-DM STATE ===
        let isCoDM = false;      // true when this instance joined as a co-DM
        let hostDMConn = null;   // co-DM's connection to the host DM
        let coDMs = new Map();   // host DM's map of approved co-DM connections
        let coDMOriginalCode = null;  // room code stored for co-DM reconnects
        let coDMOriginalName = null;  // co-DM display name for reconnects
        let coDMReconnectTimer = null;

        // === CONNECTION RESILIENCE STATE ===
        let playerFirebaseWatcher = null; // Firestore onSnapshot unsubscribe fn
        let dmHeartbeatTimer = null;      // setInterval handle for DM Firebase keepalive

        // === FIREBASE ===
        const firebaseConfig = {
            apiKey: "AIzaSyDDl5BjZUW-RmT6MG_z9MTsfdedK75fSrc",
            authDomain: "ddddd-f276d.firebaseapp.com",
            projectId: "ddddd-f276d",
            storageBucket: "ddddd-f276d.firebasestorage.app",
            messagingSenderId: "260370337802",
            appId: "1:260370337802:web:e7310129ef9533de4b8ff3",
            measurementId: "G-4X38GGZZ3S"
        };
        let fbDb = null;
        try {
            if (typeof firebase !== 'undefined') {
                if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
                fbDb = firebase.firestore();
            }
        } catch(e) {
            console.warn('‚ö†Ô∏è Firebase unavailable ‚Äî running without cloud persistence:', e.message);
        }
        let firebaseUser = null;
        let firebaseSaveTimeout = null;
        let firebaseRoomRef = null; // set to roomCode string once DM opens room

        async function firebaseSignIn() {
            if (typeof firebase === 'undefined' || !fbDb) return;
            try {
                const result = await firebase.auth().signInAnonymously();
                firebaseUser = result.user;
                console.log('üî• Firebase signed in:', firebaseUser.uid);
            } catch (err) {
                console.error('üî• Firebase auth error:', err);
                updateFirebaseStatus('‚ö†Ô∏è Auth failed', '#ef4444');
            }
        }

        // Watch Firestore for DM peer ID changes; fires callback immediately with the
        // current value then on every future change. Stores the unsubscribe fn in
        // playerFirebaseWatcher so the watcher can be torn down cleanly.
        function startFirebaseWatch(roomId, callback) {
            stopFirebaseWatch();
            if (!roomId || !fbDb) return;
            firebaseSignIn().then(() => {
                const unsub = fbDb
                    .collection('vtt_rooms').doc(roomId)
                    .onSnapshot(doc => {
                        const peerId = doc.exists && doc.data() && doc.data().currentPeerId;
                        if (peerId) callback(peerId);
                    }, err => console.error('üî• Watch error:', err));
                playerFirebaseWatcher = unsub;
            }).catch(err => console.error('üî• Watch sign-in error:', err));
        }

        function stopFirebaseWatch() {
            if (typeof playerFirebaseWatcher === 'function') {
                try { playerFirebaseWatcher(); } catch(e) {}
            }
            playerFirebaseWatcher = null;
        }

        // DM refreshes currentPeerId + lastSeen in Firebase every 20 s so that
        // onSnapshot watchers on players/co-DMs wake up if the first write was missed.
        function startDMHeartbeat() {
            stopDMHeartbeat();
            dmHeartbeatTimer = setInterval(() => {
                if (!isDM || isCoDM || !firebaseRoomRef || !firebaseUser || !fbDb) return;
                fbDb.collection('vtt_rooms').doc(firebaseRoomRef)
                    .set({ currentPeerId: myId, lastSeen: Date.now() }, { merge: true })
                    .catch(e => console.error('üî• Heartbeat error:', e));
            }, 20000);
        }

        function stopDMHeartbeat() {
            if (dmHeartbeatTimer) { clearInterval(dmHeartbeatTimer); dmHeartbeatTimer = null; }
        }

        // Re-connect a co-DM to the host using the latest Firebase peer ID.
        function coDMAutoReconnect() {
            if (!isCoDM || !coDMOriginalCode) return;
            clearTimeout(coDMReconnectTimer);
            joinAsCoDM(coDMOriginalName || myName || 'Co-DM', coDMOriginalCode);
        }

        // Firestore has a 1MB document limit, so we split state across
        // sibling documents ‚Äî all matched by the {roomId} wildcard in your rules.
        // Main doc:  vtt_rooms/{roomId}           ‚Üí tokens, zoom, pan, lockedCells
        // Cell docs: vtt_rooms/{roomId}__cell_X_Y ‚Üí one canvas dataURL per grid cell
        // Fog docs:  vtt_rooms/{roomId}__fog_NAME ‚Üí one canvas dataURL per fog group
        // Image doc: vtt_rooms/{roomId}__images   ‚Üí placed image list

        function scheduleSave() {
            if (!isDM || !firebaseRoomRef || !firebaseUser) return;
            clearTimeout(firebaseSaveTimeout);
            updateFirebaseStatus('‚òÅÔ∏è Unsaved...', '#fbbf24');
            firebaseSaveTimeout = setTimeout(saveToFirebase, 1500);
        }

        async function saveToFirebase() {
            if (!isDM || !firebaseRoomRef || !firebaseUser || !fbDb) return;
            try {
                updateFirebaseStatus('‚òÅÔ∏è Saving...', '#fbbf24');
                const col = fbDb.collection('vtt_rooms');
                const batch = fbDb.batch();

                // Main document ‚Äî lightweight state
                batch.set(col.doc(firebaseRoomRef), {
                    tokens: [...stagingTokens, ...placedTokens],
                    lockedCells,
                    zoom, panX, panY,
                    fogGroupNames: Object.keys(fogGroups),
                    savedAt: Date.now()
                });

                // One document per grid cell
                for (const key in gridCells) {
                    const safeKey = key.replace(/,/g, '_');
                    batch.set(col.doc(firebaseRoomRef + '__cell_' + safeKey), {
                        data: gridCells[key].toDataURL()
                    });
                }

                // One document per fog group
                for (const group in fogGroups) {
                    const safeGroup = group.replace(/[^a-zA-Z0-9_-]/g, '_');
                    batch.set(col.doc(firebaseRoomRef + '__fog_' + safeGroup), {
                        name: group,
                        data: fogGroups[group].canvas.toDataURL()
                    });
                }

                // Placed images
                const imagesData = placedImages.map(pi => ({
                    src: pi.img.src,
                    x: pi.x, y: pi.y,
                    width: pi.width, height: pi.height,
                    rotation: pi.rotation,
                    gridX: pi.gridX, gridY: pi.gridY
                }));
                batch.set(col.doc(firebaseRoomRef + '__images'), { images: imagesData });

                await batch.commit();
                updateFirebaseStatus('‚òÅÔ∏è Saved', '#10b981');
                console.log('üî• Saved to Firestore');
            } catch (err) {
                console.error('üî• Firebase save error:', err);
                updateFirebaseStatus('‚ö†Ô∏è Save failed', '#ef4444');
            }
        }

        async function loadFromFirebase(roomId) {
            if (!fbDb) return;
            try {
                updateFirebaseStatus('‚òÅÔ∏è Loading...', '#fbbf24');
                const col = fbDb.collection('vtt_rooms');
                const mainSnap = await col.doc(roomId).get();

                if (!mainSnap.exists) {
                    updateFirebaseStatus('‚òÅÔ∏è New room', '#9ca3af');
                    console.log('üî• No saved state ‚Äî starting fresh');
                    return;
                }

                const main = mainSnap.data();

                // Load all 9 possible grid cells
                const gridData = {};
                const cellFetches = [];
                for (let cy = 0; cy < 3; cy++) {
                    for (let cx = 0; cx < 3; cx++) {
                        const key = `${cx},${cy}`;
                        const safeKey = `${cx}_${cy}`;
                        cellFetches.push(
                            col.doc(roomId + '__cell_' + safeKey).get().then(snap => {
                                if (snap.exists) gridData[key] = snap.data().data;
                            })
                        );
                    }
                }

                // Load fog groups
                const fogData = {};
                const fogNames = main.fogGroupNames || ['everyone'];
                const fogFetches = fogNames.map(name => {
                    const safeGroup = name.replace(/[^a-zA-Z0-9_-]/g, '_');
                    return col.doc(roomId + '__fog_' + safeGroup).get().then(snap => {
                        if (snap.exists) fogData[snap.data().name] = snap.data().data;
                    });
                });

                // Load placed images
                const imagesSnap = await col.doc(roomId + '__images').get();
                const imagesData = imagesSnap.exists ? imagesSnap.data().images : [];

                await Promise.all([...cellFetches, ...fogFetches]);

                loadGameState({
                    tokens: main.tokens || [],
                    lockedCells: main.lockedCells || {},
                    zoom: main.zoom || 1,
                    panX: main.panX || 0,
                    panY: main.panY || 0,
                    gridCells: gridData,
                    fogGroups: fogData,
                    placedImages: imagesData
                });

                updateFirebaseStatus('‚òÅÔ∏è Loaded', '#10b981');
                console.log('üî• Loaded from Firestore');
            } catch (err) {
                console.error('üî• Firebase load error:', err);
                updateFirebaseStatus('‚ö†Ô∏è Load failed', '#ef4444');
            }
        }

        function updateFirebaseStatus(text, color) {
            const header = document.getElementById('firebaseStatus');
            const panel = document.getElementById('firebaseStatusPanel');
            const section = document.getElementById('firebaseStatusSection');
            if (header) { header.textContent = text; header.style.color = color; }
            if (panel)  { panel.textContent = text; panel.style.color = color; }
            if (section) section.style.display = 'block';
        }

        // Game state
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let gridSnapEnabled = true;
        const GRID_SNAP_SIZE = 25;
        const GRID_SIZE = 400;
        const CELL_SIZE = 400;

        // Map builder
        let currentCellX = 1;
        let currentCellY = 1;
        let gridCells = {};
        let lockedCells = {};
        let tool = 'brush';
        let color = '#4a7c59';
        let size = 8;
        let currentAsset = 'Brush';
        let lastToolBeforeEraser = 'brush'; // Track tool before eraser
        let eraserMode = 'content'; // 'content' or 'all'
        let currentStamp = 'üè∞';
        let tokenType = 'emoji'; // 'emoji' or 'image'
        let tokenImageData = null;
        
        // Image layer for DM
        let placedImages = []; // { img, x, y, width, height, rotation, gridX, gridY }
        let selectedImage = null;
        let imageResizeHandle = null; // 'nw', 'ne', 'sw', 'se', 'rotate'
        let imageDragStart = null;
        
        // History tracking
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // Drawing state
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Tokens
        let stagingTokens = [];
        let placedTokens = [];
        const tokenImageCache = new Map(); // keyed by token id ‚Üí {img, srcKey}
        let draggedToken = null;
        let draggedPlacedToken = null; // For moving tokens already on the map
        let tokenDragOffset = { x: 0, y: 0 };

        // Fog
        let activeFogGroup = 'everyone';
        let fogGroups = { everyone: { name: 'Everyone', canvas: null } };
        let fogMode = false;
        let fogPaintMode = 'brush'; // 'brush' or 'rect'
        let fogBrushSize = 60;
        let fogRectStart = null;
        let isFogDrawing = false;
        let dmFogOpacity = 0.3; // DM sees through fog
        let fogBroadcastTimeout = null; // For throttling broadcasts

        // Player requests
        let pendingRequests = [];
        let approvedPlayerNames = new Set(); // tracks names of ever-approved players for auto-reapprove

        // Minimap
        let minimapDocked = false;
        let minimapDragOffset = null;
        let _minimapLastState = ''; // dirty-check: skip rebuild when nothing changed

        const gridNames = [
            ['Top-Left', 'Top-Center', 'Top-Right'],
            ['Middle-Left', 'Center', 'Middle-Right'],
            ['Bottom-Left', 'Bottom-Center', 'Bottom-Right']
        ];

        // Canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');

        // Initialize fog canvases
        for (let group in fogGroups) {
            const fogCanvas = document.createElement('canvas');
            fogCanvas.width = GRID_SIZE * 3;
            fogCanvas.height = GRID_SIZE * 3;
            const fogCtx = fogCanvas.getContext('2d');
            fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Full opacity black fog
            fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
            fogGroups[group].canvas = fogCanvas;
        }

        // === INITIALIZATION ===
        // Cached DOM references ‚Äî set once in init() to avoid repeated getElementById on hot paths
        let _elStatusText, _elStatusIndicator, _elTabIndicator, _elCurrentCell, _elCurrentAsset, _elMinimapGrid;

        function init() {
            _elStatusText      = document.getElementById('statusText');
            _elStatusIndicator = document.getElementById('statusIndicator');
            _elTabIndicator    = document.getElementById('tabIndicator');
            _elCurrentCell     = document.getElementById('currentCell');
            _elCurrentAsset    = document.getElementById('currentAsset');
            _elMinimapGrid     = document.getElementById('minimapGrid');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // On page hide/close: flush any pending Firebase save immediately
            // so game state is never lost on DM refresh.
            function flushSave() {
                if (isDM && firebaseRoomRef && firebaseUser && fbDb) {
                    clearTimeout(firebaseSaveTimeout);
                    firebaseSaveTimeout = null;
                    saveToFirebase(); // best-effort async save
                }
            }
            // visibilitychange fires reliably on tab switch, phone sleep, refresh
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') flushSave();
            });
            // beforeunload fires on browser close / navigation
            window.addEventListener('beforeunload', () => {
                flushSave();
                if (peer && !peer.destroyed) peer.destroy();
            });

            // Listen for another tab taking over as DM ‚Äî surrender peer immediately
            try {
                const dmChannel = new BroadcastChannel('fracturedSky_dm');
                dmChannel.onmessage = (e) => {
                    if (e.data.type === 'surrender' && isDM && peer && !peer.destroyed && roomCode === e.data.id) {
                        console.log('üì° Surrendering peer ID to new tab:', e.data.id);
                        peer.destroy();
                    }
                };
            } catch(e) {}
            
            mapCtx.fillStyle = '#f5f5dc';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            
            updateGridDisplay();
            updateMinimap();
            saveHistory();
            
            // Close DM panel when double-clicking outside
            document.addEventListener('dblclick', (e) => {
                if (!isDM) return;
                const panel = document.getElementById('dmPanel');
                if (!panel.contains(e.target) && panel.classList.contains('open')) {
                    toggleDMPanel();
                    deselectAllTools();
                }
            });

            // Check for saved sessions and offer to resume.
            // tabRole (sessionStorage) is per-tab and survives refresh but NOT
            // browser restart, so it's safe to use in split-tab same-browser setups.
            // localStorage holds the actual data (room IDs, names) that persists
            // longer term but must never be used alone to decide which role THIS tab has.
            const tabRole = sessionStorage.getItem('fracturedSkyTabRole');
            const savedDMSession = localStorage.getItem('fracturedSkySessionId');
            const savedPlayerRoom = localStorage.getItem('fracturedSkyPlayerRoom');
            const savedPlayerName = localStorage.getItem('fracturedSkyPlayerName');

            // Decide which role this tab should resume.
            // Priority: sessionStorage role (refresh-safe, tab-isolated) >
            //           localStorage isDM flag (browser-restart fallback, single-tab only).
            const resumeAsDM = tabRole === 'dm'
                || (tabRole === null && localStorage.getItem('fracturedSkyIsDM') === 'true');
            const resumeAsPlayer = !resumeAsDM && (tabRole === 'player'
                || (tabRole === null && !!(savedPlayerRoom && savedPlayerName)));

            if (resumeAsDM && savedDMSession) {
                // Auto-reconnect DM immediately ‚Äî no click required.
                // Show a "Start Fresh" cancel button in case they want a new session.
                document.getElementById('welcomeButtons').style.display = 'none';
                document.getElementById('welcomeReconnect').style.display = 'block';
                document.getElementById('welcomeReconnectMsg').textContent = 'üëë Resuming your DM session...';
                document.getElementById('connectionTabContainer').style.display = 'block';
                document.getElementById('startFreshBtn').style.display = 'block';
                try {
                    const saved = localStorage.getItem('fracturedSkyApprovedNames');
                    if (saved) JSON.parse(saved).forEach(n => approvedPlayerNames.add(n));
                } catch(e) {}
                createRoom(savedDMSession);
            } else if (resumeAsPlayer && savedPlayerRoom && savedPlayerName) {
                // Auto-reconnect player immediately.
                // Keep welcome screen visible so user can cancel if stuck.
                document.getElementById('welcomeButtons').style.display = 'none';
                document.getElementById('welcomeReconnect').style.display = 'block';
                document.getElementById('welcomeReconnectMsg').textContent = `üë§ Reconnecting as "${savedPlayerName}"...`;
                document.getElementById('connectionTabContainer').style.display = 'block';
                document.getElementById('startFreshBtn').style.display = 'block';
                myName = savedPlayerName;
                roomCode = savedPlayerRoom;
                updateConnectionStatus('Reconnecting...', false);
                playerAutoReconnect();
            }
        }

        function doAutoReconnect() {
            document.getElementById('welcomeReconnect').style.display = 'none';
            document.getElementById('welcomeButtons').style.display = 'flex';
            const savedDMSession = localStorage.getItem('fracturedSkySessionId');
            const wasDM = localStorage.getItem('fracturedSkyIsDM') === 'true';
            if (wasDM && savedDMSession) {
                try {
                    const saved = localStorage.getItem('fracturedSkyApprovedNames');
                    if (saved) JSON.parse(saved).forEach(n => approvedPlayerNames.add(n));
                } catch(e) {}
                sessionStorage.setItem('fracturedSkyTabRole', 'dm');
                updateConnectionStatus('Reconnecting...', false);
                createRoom(savedDMSession);
            } else {
                const savedPlayerRoom = localStorage.getItem('fracturedSkyPlayerRoom');
                const savedPlayerName = localStorage.getItem('fracturedSkyPlayerName');
                if (savedPlayerRoom && savedPlayerName) {
                    sessionStorage.setItem('fracturedSkyTabRole', 'player');
                    myName = savedPlayerName;
                    roomCode = savedPlayerRoom;
                    document.getElementById('welcomeScreen').classList.add('hidden');
                    document.getElementById('connectionTabContainer').style.display = 'block';
                    updateConnectionStatus('Reconnecting...', false);
                    playerAutoReconnect();
                }
            }
        }

        function resumeDMSession() {
            try {
                const saved = localStorage.getItem('fracturedSkyApprovedNames');
                if (saved) JSON.parse(saved).forEach(n => approvedPlayerNames.add(n));
            } catch(e) {}
            const savedDMSession = localStorage.getItem('fracturedSkySessionId');
            sessionStorage.setItem('fracturedSkyTabRole', 'dm');
            // Hide welcome screen & show connection tab immediately so user sees feedback
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('connectionTabContainer').style.display = 'block';
            updateConnectionStatus('Reconnecting...', false);
            createRoom(savedDMSession);
        }
        function clearDMSession() {
            localStorage.removeItem('fracturedSkySessionId');
            localStorage.removeItem('fracturedSkyIsDM');
            document.getElementById('resumeArea').innerHTML = '';
        }
        function resumePlayerSession() {
            const savedPlayerRoom = localStorage.getItem('fracturedSkyPlayerRoom');
            const savedPlayerName = localStorage.getItem('fracturedSkyPlayerName');
            sessionStorage.setItem('fracturedSkyTabRole', 'player');
            myName = savedPlayerName;
            roomCode = savedPlayerRoom;
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('connectionTabContainer').style.display = 'block';
            updateConnectionStatus('Reconnecting as ' + savedPlayerName + '...', false);
            playerAutoReconnect();
        }
        function clearPlayerSession() {
            localStorage.removeItem('fracturedSkyPlayerRoom');
            localStorage.removeItem('fracturedSkyPlayerName');
            document.getElementById('resumeArea').innerHTML = '';
        }

        function cancelAutoReconnect() {
            // Abort any in-flight reconnect attempt
            stopFirebaseWatch();
            if (peer && !peer.destroyed) { try { peer.destroy(); } catch(e) {} }
            peer = null;
            isDM = false;
            // Clear all saved session data
            sessionStorage.removeItem('fracturedSkyTabRole');
            sessionStorage.removeItem('fracturedSkyPlayerRoom');
            localStorage.removeItem('fracturedSkyIsDM');
            localStorage.removeItem('fracturedSkySessionId');
            localStorage.removeItem('fracturedSkyPlayerRoom');
            localStorage.removeItem('fracturedSkyPlayerName');
            // Restore welcome screen
            document.getElementById('welcomeReconnect').style.display = 'none';
            document.getElementById('welcomeButtons').style.display = 'flex';
            document.getElementById('welcomeScreen').classList.remove('hidden');
            document.getElementById('connectionTabContainer').style.display = 'none';
        }

        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            const prevW = canvas.width;
            const prevH = canvas.height;
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            // Only center on first load (prevW === 0), not on every resize
            if (prevW === 0) {
                panX = (canvas.width - GRID_SIZE * 3) / 2;
                panY = (canvas.height - GRID_SIZE * 3) / 2;
            }
            draw();
        }

        // === AUTHENTICATION ===
        function showDMLogin() {
            const savedSession = localStorage.getItem('fracturedSkySessionId');
            if (savedSession) {
                document.getElementById('sessionId').value = savedSession;
            }
            document.getElementById('dmModal').classList.add('active');
        }

        function closeDMModal() {
            document.getElementById('dmModal').classList.remove('active');
            document.getElementById('dmError').classList.remove('show');
            document.getElementById('dmInfo').style.display = 'none';
        }

        function dmLogin(e) {
            e.preventDefault();
            const user = document.getElementById('dmUser').value;
            const pass = document.getElementById('dmPass').value;
            const sessionId = document.getElementById('sessionId').value.trim();
            if (user === 'Wizard' && pass === 'FracturedSky2025!') {
                closeDMModal();
                createRoom(sessionId || null);
            } else {
                document.getElementById('dmError').classList.add('show');
            }
        }

        function showPlayerLogin() {
            document.getElementById('playerModal').classList.add('active');
        }

        function closePlayerModal() {
            document.getElementById('playerModal').classList.remove('active');
            document.getElementById('playerError').classList.remove('show');
            document.getElementById('playerSuccess').classList.remove('show');
        }

        function playerLogin(e) {
            e.preventDefault();
            myName = document.getElementById('playerName').value;
            const code = document.getElementById('roomCodeInput').value.trim();
            // Mark THIS TAB as player in sessionStorage.
            // Do NOT touch fracturedSkyIsDM / fracturedSkySessionId in localStorage ‚Äî
            // those belong to the DM tab. Wiping them here was the root cause of the
            // DM being unable to auto-reconnect after a refresh in split-tab same-browser use.
            sessionStorage.setItem('fracturedSkyTabRole', 'player');

            roomCode = code;
            localStorage.setItem('fracturedSkyPlayerRoom', code);
            localStorage.setItem('fracturedSkyPlayerName', myName);

            peer = new Peer();
            peer.on('open', (id) => {
                myId = id;
                const conn = peer.connect(code);

                setupConnection(conn, true);

                conn.on('open', () => {
                    // Send join request
                    sendToPeer(conn, {
                        type: 'playerJoinRequest',
                        name: myName,
                        peerId: myId
                    });
                    
                    document.getElementById('playerSuccess').classList.add('show');
                    
                    setTimeout(() => {
                        closePlayerModal();
                        document.getElementById('welcomeScreen').classList.add('hidden');
                        document.getElementById('connectionTabContainer').style.display = 'block';
                        updateConnectionStatus('Waiting for approval...', false);
                    }, 2000);
                });
                
                conn.on('error', (err) => {
                    document.getElementById('playerError').textContent = 'Connection failed: ' + err.type;
                    document.getElementById('playerError').classList.add('show');
                });
            });
        }

        function playerAutoReconnect() {
            const savedRoom = localStorage.getItem('fracturedSkyPlayerRoom');
            const savedName = localStorage.getItem('fracturedSkyPlayerName');
            if (!savedRoom || !savedName || isDM) return;
            myName = savedName;
            roomCode = savedRoom;

            // Track the peer ID we most recently tried so we don't open
            // duplicate connections when the Firebase watcher fires multiple times.
            let lastAttemptedPeerId = null;
            // The latest peer ID we know about (from Firebase or savedRoom).
            // Used by scheduleRetry so we keep knocking on the same door while
            // waiting for the DM to come back online.
            let currentBestPeerId = null;
            // ONE shared timeout handle ‚Äî always cancelled before starting a new
            // connect attempt, so a stale timeout from attempt N can never reset
            // lastAttemptedPeerId while attempt N+1 is already in flight.
            let activeConnTimeout = null;

            // After a failed attempt, retry with the best-known peer ID after 15 s.
            // This handles the case where the DM comes back with the SAME peer ID
            // (the Firebase watcher won't fire again if the value didn't change).
            function scheduleRetry() {
                setTimeout(() => {
                    if (isDM) return; // user switched to DM ‚Äî stop retrying
                    if (lastAttemptedPeerId === null) doConnect(currentBestPeerId || savedRoom);
                }, 15000);
            }

            function doConnect(targetPeerId) {
                if (isDM) return; // user switched to DM ‚Äî abort
                if (targetPeerId === lastAttemptedPeerId) return; // already trying
                currentBestPeerId = targetPeerId;
                lastAttemptedPeerId = targetPeerId;

                // Cancel any timeout from the previous attempt before we destroy
                // that peer ‚Äî prevents the old callback from firing after we move on.
                if (activeConnTimeout) { clearTimeout(activeConnTimeout); activeConnTimeout = null; }

                if (peer && !peer.destroyed) { try { peer.destroy(); } catch(e) {} }
                peer = new Peer();
                peer.on('open', (id) => {
                    myId = id;
                    const conn = peer.connect(targetPeerId);
                    setupConnection(conn, true);

                    activeConnTimeout = setTimeout(() => {
                        activeConnTimeout = null;
                        if (isDM) return; // user became DM ‚Äî don't overwrite DM status
                        lastAttemptedPeerId = null;
                        updateConnectionStatus('Waiting for DM...', false);
                        scheduleRetry(); // keep trying every 15 s while DM is offline
                    }, 12000);

                    conn.on('open', () => {
                        clearTimeout(activeConnTimeout); activeConnTimeout = null;
                        sendToPeer(conn, { type: 'playerJoinRequest', name: myName, peerId: myId, isReconnect: true });
                        updateConnectionStatus('Waiting for approval...', false);
                    });
                    conn.on('error', () => {
                        clearTimeout(activeConnTimeout); activeConnTimeout = null;
                        if (isDM) return; // user became DM ‚Äî don't overwrite DM status
                        lastAttemptedPeerId = null;
                        updateConnectionStatus('Waiting for DM...', false);
                        scheduleRetry(); // keep trying every 15 s while DM is offline
                    });
                });
                peer.on('error', () => {
                    lastAttemptedPeerId = null;
                    if (!isDM) setTimeout(playerAutoReconnect, 5000);
                });
            }

            updateConnectionStatus('Looking up room...', false);

            // Prefer Firebase onSnapshot: fires immediately with current value
            // AND fires again whenever the DM publishes a new peer ID after refresh.
            if (fbDb) {
                // Watch Firebase for live peer ID ‚Äî fires immediately if already set,
                // and again whenever the DM publishes a new peer ID after refresh.
                startFirebaseWatch(savedRoom, (peerId) => doConnect(peerId));
                // Fallback: if Firebase doesn't deliver within 4 s, try saved code directly.
                setTimeout(() => { if (lastAttemptedPeerId === null) doConnect(savedRoom); }, 4000);
            } else {
                // No Firebase ‚Äî connect directly to the saved peer ID
                doConnect(savedRoom);
            }
        }

        // === MULTIPLAYER ===
        function createRoom(existingId = null) {
            isDM = true;
            isCoDM = false;
            myName = 'Dungeon Master';
            // NOTE: do NOT clear fracturedSkyPlayerRoom / fracturedSkyPlayerName here.
            // Both tabs share localStorage; wiping those keys kills the player tab's
            // ability to reconnect whenever the DM refreshes in the same browser.
            // playerAutoReconnect already guards itself with `if (isDM) return`, so
            // the DM tab is safe even without the removal.

            // Keep old room ID so we can load campaign data from Firebase
            // even if we end up with a different peer ID
            const fbLoadId = existingId;

            // --- Shared "peer is ready" logic ---
            function onPeerReady(id) {
                myId = id;
                roomCode = id;
                savedPeerId = id;
                // Only persist the session ID on first room creation (fbLoadId is null).
                // On reconnects fbLoadId holds the *canonical* room ID ‚Äî we must NOT
                // overwrite it with the fresh peer ID or every subsequent refresh will
                // load from the wrong Firebase doc and the room dies.
                if (!fbLoadId) {
                    localStorage.setItem('fracturedSkySessionId', id);
                }
                localStorage.setItem('fracturedSkyIsDM', 'true');
                // Mark THIS TAB as DM in sessionStorage (tab-isolated, survives refresh).
                // This is the canonical way to detect the role on refresh without
                // being confused by another tab's localStorage writes.
                sessionStorage.setItem('fracturedSkyTabRole', 'dm');
                onDMReady();
                document.getElementById('firebaseSection').style.display = 'flex';
                document.getElementById('firebaseStatus').style.display = 'inline';
                firebaseSignIn().then(() => {
                    const loadId = fbLoadId || roomCode;
                    // Always save/heartbeat to the canonical room doc (loadId) so
                    // data never splits across multiple Firestore documents when the
                    // DM gets a new peer ID after refresh.
                    firebaseRoomRef = loadId;

                    // Publish the DM's live peer ID to the canonical room doc so
                    // players/co-DMs watching it always learn the latest peer ID,
                    // even when a fresh peer ID was assigned after refresh.
                    if (fbDb) {
                        const stamp = { currentPeerId: id, lastSeen: Date.now() };
                        fbDb.collection('vtt_rooms').doc(loadId).set(stamp, { merge: true }).catch(() => {});
                    }

                    loadFromFirebase(loadId);

                    // Keep Firebase updated every 20 s so onSnapshot watchers on
                    // players and co-DMs receive a timely wake-up call even if
                    // they missed the first write.
                    startDMHeartbeat();
                });
            }

            // --- Fall back to a fresh random peer ID (with retry) ---
            function startFreshPeer(attempt = 1) {
                updateConnectionStatus('Getting new session...', false);
                if (peer) { try { peer.destroy(); } catch(e) {} }
                peer = new Peer();
                let done = false;
                const t = setTimeout(() => {
                    if (done) return;
                    done = true;
                    if (attempt < 5) {
                        startFreshPeer(attempt + 1);
                    } else {
                        updateConnectionStatus('Server not responding ‚Äî try refreshing', false);
                    }
                }, 8000);
                peer.on('open', id => {
                    if (done) return;
                    done = true;
                    clearTimeout(t);
                    onPeerReady(id);
                });
                peer.on('connection', conn => setupConnection(conn));
                peer.on('error', e => {
                    if (done) return;
                    done = true;
                    clearTimeout(t);
                    console.error('Peer error (fresh):', e.type, 'attempt', attempt);
                    if (attempt < 5) {
                        const delay = Math.min(attempt * 2000, 8000);
                        updateConnectionStatus('Reconnecting...', false);
                        setTimeout(() => startFreshPeer(attempt + 1), delay);
                    } else {
                        updateConnectionStatus('Connection failed ‚Äî refresh and try again', false);
                    }
                });
            }

            // --- Try to claim a specific peer ID, with up to 3 retries ---
            function tryClaimId(idToClaim, attempt) {
                if (peer) { try { peer.destroy(); } catch(e) {} }
                peer = new Peer(idToClaim);
                // Guard so the timeout and the error event can't both call startFreshPeer
                let alreadyDone = false;

                // 4-second timeout per attempt ‚Äî if the signalling server hasn't
                // responded by then, fall through to a fresh random peer ID fast.
                const timeout = setTimeout(() => {
                    if (alreadyDone) return;
                    alreadyDone = true;
                    updateConnectionStatus('Server slow ‚Äî switching to new session...', false);
                    startFreshPeer();
                }, 4000);

                peer.on('open', id => {
                    if (alreadyDone) return;
                    alreadyDone = true;
                    clearTimeout(timeout);
                    onPeerReady(id);
                });
                peer.on('connection', conn => setupConnection(conn));
                peer.on('error', err => {
                    if (alreadyDone) return;
                    alreadyDone = true;
                    clearTimeout(timeout);
                    if (err.type === 'unavailable-id' && attempt < 3) {
                        // Short delays: 500 ms, 1 s ‚Äî fast fallthrough to fresh ID
                        const delay = attempt * 500;
                        updateConnectionStatus(`Reclaiming session... (${attempt}/3)`, false);
                        setTimeout(() => tryClaimId(idToClaim, attempt + 1), delay);
                    } else {
                        // All retries exhausted or other error ‚Äî fall back to fresh ID
                        // Campaign data will still load from Firebase
                        startFreshPeer();
                    }
                });
            }

            if (existingId) {
                // Tell any other tab holding this peer ID to release it
                try {
                    const bc = new BroadcastChannel('fracturedSky_dm');
                    bc.postMessage({ type: 'surrender', id: existingId });
                    bc.close();
                } catch(e) {}
                // Short pause for the release, then try to claim
                setTimeout(() => tryClaimId(existingId, 1), 500);
            } else {
                startFreshPeer();
            }
        }

        // Called whenever this tab successfully claims the DM role
        function onDMReady() {
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('welcomeReconnect').style.display = 'none';
            document.getElementById('welcomeButtons').style.display = 'flex';
            document.getElementById('startFreshBtn').style.display = 'none';
            document.getElementById('connectionTabContainer').style.display = 'block';
            document.getElementById('roomCodeSection').style.display = 'block';
            document.getElementById('roomCode').textContent = roomCode;
            document.getElementById('dmControlsBtn').style.display = 'block';
            document.getElementById('musicToggleBtn').style.display = 'block';
            document.getElementById('stagingZone').style.display = 'flex';
            updateConnectionStatus('Connected as DM', true);
            updateUserList();
            loadSavedCloudLink();
            initMusicPanel();
            // Open the connection panel to show the room code ‚Äî stays open until DM closes it
            const panel = document.getElementById('connectionPanel');
            if (!panel.classList.contains('open')) toggleConnectionPanel();
        }

        // === CO-DM ===
        function showCoDMLogin() {
            document.getElementById('coDMModal').classList.add('active');
        }
        function closeCoDMModal() {
            document.getElementById('coDMModal').classList.remove('active');
            document.getElementById('coDMError').classList.remove('show');
        }
        function coDMLogin(e) {
            e.preventDefault();
            const name = document.getElementById('coDMName').value.trim();
            const code = document.getElementById('coDMRoomCode').value.trim();
            const pass = document.getElementById('coDMPass').value;
            if (pass !== 'FracturedSky2025!') {
                document.getElementById('coDMError').classList.add('show');
                return;
            }
            closeCoDMModal();
            joinAsCoDM(name, code);
        }
        function joinAsCoDM(name, code) {
            isDM = true;
            isCoDM = true;
            myName = name;
            roomCode = code;
            // Remember for automatic reconnects
            coDMOriginalCode = code;
            coDMOriginalName = name;
            clearTimeout(coDMReconnectTimer);

            function doConnect(targetPeerId) {
                if (peer && !peer.destroyed) { try { peer.destroy(); } catch(e) {} }
                peer = new Peer();
                peer.on('open', (id) => {
                    myId = id;
                    hostDMConn = peer.connect(targetPeerId);
                    setupConnection(hostDMConn, false); // isPlayer=false ‚Üí DM-side connection

                    // Give the host up to 12 s to answer; schedule reconnect if it doesn't.
                    const connTimeout = setTimeout(() => {
                        updateConnectionStatus('Host not reachable ‚Äî retrying...', false);
                        coDMReconnectTimer = setTimeout(coDMAutoReconnect, 5000);
                    }, 12000);

                    hostDMConn.on('open', () => {
                        clearTimeout(connTimeout);
                        sendToPeer(hostDMConn, { type: 'coDMJoinRequest', name, peerId: myId });
                        document.getElementById('welcomeScreen').classList.add('hidden');
                        document.getElementById('connectionTabContainer').style.display = 'block';
                        updateConnectionStatus('Connecting as Co-DM...', false);
                    });
                    hostDMConn.on('error', () => {
                        clearTimeout(connTimeout);
                        updateConnectionStatus('Co-DM connection failed ‚Äî retrying...', false);
                        coDMReconnectTimer = setTimeout(coDMAutoReconnect, 5000);
                    });
                });
                peer.on('error', () => {
                    updateConnectionStatus('Peer error ‚Äî retrying...', false);
                    coDMReconnectTimer = setTimeout(coDMAutoReconnect, 5000);
                });
            }

            // Look up the host DM's current live peer ID from Firebase first,
            // in case they refreshed and got a new peer ID since we last connected.
            if (fbDb) {
                updateConnectionStatus('Co-DM: Looking up host...', false);
                firebaseSignIn().then(() => {
                    return fbDb.collection('vtt_rooms').doc(code).get();
                }).then(doc => {
                    const livePeerId = doc.exists && doc.data() && doc.data().currentPeerId;
                    doConnect(livePeerId || code);
                }).catch(() => doConnect(code));
            } else {
                doConnect(code);
            }
        }

        function setupConnection(conn, isPlayer = false) {
            conn.on('data', (data) => handleMessage(conn, data));

            function onConnOpen() {
                if (!isPlayer) {
                    connections.set(conn.peer, { conn, name: 'Unknown', role: 'player', approved: false });
                } else {
                    connections.set(conn.peer, { conn, name: 'Dungeon Master', role: 'dm', approved: true });
                }
                updateUserList();
            }

            // PeerJS can fire 'connection' after the DataChannel is already
            // open, meaning conn.on('open') would never fire. Guard against
            // that race by running onConnOpen immediately if already open.
            if (conn.open) {
                onConnOpen();
            } else {
                conn.on('open', onConnOpen);
            }

            conn.on('close', () => {
                connections.delete(conn.peer);
                updateUserList();
                if (isCoDM && conn === hostDMConn) {
                    // Co-DM lost its connection to the host DM ‚Äî reconnect via Firebase
                    updateConnectionStatus('Host DM disconnected ‚Äî reconnecting...', false);
                    clearTimeout(coDMReconnectTimer);
                    coDMReconnectTimer = setTimeout(coDMAutoReconnect, 3000);
                } else if (isPlayer) {
                    // Regular player lost connection to DM
                    updateConnectionStatus('Disconnected ‚Äî reconnecting...', false);
                    stopFirebaseWatch(); // will be restarted inside playerAutoReconnect
                    setTimeout(playerAutoReconnect, 3000);
                }
            });
        }

        function handleMessage(conn, data) {
            switch (data.type) {
                // --- Co-DM handshake ---
                case 'coDMJoinRequest':
                    if (isDM && !isCoDM) {
                        // Accept co-DM: give them full game state + co-DM role
                        const connData = connections.get(conn.peer);
                        if (connData) {
                            connData.name = data.name + ' (Co-DM)';
                            connData.role = 'co-dm';
                            connData.approved = true;
                        }
                        coDMs.set(conn.peer, conn);
                        sendToPeer(conn, { type: 'coDMApproved', name: data.name, roomCode });
                        sendGameState(conn);
                        updateUserList();
                    }
                    break;

                case 'coDMApproved':
                    // We are the co-DM, host approved us
                    myName = data.name + ' (Co-DM)';
                    roomCode = data.roomCode;
                    document.getElementById('roomCodeSection').style.display = 'block';
                    document.getElementById('roomCode').textContent = roomCode;
                    document.getElementById('dmControlsBtn').style.display = 'block';
                    document.getElementById('musicToggleBtn').style.display = 'block';
                    document.getElementById('stagingZone').style.display = 'flex';
                    updateConnectionStatus('Connected as Co-DM', true);
                    updateUserList();
                    initMusicPanel();
                    break;

                case 'coDMBroadcast':
                    // Host DM receives a change from a co-DM, applies it and re-broadcasts
                    if (isDM && !isCoDM) {
                        handleIncomingChange(data.payload);
                        // Re-broadcast to every approved client EXCEPT the originating
                        // co-DM ‚Äî this includes players AND other co-DMs so they all
                        // stay in sync when multiple co-DMs are connected.
                        const originPeer = conn.peer;
                        connections.forEach(({ conn: c, approved }) => {
                            if (approved && c.peer !== originPeer) sendToPeer(c, data.payload);
                        });
                    }
                    break;

                case 'playerJoinRequest':
                    if (isDM) {
                        // Auto-approve players whose name was previously approved (handles restarts too)
                        if (approvedPlayerNames.has(data.name)) {
                            // Connection entry may not exist yet if the data message
                            // arrived before PeerJS fired conn.on('open') (race condition).
                            let connData = connections.get(conn.peer);
                            if (!connData) {
                                connData = { conn, name: data.name, role: 'player', approved: false };
                                connections.set(conn.peer, connData);
                            }
                            connData.approved = true;
                            connData.name = data.name;
                            sendToPeer(conn, { type: 'playerApproved', name: data.name, canonicalRoomId: firebaseRoomRef || roomCode });
                            sendGameState(conn);
                            updateUserList();
                            console.log('‚úÖ Auto-approved reconnecting player:', data.name);
                        } else {
                            pendingRequests.push({
                                peerId: conn.peer,
                                name: data.name,
                                conn: conn
                            });
                            showJoinToast(data.name);
                            renderPendingRequests();
                        }
                    }
                    break;
                    
                case 'playerApproved':
                    // Successfully joined ‚Äî stop watching Firebase for peer ID changes.
                    stopFirebaseWatch();
                    myName = data.name;
                    // Keep roomCode as the DM's live peer ID for this session's P2P use.
                    roomCode = conn.peer;
                    // But persist the *canonical* room ID (sent by the DM) so that after
                    // future DM refreshes the player watches the same Firebase doc that
                    // the DM always writes its new peer ID to. Saving conn.peer here
                    // caused the watch chain to drift and the room to "die" after 2 refreshes.
                    localStorage.setItem('fracturedSkyPlayerRoom', data.canonicalRoomId || conn.peer);
                    localStorage.setItem('fracturedSkyPlayerName', myName);
                    // Keep sessionStorage in sync so refresh always uses the canonical room ID.
                    sessionStorage.setItem('fracturedSkyTabRole', 'player');
                    sessionStorage.setItem('fracturedSkyPlayerRoom', data.canonicalRoomId || conn.peer);
                    updateConnectionStatus('Connected to room', true);
                    requestGameState(conn);
                    document.getElementById('welcomeScreen').classList.add('hidden');
                    document.getElementById('welcomeReconnect').style.display = 'none';
                    document.getElementById('welcomeButtons').style.display = 'none';
                    document.getElementById('startFreshBtn').style.display = 'none';
                    document.getElementById('playerPanelContainer').style.display = 'block';
                    savePlayerState();
                    break;
                    
                case 'playerRejected':
                    alert('Your join request was denied by the DM.');
                    break;
                    
                case 'tokenRequest':
                    if (isDM) {
                        // Add to pending requests
                        pendingRequests.push({
                            type: 'token',
                            peerId: conn.peer,
                            name: data.playerName,
                            tokenData: data.tokenData,
                            conn: conn
                        });
                        renderPendingRequests();
                    }
                    break;
                    
                case 'tokenApproved':
                    // Token was approved, add to staging
                    stagingTokens.push(data.token);
                    renderStagingTokens();
                    break;
                    
                case 'requestState':
                    // Player asking DM to send the full game state (sent right after playerApproved)
                    if (isDM) sendGameState(conn);
                    break;

                case 'gameState':
                    loadGameState(data.state);
                    break;
                    
                case 'gridUpdate':
                    updateGridFromNetwork(data);
                    break;
                    
                case 'tokenUpdate':
                    // Separate staging and placed tokens
                    stagingTokens = [];
                    placedTokens = [];
                    
                    data.tokens.forEach(token => {
                        if (token.x !== undefined && token.y !== undefined) {
                            // Has position = placed token
                            placedTokens.push(token);
                        } else {
                            // No position = staging token
                            stagingTokens.push(token);
                        }
                    });
                    
                    console.log('üé≤ Token update:', stagingTokens.length, 'staging,', placedTokens.length, 'placed');
                    renderStagingTokens();
                    draw();
                    break;
                    
                case 'fogUpdate':
                    updateFogFromNetwork(data);
                    break;
                    
                case 'imagesUpdate':
                    placedImages = [];
                    data.images.forEach(imgData => {
                        const img = new Image();
                        img.onload = () => {
                            placedImages.push({
                                img: img,
                                x: imgData.x,
                                y: imgData.y,
                                width: imgData.width,
                                height: imgData.height,
                                rotation: imgData.rotation,
                                gridX: imgData.gridX,
                                gridY: imgData.gridY
                            });
                            draw();
                        };
                        img.src = imgData.src;
                    });
                    break;

                case 'musicCue':
                    if (isCoDM) {
                        // Co-DM relays musicCue to its own approved players
                        connections.forEach(({ conn: c, approved, role }) => {
                            if (approved && role === 'player') sendToPeer(c, data);
                        });
                    } else if (!isDM) {
                        // Player plays the cued track
                        const track = MUSIC_TRACKS.find(t => t.id === data.trackId);
                        const audio = document.getElementById('musicAudio');
                        if (track) {
                            audio.src = track.file;
                            audio.volume = 0.6;
                            audio.play().catch(() => {});
                            const notice = document.createElement('div');
                            notice.style.cssText = 'position:fixed;bottom:70px;left:50%;transform:translateX(-50%);background:var(--bg-card);border:1px solid var(--accent);padding:0.5rem 1rem;border-radius:8px;font-size:0.8rem;z-index:9999;pointer-events:none;';
                            notice.textContent = `${track.emoji} DM playing: ${track.label}`;
                            document.body.appendChild(notice);
                            setTimeout(() => notice.remove(), 4500);
                        } else {
                            audio.pause();
                        }
                    }
                    break;
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Delete selected image
            if (e.key === 'Delete' && selectedImage && isDM) {
                const index = placedImages.indexOf(selectedImage);
                if (index > -1) {
                    placedImages.splice(index, 1);
                    selectedImage = null;
                    draw();
                    broadcastImages();
                }
            }
        });

        function sendToPeer(conn, data) {
            if (!conn || !conn.open) return;
            try {
                conn.send(data);
            } catch (err) {
                console.error('Send error:', err);
            }
        }

        function broadcast(data) {
            if (isCoDM && hostDMConn) {
                // Co-DM: route through host DM who will re-broadcast to players
                sendToPeer(hostDMConn, { type: 'coDMBroadcast', payload: data });
            } else {
                // Host DM: broadcast directly to approved players and co-DMs
                connections.forEach(({ conn, approved }) => {
                    if (approved) sendToPeer(conn, data);
                });
            }
            scheduleSave();
        }

        // Apply an incoming state change from a co-DM without re-broadcasting
        function handleIncomingChange(data) {
            switch (data.type) {
                case 'gridUpdate':     updateGridFromNetwork(data); updateMinimap(); break;
                case 'tokenUpdate':
                    stagingTokens = [];
                    placedTokens = [];
                    (data.tokens || []).forEach(t => {
                        if (t.x !== undefined) placedTokens.push(t);
                        else stagingTokens.push(t);
                    });
                    renderStagingTokens(); draw();
                    break;
                case 'fogUpdate':      updateFogFromNetwork(data); break;
                case 'imagesUpdate':
                    placedImages = [];
                    (data.images || []).forEach(imgData => {
                        const img = new Image();
                        img.onload = () => { placedImages.push({ img, x:imgData.x, y:imgData.y, width:imgData.width, height:imgData.height, rotation:imgData.rotation, gridX:imgData.gridX, gridY:imgData.gridY }); draw(); };
                        img.src = imgData.src;
                    });
                    break;
            }
        }

        function approvePlayer(index) {
            const request = pendingRequests[index];
            if (!request || request.type === 'token') return;

            // Ensure the connection entry exists ‚Äî it may not if the data message
            // (playerJoinRequest) arrived before PeerJS fired conn.on('open') on
            // the DM side (a known PeerJS race condition).
            let connData = connections.get(request.peerId);
            if (!connData) {
                connData = { conn: request.conn, name: request.name, role: 'player', approved: false };
                connections.set(request.peerId, connData);
            }
            connData.approved = true;
            connData.name = request.name;
            approvedPlayerNames.add(request.name);
            localStorage.setItem('fracturedSkyApprovedNames', JSON.stringify([...approvedPlayerNames]));

            sendToPeer(request.conn, {
                type: 'playerApproved',
                name: request.name,
                canonicalRoomId: firebaseRoomRef || roomCode
            });

            sendGameState(request.conn);
            
            pendingRequests.splice(index, 1);
            renderPendingRequests();
            updateUserList();
        }

        function rejectPlayer(index) {
            const request = pendingRequests[index];
            if (!request || request.type === 'token') return;
            
            sendToPeer(request.conn, { type: 'playerRejected' });
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function approveToken(index) {
            const request = pendingRequests[index];
            if (!request || request.type !== 'token') return;
            
            const token = {
                ...request.tokenData,
                owner: request.name,
                approved: true
            };
            
            stagingTokens.push(token);
            renderStagingTokens();
            
            sendToPeer(request.conn, {
                type: 'tokenApproved',
                token: token
            });
            
            broadcast({
                type: 'tokenUpdate',
                tokens: [...stagingTokens, ...placedTokens]
            });
            
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function rejectToken(index) {
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function showJoinToast(name) {
            // Persistent banner at top of screen ‚Äî DM cannot miss it
            const existing = document.getElementById('joinToast');
            if (existing) existing.remove();
            const toast = document.createElement('div');
            toast.id = 'joinToast';
            toast.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#f59e0b;color:#1a1a2e;text-align:center;padding:0.75rem 1rem;font-weight:700;font-size:1rem;z-index:99999;cursor:pointer;letter-spacing:0.05em;';
            toast.innerHTML = `üîî PLAYER REQUEST: <strong>${name}</strong> wants to join ‚Äî click here or open DM Controls`;
            toast.onclick = () => {
                toast.remove();
                const panel = document.getElementById('dmPanel');
                if (panel && !panel.classList.contains('open')) panel.classList.add('open');
                const dmContent = document.querySelector('.dm-content');
                if (dmContent) dmContent.scrollTop = 0;
            };
            document.body.prepend(toast);
        }

        function renderPendingRequests() {
            const container = document.getElementById('pendingRequests');

            if (pendingRequests.length === 0) {
                container.innerHTML = '<p style="font-size: 0.85rem; color: var(--text-dim);">No pending requests</p>';
                const btn = document.getElementById('dmControlsBtn');
                if (btn) btn.textContent = 'üé≠ DM Controls';
                const toast = document.getElementById('joinToast');
                if (toast) toast.remove();
                return;
            }

            // Badge the header button, force-open the DM panel, scroll to top
            const btn = document.getElementById('dmControlsBtn');
            if (btn) btn.textContent = `üé≠ DM Controls (${pendingRequests.length}) üîî`;
            const panel = document.getElementById('dmPanel');
            if (panel && !panel.classList.contains('open')) {
                panel.classList.add('open');
            }
            // Always scroll DM panel to top so Player Requests is visible
            const dmContent = document.querySelector('.dm-content');
            if (dmContent) dmContent.scrollTop = 0;
            
            container.innerHTML = pendingRequests.map((req, idx) => {
                if (req.type === 'token') {
                    return `
                        <div class="request-item">
                            <div class="request-info">
                                <div class="request-name">${req.name}</div>
                                <div class="request-detail">Token: ${req.tokenData.icon}</div>
                            </div>
                            <div class="request-actions">
                                <button class="btn btn-small btn-success" onclick="approveToken(${idx})">‚úì</button>
                                <button class="btn btn-small btn-danger" onclick="rejectToken(${idx})">‚úï</button>
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="request-item">
                            <div class="request-info">
                                <div class="request-name">${req.name}</div>
                                <div class="request-detail">Wants to join</div>
                            </div>
                            <div class="request-actions">
                                <button class="btn btn-small btn-success" onclick="approvePlayer(${idx})">‚úì</button>
                                <button class="btn btn-small btn-danger" onclick="rejectPlayer(${idx})">‚úï</button>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }

        function sendGameState(conn) {
            const gridData = {};
            for (let key in gridCells) {
                gridData[key] = gridCells[key].toDataURL();
            }
            
            const fogData = {};
            for (let group in fogGroups) {
                fogData[group] = fogGroups[group].canvas.toDataURL();
            }
            
            // Serialize placed images
            const imagesData = placedImages.map(pi => ({
                src: pi.img.src,
                x: pi.x,
                y: pi.y,
                width: pi.width,
                height: pi.height,
                rotation: pi.rotation,
                gridX: pi.gridX,
                gridY: pi.gridY
            }));
            
            sendToPeer(conn, {
                type: 'gameState',
                state: {
                    gridCells: gridData,
                    lockedCells,
                    fogGroups: fogData,
                    tokens: [...stagingTokens, ...placedTokens],
                    placedImages: imagesData,
                    zoom,
                    panX,
                    panY
                }
            });
            
            console.log('üì§ Sent game state:', stagingTokens.length + placedTokens.length, 'tokens,', imagesData.length, 'images');
        }

        function requestGameState(conn) {
            sendToPeer(conn, { type: 'requestState' });
        }

        function loadGameState(state) {
            console.log('üì• Loading game state...');
            
            // Load grid
            gridCells = {};
            for (let key in state.gridCells) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = CELL_SIZE;
                    canvas.height = CELL_SIZE;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    gridCells[key] = canvas;
                    draw();
                };
                img.src = state.gridCells[key];
            }
            
            // Load fog
            for (let group in state.fogGroups) {
                if (!fogGroups[group]) {
                    fogGroups[group] = { name: group, canvas: document.createElement('canvas') };
                    fogGroups[group].canvas.width = GRID_SIZE * 3;
                    fogGroups[group].canvas.height = GRID_SIZE * 3;
                }
                const img = new Image();
                img.onload = () => {
                    const ctx = fogGroups[group].canvas.getContext('2d');
                    ctx.clearRect(0, 0, fogGroups[group].canvas.width, fogGroups[group].canvas.height);
                    ctx.drawImage(img, 0, 0);
                    draw();
                };
                img.src = state.fogGroups[group];
            }
            
            // Load tokens (IMPORTANT!)
            if (state.tokens) {
                stagingTokens = [];
                placedTokens = [];
                
                state.tokens.forEach(token => {
                    // Separate staging vs placed tokens
                    if (token.x !== undefined && token.y !== undefined) {
                        // It's a placed token
                        placedTokens.push(token);
                    } else {
                        // It's a staging token
                        stagingTokens.push(token);
                    }
                });
                
                console.log('‚úÖ Loaded tokens:', stagingTokens.length, 'staging,', placedTokens.length, 'placed');
                renderStagingTokens();
            }
            
            // Load placed images if present
            if (state.placedImages) {
                placedImages = [];
                state.placedImages.forEach(imgData => {
                    const img = new Image();
                    img.onload = () => {
                        placedImages.push({
                            img: img,
                            x: imgData.x,
                            y: imgData.y,
                            width: imgData.width,
                            height: imgData.height,
                            rotation: imgData.rotation,
                            gridX: imgData.gridX,
                            gridY: imgData.gridY
                        });
                        draw();
                    };
                    img.src = imgData.src;
                });
            }
            
            lockedCells = state.lockedCells || {};
            zoom = state.zoom || 1;
            panX = state.panX || 0;
            panY = state.panY || 0;
            
            document.getElementById('zoomSlider').value = zoom * 100;
            document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
            
            draw();
            updateMinimap();
        }

        function updateGridFromNetwork(data) {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = CELL_SIZE;
                canvas.height = CELL_SIZE;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                gridCells[`${data.cellX},${data.cellY}`] = canvas;
                draw();
                updateMinimap();
            };
            img.src = data.imageData;
        }

        function updateFogFromNetwork(data) {
            console.log('üå´Ô∏è Received fog update for group:', data.group);
            if (fogGroups[data.group]) {
                const img = new Image();
                img.onload = () => {
                    const ctx = fogGroups[data.group].canvas.getContext('2d');
                    ctx.clearRect(0, 0, fogGroups[data.group].canvas.width, fogGroups[data.group].canvas.height);
                    ctx.drawImage(img, 0, 0);
                    draw();
                    console.log('‚úÖ Fog updated on canvas');
                };
                img.onerror = () => {
                    console.error('‚ùå Failed to load fog image');
                };
                img.src = data.fogData;
            } else {
                console.warn('‚ö†Ô∏è Fog group not found:', data.group);
            }
        }

        function toggleConnectionPanel() {
            const panel = document.getElementById('connectionPanel');
            const tab = document.getElementById('connectionTab');
            const arrow = document.getElementById('tabArrow');
            
            if (panel.classList.contains('open')) {
                panel.classList.remove('open');
                tab.classList.remove('open');
                arrow.textContent = '‚ñº';
            } else {
                panel.classList.add('open');
                tab.classList.add('open');
                arrow.textContent = '‚ñ≤';
            }
        }

        function updateConnectionStatus(text, connected) {
            if (_elStatusText) _elStatusText.textContent = text;
            [_elStatusIndicator, _elTabIndicator].forEach(ind => {
                if (!ind) return;
                if (connected) ind.classList.add('connected');
                else ind.classList.remove('connected');
            });
        }

        function updateUserList() {
            const container = document.getElementById('userList');
            const users = [];
            if (isDM) users.push({ name: myName, role: isCoDM ? 'Co-DM' : 'DM' });
            connections.forEach(({ name, role, approved }) => {
                if (approved) {
                    const label = role === 'co-dm' ? 'Co-DM' : role === 'dm' ? 'DM' : 'Player';
                    users.push({ name, role: label });
                }
            });
            if (users.length === 0) {
                container.innerHTML = '<p style="font-size:0.85rem;color:var(--text-dim);">No users</p>';
                return;
            }
            container.innerHTML = users.map(u => `
                <div class="user-item">
                    <span>${u.name}</span>
                    <span class="user-role ${u.role === 'Co-DM' ? 'co-dm' : ''}">${u.role}</span>
                </div>
            `).join('');
        }

        function copyRoomCode() {
            if (!roomCode) {
                console.error('No room code to copy');
                return;
            }
            
            // Try modern clipboard API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(roomCode).then(() => {
                    const elem = document.getElementById('roomCode');
                    const old = elem.textContent;
                    elem.textContent = '‚úì Copied!';
                    elem.style.background = 'var(--accent)';
                    elem.style.color = 'white';
                    setTimeout(() => {
                        elem.textContent = old;
                        elem.style.background = 'var(--bg-dark)';
                        elem.style.color = 'var(--accent)';
                    }, 2000);
                    console.log('‚úÖ Room code copied:', roomCode);
                }).catch(err => {
                    console.error('Clipboard API failed:', err);
                    fallbackCopy();
                });
            } else {
                // Fallback for older browsers
                fallbackCopy();
            }
        }
        
        function fallbackCopy() {
            try {
                // Create temporary textarea
                const textarea = document.createElement('textarea');
                textarea.value = roomCode;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                const elem = document.getElementById('roomCode');
                const old = elem.textContent;
                elem.textContent = '‚úì Copied!';
                elem.style.background = 'var(--accent)';
                elem.style.color = 'white';
                setTimeout(() => {
                    elem.textContent = old;
                    elem.style.background = 'var(--bg-dark)';
                    elem.style.color = 'var(--accent)';
                }, 2000);
                console.log('‚úÖ Room code copied (fallback):', roomCode);
            } catch (err) {
                console.error('Copy failed:', err);
                alert('Could not copy. Room code: ' + roomCode);
            }
        }

        // === TOKENS ===
        function showTokenModal() {
            document.getElementById('tokenRequestModal').classList.add('active');
            setTokenType('emoji'); // Default to emoji
        }

        function closeTokenModal() {
            document.getElementById('tokenRequestModal').classList.remove('active');
            tokenImageData = null;
        }

        function setTokenType(type) {
            tokenType = type;
            
            document.getElementById('emojiTokenBtn').classList.remove('btn-primary');
            document.getElementById('imageTokenBtn').classList.remove('btn-primary');
            
            if (type === 'emoji') {
                document.getElementById('emojiTokenBtn').classList.add('btn-primary');
                document.getElementById('emojiTokenInputs').style.display = 'block';
                document.getElementById('imageTokenInputs').style.display = 'none';
            } else {
                document.getElementById('imageTokenBtn').classList.add('btn-primary');
                document.getElementById('emojiTokenInputs').style.display = 'none';
                document.getElementById('imageTokenInputs').style.display = 'block';
            }
        }

        function createToken() {
            const color = document.getElementById('tokenColor').value;
            
            if (tokenType === 'emoji') {
                const emoji = document.getElementById('tokenEmoji').value || '‚öîÔ∏è';
                
                if (isDM) {
                    const token = {
                        id: Date.now(),
                        type: 'emoji',
                        icon: emoji,
                        color: color,
                        size: 12, // Default size (fits in single grid square)
                        owner: 'DM',
                        approved: true
                    };
                    
                    stagingTokens.push(token);
                    renderStagingTokens();
                    closeTokenModal();
                    
                    broadcast({
                        type: 'tokenUpdate',
                        tokens: [...stagingTokens, ...placedTokens]
                    });
                }
            } else {
                // Image token
                const file = document.getElementById('tokenImageFile').files[0];
                if (!file) {
                    alert('Please select an image file');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    if (isDM) {
                        const token = {
                            id: Date.now(),
                            type: 'image',
                            imageData: e.target.result,
                            color: color,
                            size: 12, // Default size (fits in single grid square)
                            owner: 'DM',
                            approved: true
                        };
                        
                        stagingTokens.push(token);
                        renderStagingTokens();
                        closeTokenModal();
                        
                        broadcast({
                            type: 'tokenUpdate',
                            tokens: [...stagingTokens, ...placedTokens]
                        });
                    }
                };
                reader.readAsDataURL(file);
            }
        }

        function renderStagingTokens() {
            const container = document.getElementById('stagingTokens');
            container.innerHTML = stagingTokens.map(t => {
                if (t.type === 'image') {
                    return `
                        <div class="token-item" draggable="true" ondragstart="dragTokenStart(event, ${t.id})" style="background: ${t.color}; background-image: url('${t.imageData}'); background-size: cover; background-position: center;">
                            <div class="token-owner">${t.owner}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="token-item" draggable="true" ondragstart="dragTokenStart(event, ${t.id})" style="background: ${t.color};">
                            ${t.icon}
                            <div class="token-owner">${t.owner}</div>
                        </div>
                    `;
                }
            }).join('');
            
            if (stagingTokens.length > 0) {
                document.getElementById('stagingZone').style.display = 'flex';
            }
        }

        function dragTokenStart(e, tokenId) {
            const token = stagingTokens.find(t => t.id === tokenId);
            e.dataTransfer.setData('application/json', JSON.stringify(token));
            draggedToken = token;
        }

        function toggleGridSnap() {
            gridSnapEnabled = document.getElementById('gridSnap').checked;
        }

        function snapToGrid(value) {
            if (!gridSnapEnabled) return value;
            // Snap to center of grid squares instead of intersections
            // Grid squares are GRID_SNAP_SIZE x GRID_SNAP_SIZE
            // Centers are at 12.5, 37.5, 62.5, etc. (GRID_SNAP_SIZE / 2 + n * GRID_SNAP_SIZE)
            const gridCenter = GRID_SNAP_SIZE / 2;
            return Math.round((value - gridCenter) / GRID_SNAP_SIZE) * GRID_SNAP_SIZE + gridCenter;
        }

        // === DRAWING ===
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);

            // Grid cells
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const x = col * GRID_SIZE;
                    const y = row * GRID_SIZE;
                    const key = `${col},${row}`;
                    
                    ctx.fillStyle = '#1a1f2e';
                    ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                    
                    if (gridCells[key]) {
                        ctx.drawImage(gridCells[key], x, y, GRID_SIZE, GRID_SIZE);
                    }
                    
                    ctx.strokeStyle = '#2a2f3e';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                    
                    if (col === currentCellX && row === currentCellY && isDM) {
                        ctx.strokeStyle = lockedCells[key] ? '#fbbf24' : '#8b5cf6';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                    }
                }
            }

            // Grid snap lines
            if (gridSnapEnabled) {
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.15)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= GRID_SIZE * 3; x += GRID_SNAP_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, GRID_SIZE * 3);
                    ctx.stroke();
                }
                for (let y = 0; y <= GRID_SIZE * 3; y += GRID_SNAP_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(GRID_SIZE * 3, y);
                    ctx.stroke();
                }
            }

            // Placed images (DM layer)
            placedImages.forEach(pi => {
                ctx.save();
                ctx.translate(pi.x + pi.width / 2, pi.y + pi.height / 2);
                ctx.rotate(pi.rotation * Math.PI / 180);
                ctx.drawImage(pi.img, -pi.width / 2, -pi.height / 2, pi.width, pi.height);
                ctx.restore();
                
                // Draw selection handles if selected
                if (isDM && selectedImage === pi) {
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(pi.x, pi.y, pi.width, pi.height);
                    ctx.setLineDash([]);
                    
                    // Corner handles for resize
                    const handleSize = 8;
                    ctx.fillStyle = '#8b5cf6';
                    ctx.fillRect(pi.x - handleSize/2, pi.y - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(pi.x + pi.width - handleSize/2, pi.y - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(pi.x - handleSize/2, pi.y + pi.height - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(pi.x + pi.width - handleSize/2, pi.y + pi.height - handleSize/2, handleSize, handleSize);
                    
                    // Rotation handle
                    ctx.beginPath();
                    ctx.arc(pi.x + pi.width / 2, pi.y - 20, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fill();
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });

            // Placed tokens
            placedTokens.forEach(t => {
                const tokenSize = t.size || 12; // Default to 12px (fits in 25px grid square)
                const borderWidth = Math.max(2, tokenSize / 6); // Proportional border
                const fontSize = Math.max(12, tokenSize * 1.5); // Proportional font
                
                ctx.fillStyle = t.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, tokenSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = borderWidth;
                ctx.stroke();
                
                if (t.type === 'image' && t.imageData) {
                    // Use cached Image to avoid creating a new object every frame
                    let cached = tokenImageCache.get(t.id);
                    if (!cached || cached.srcKey !== t.imageData) {
                        const img = new Image();
                        img.src = t.imageData;
                        img.onload = () => draw(); // redraw once loaded
                        cached = { img, srcKey: t.imageData };
                        tokenImageCache.set(t.id, cached);
                    }
                    const img = cached.img;
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, tokenSize - 1, 0, Math.PI * 2);
                    ctx.clip();
                    const imgSize = (tokenSize - 1) * 2;
                    if (img.complete && img.naturalWidth) {
                        ctx.drawImage(img, t.x - (tokenSize - 1), t.y - (tokenSize - 1), imgSize, imgSize);
                    }
                    ctx.restore();
                } else {
                    // Draw emoji token
                    ctx.fillStyle = '#fff';
                    ctx.font = `${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(t.icon || '‚öîÔ∏è', t.x, t.y);
                }
            });

            ctx.restore();

            // Fog - FULLY OPAQUE for players, semi-transparent for DM
            if (fogGroups[activeFogGroup]) {
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoom, zoom);
                
                // DM sees through fog, players see full black
                if (isDM) {
                    ctx.globalAlpha = dmFogOpacity;
                } else {
                    ctx.globalAlpha = 1.0; // Full opacity for players
                }
                
                ctx.drawImage(fogGroups[activeFogGroup].canvas, 0, 0, GRID_SIZE * 3, GRID_SIZE * 3);
                ctx.restore();
            }

            updateMinimap();
        }

        // === MAP BUILDER ===
        function selectCell(x, y) {
            if (!isDM) return;
            currentCellX = x;
            currentCellY = y;
            
            const key = `${x},${y}`;
            if (gridCells[key]) {
                mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                mapCtx.drawImage(gridCells[key], 0, 0);
            } else {
                mapCtx.fillStyle = '#f5f5dc';
                mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            }
            
            updateGridDisplay();
            draw();
        }

        function updateGridDisplay() {
            if (_elCurrentCell) _elCurrentCell.textContent = gridNames[currentCellY][currentCellX];
        }

        function setTool(t) {
            // Track last tool before switching to eraser
            if (tool !== 'eraser' && t === 'eraser') {
                lastToolBeforeEraser = tool;
                // Show eraser options
                document.getElementById('eraserOptions').style.display = 'block';
                updateEraserModeUI();
            } else if (t !== 'eraser') {
                // Hide eraser options
                document.getElementById('eraserOptions').style.display = 'none';
            }
            
            // Show/hide stamp library toggle
            if (t === 'stamp') {
                document.getElementById('stampLibraryToggle').style.display = 'block';
            } else {
                document.getElementById('stampLibraryToggle').style.display = 'none';
            }
            
            // Deselect image when switching tools
            if (t !== 'select') {
                selectedImage = null;
                draw();
            }
            
            tool = t;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const toolBtn = document.getElementById(t + 'Btn');
            if (toolBtn) toolBtn.classList.add('active');
            
            const assetNames = {
                brush: 'Brush',
                fill: 'Fill',
                stamp: 'Stamp: ' + currentStamp,
                image: 'Place Image',
                select: 'Select & Move',
                eraser: eraserMode === 'content' ? 
                       (lastToolBeforeEraser === 'brush' ? 'Brush Strokes' : 
                        lastToolBeforeEraser === 'fill' ? 'Fill Areas' :
                        lastToolBeforeEraser === 'stamp' ? 'Stamps' : 'Content') :
                       'Everything'
            };
            currentAsset = assetNames[t] || t;
            (_elCurrentAsset||{}).textContent = currentAsset;
        }

        function selectStamp(emoji) {
            currentStamp = emoji;
            currentAsset = 'Stamp: ' + emoji;
            (_elCurrentAsset||{}).textContent = currentAsset;
            setTool('stamp'); // Ensure stamp tool is active
        }

        // Stamp library docking
        let stampLibraryDocked = false;
        let stampLibraryDragOffset = null;

        function toggleStampLibrary() {
            const panel = document.getElementById('stampLibraryContainer');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function closeStampLibrary() {
            document.getElementById('stampLibraryContainer').style.display = 'none';
        }

        function toggleStampLibraryCollapse() {
            document.getElementById('stampLibraryPanel').classList.toggle('collapsed');
            const btn = document.getElementById('stampCollapseBtn');
            btn.textContent = document.getElementById('stampLibraryPanel').classList.contains('collapsed') ? '+' : '‚àí';
        }

        function toggleStampLibraryDock() {
            stampLibraryDocked = !stampLibraryDocked;
            const container = document.getElementById('stampLibraryContainer');
            const btn = document.getElementById('stampDockBtn');
            
            if (stampLibraryDocked) {
                container.style.cursor = 'default';
                btn.textContent = 'üîí';
            } else {
                container.style.cursor = 'move';
                btn.textContent = 'üîì';
            }
        }

        // Stamp library dragging
        const stampLibraryContainer = document.getElementById('stampLibraryContainer');
        stampLibraryContainer.addEventListener('mousedown', (e) => {
            if (stampLibraryDocked) return;
            if (e.target.closest('.minimap-btn') || e.target.closest('.tool-btn')) return;
            
            stampLibraryDragOffset = {
                x: e.clientX - stampLibraryContainer.offsetLeft,
                y: e.clientY - stampLibraryContainer.offsetTop
            };
        });

        let _stampRafPending = false;
        document.addEventListener('mousemove', (e) => {
            if (!stampLibraryDragOffset || stampLibraryDocked) return;
            if (_stampRafPending) return;
            _stampRafPending = true;
            requestAnimationFrame(() => {
                _stampRafPending = false;
                if (!stampLibraryDragOffset) return;
                stampLibraryContainer.style.left = (e.clientX - stampLibraryDragOffset.x) + 'px';
                stampLibraryContainer.style.top = (e.clientY - stampLibraryDragOffset.y) + 'px';
                stampLibraryContainer.style.bottom = 'auto';
            });
        });

        document.addEventListener('mouseup', () => {
            if (stampLibraryDragOffset) {
                stampLibraryDragOffset = null;
            }
        });

        // Player token functions
        let playerTokenType = 'emoji';

        function showPlayerTokenModal() {
            document.getElementById('playerTokenModal').classList.add('active');
            setPlayerTokenType('emoji');
        }

        function closePlayerTokenModal() {
            document.getElementById('playerTokenModal').classList.remove('active');
        }

        function setPlayerTokenType(type) {
            playerTokenType = type;
            
            document.getElementById('playerEmojiTokenBtn').classList.remove('btn-primary');
            document.getElementById('playerImageTokenBtn').classList.remove('btn-primary');
            
            if (type === 'emoji') {
                document.getElementById('playerEmojiTokenBtn').classList.add('btn-primary');
                document.getElementById('playerEmojiTokenInputs').style.display = 'block';
                document.getElementById('playerImageTokenInputs').style.display = 'none';
            } else {
                document.getElementById('playerImageTokenBtn').classList.add('btn-primary');
                document.getElementById('playerEmojiTokenInputs').style.display = 'none';
                document.getElementById('playerImageTokenInputs').style.display = 'block';
            }
        }

        function requestPlayerToken() {
            const color = document.getElementById('playerTokenColor').value;
            
            if (playerTokenType === 'emoji') {
                const emoji = document.getElementById('playerTokenEmoji').value || '‚öîÔ∏è';
                
                connections.forEach(({ conn, role }) => {
                    if (role === 'dm') {
                        sendToPeer(conn, {
                            type: 'tokenRequest',
                            playerName: myName,
                            tokenData: {
                                id: Date.now(),
                                type: 'emoji',
                                icon: emoji,
                                color: color,
                                size: 12 // Default size
                            }
                        });
                    }
                });
                
                closePlayerTokenModal();
                alert('‚úÖ Token request sent to DM for approval!');
            } else {
                // Image token
                const file = document.getElementById('playerTokenImageFile').files[0];
                if (!file) {
                    alert('Please select an image file');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    connections.forEach(({ conn, role }) => {
                        if (role === 'dm') {
                            sendToPeer(conn, {
                                type: 'tokenRequest',
                                playerName: myName,
                                tokenData: {
                                    id: Date.now(),
                                    type: 'image',
                                    imageData: e.target.result,
                                    color: color,
                                    size: 12 // Default size
                                }
                            });
                        }
                    });
                    
                    closePlayerTokenModal();
                    alert('‚úÖ Token request sent to DM for approval!');
                };
                reader.readAsDataURL(file);
            }
        }

        function setStamp(emoji) {
            currentStamp = emoji;
            currentAsset = 'Stamp: ' + emoji;
            (_elCurrentAsset||{}).textContent = currentAsset;
        }

        function updateColor(value) {
            color = value;
        }

        function importMapImage(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    mapCtx.drawImage(img, 0, 0, mapCanvas.width, mapCanvas.height);
                    saveHistory();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function importImageToCanvas(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Place image at center of current cell
                    const cellX = currentCellX * GRID_SIZE + GRID_SIZE / 2;
                    const cellY = currentCellY * GRID_SIZE + GRID_SIZE / 2;
                    
                    // Scale image to fit within cell
                    const maxSize = GRID_SIZE * 0.8;
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > maxSize || height > maxSize) {
                        const scale = Math.min(maxSize / width, maxSize / height);
                        width *= scale;
                        height *= scale;
                    }
                    
                    const placedImg = {
                        img: img,
                        x: cellX - width / 2,
                        y: cellY - height / 2,
                        width: width,
                        height: height,
                        rotation: 0,
                        gridX: currentCellX,
                        gridY: currentCellY
                    };
                    
                    placedImages.push(placedImg);
                    selectedImage = placedImg;
                    setTool('select');
                    draw();
                    
                    // Broadcast to players
                    broadcastImages();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function broadcastImages() {
            const imageData = placedImages.map(pi => ({
                src: pi.img.src,
                x: pi.x,
                y: pi.y,
                width: pi.width,
                height: pi.height,
                rotation: pi.rotation,
                gridX: pi.gridX,
                gridY: pi.gridY
            }));
            
            broadcast({
                type: 'imagesUpdate',
                images: imageData
            });
        }

        function setEraserMode(mode) {
            eraserMode = mode;
            updateEraserModeUI();
            
            // Update asset indicator
            if (tool === 'eraser') {
                const assetNames = {
                    content: lastToolBeforeEraser === 'brush' ? 'Brush Strokes' : 
                             lastToolBeforeEraser === 'texture' ? 'Textures' : 
                             lastToolBeforeEraser === 'image' ? 'Images' : 'Content',
                    all: 'Everything'
                };
                currentAsset = assetNames[mode];
                (_elCurrentAsset||{}).textContent = currentAsset;
            }
        }

        function updateEraserModeUI() {
            // Update button states
            document.getElementById('eraseContentBtn').classList.remove('btn-primary');
            document.getElementById('eraseAllBtn').classList.remove('btn-primary');
            
            if (eraserMode === 'content') {
                document.getElementById('eraseContentBtn').classList.add('btn-primary');
                document.getElementById('eraserModeDesc').textContent = 'Erases drawn content without touching background';
            } else {
                document.getElementById('eraseAllBtn').classList.add('btn-primary');
                document.getElementById('eraserModeDesc').textContent = 'Erases everything including background color';
            }
        }

        function setSize(v) {
            size = v;
            document.getElementById('sizeValue').textContent = v + 'px';
        }

        function saveHistory() {
            const imageData = mapCtx.getImageData(0, 0, mapCanvas.width, mapCanvas.height);
            
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            history.push(imageData);
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
            
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                mapCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                mapCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
        }

        function clearMapCanvas() {
            mapCtx.fillStyle = '#f5f5dc';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            saveHistory();
        }

        function submitCell() {
            const key = `${currentCellX},${currentCellY}`;
            const cellCanvas = document.createElement('canvas');
            cellCanvas.width = CELL_SIZE;
            cellCanvas.height = CELL_SIZE;
            const cellCtx = cellCanvas.getContext('2d');
            cellCtx.drawImage(mapCanvas, 0, 0);
            gridCells[key] = cellCanvas;
            
            draw();
            
            broadcast({
                type: 'gridUpdate',
                cellX: currentCellX,
                cellY: currentCellY,
                imageData: cellCanvas.toDataURL()
            });
        }

        function deselectAllTools() {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            tool = null;
            currentAsset = 'None';
            (_elCurrentAsset||{}).textContent = currentAsset;
        }

        // Map canvas drawing
        mapCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = mapCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
            lastX = x;
            lastY = y;
            
            if (tool === 'brush') {
                mapCtx.beginPath();
                mapCtx.moveTo(x, y);
                mapCtx.strokeStyle = color;
                mapCtx.lineWidth = size;
                mapCtx.lineCap = 'round';
                mapCtx.lineJoin = 'round';
            } else if (tool === 'fill') {
                mapCtx.fillStyle = color;
                mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
                saveHistory();
                isDrawing = false;
            } else if (tool === 'stamp') {
                mapCtx.font = '48px Arial';
                mapCtx.textAlign = 'center';
                mapCtx.textBaseline = 'middle';
                mapCtx.fillText(currentStamp, x, y);
                saveHistory();
                isDrawing = false;
            } else if (tool === 'eraser') {
                mapCtx.save();
                
                if (eraserMode === 'content') {
                    // Erase only drawn content, not background
                    mapCtx.globalCompositeOperation = 'destination-out';
                    mapCtx.strokeStyle = 'rgba(0,0,0,1)';
                } else {
                    // Erase everything including background
                    mapCtx.globalCompositeOperation = 'source-over';
                    mapCtx.strokeStyle = '#f5f5dc'; // Match background color
                }
                
                mapCtx.beginPath();
                mapCtx.moveTo(x, y);
                mapCtx.lineWidth = size;
                mapCtx.lineCap = 'round';
                mapCtx.lineJoin = 'round';
            }
        });

        mapCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = mapCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
            
            if (tool === 'brush' || tool === 'eraser') {
                mapCtx.lineTo(x, y);
                mapCtx.stroke();
            }
        });

        mapCanvas.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                if (tool === 'eraser') {
                    mapCtx.restore(); // Restore composite operation
                }
                saveHistory();
            }
        });

        mapCanvas.addEventListener('mouseleave', () => {
            if (isDrawing) {
                isDrawing = false;
                if (tool === 'eraser') {
                    mapCtx.restore(); // Restore composite operation
                }
                saveHistory();
            }
        });

        document.getElementById('colorPicker').addEventListener('change', (e) => {
            color = e.target.value;
        });

        // Main canvas interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX;
            const screenY = e.clientY;
            const mx = (screenX - rect.left - panX) / zoom;
            const my = (screenY - rect.top - panY) / zoom;
            
            // Check if clicking on a placed token (for moving it)
            if (!fogMode && tool !== 'select') {
                for (let i = placedTokens.length - 1; i >= 0; i--) {
                    const token = placedTokens[i];
                    const tokenSize = token.size || 12;
                    const dist = Math.hypot(mx - token.x, my - token.y);
                    if (dist < tokenSize) {
                        // Check permissions: DM can move any token, players can only move their own
                        if (isDM || token.owner === myName) {
                            draggedPlacedToken = token;
                            tokenDragOffset = { x: mx - token.x, y: my - token.y };
                            console.log('üéØ Selected token:', token.owner, token.icon || 'image');
                            return;
                        } else {
                            console.log('üö´ Cannot move token owned by:', token.owner);
                            return;
                        }
                    }
                }
            }
            
            // Image selection and manipulation (Select tool ONLY)
            if (isDM && tool === 'select') {
                // Check if clicking on rotation handle
                if (selectedImage) {
                    const rotX = selectedImage.x + selectedImage.width / 2;
                    const rotY = selectedImage.y - 20;
                    if (Math.hypot(mx - rotX, my - rotY) < 10) {
                        imageResizeHandle = 'rotate';
                        imageDragStart = { x: mx, y: my };
                        return;
                    }
                    
                    // Check corner handles for resize
                    const handleSize = 8;
                    const handles = [
                        { type: 'nw', x: selectedImage.x, y: selectedImage.y },
                        { type: 'ne', x: selectedImage.x + selectedImage.width, y: selectedImage.y },
                        { type: 'sw', x: selectedImage.x, y: selectedImage.y + selectedImage.height },
                        { type: 'se', x: selectedImage.x + selectedImage.width, y: selectedImage.y + selectedImage.height }
                    ];
                    
                    for (let h of handles) {
                        if (Math.abs(mx - h.x) < handleSize && Math.abs(my - h.y) < handleSize) {
                            imageResizeHandle = h.type;
                            imageDragStart = { x: mx, y: my, origWidth: selectedImage.width, origHeight: selectedImage.height, origX: selectedImage.x, origY: selectedImage.y };
                            return;
                        }
                    }
                }
                
                // Check if clicking on an image
                for (let i = placedImages.length - 1; i >= 0; i--) {
                    const pi = placedImages[i];
                    if (mx >= pi.x && mx <= pi.x + pi.width && my >= pi.y && my <= pi.y + pi.height) {
                        selectedImage = pi;
                        imageDragStart = { x: mx, y: my, imgX: pi.x, imgY: pi.y };
                        draw();
                        return;
                    }
                }
                
                // Clicked empty space - deselect
                selectedImage = null;
                draw();
                return;
            }
            
            // Fog mode painting
            if (isDM && fogMode) {
                isFogDrawing = true;
                
                if (fogPaintMode === 'brush') {
                    paintFog(mx, my);
                } else if (fogPaintMode === 'rect') {
                    fogRectStart = { x: mx, y: my };
                }
                return;
            }
            
            // Normal panning (when not in fog mode and not using select tool)
            lastX = screenX;
            lastY = screenY;
            isDrawing = true;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX;
            const screenY = e.clientY;
            const mx = (screenX - rect.left - panX) / zoom;
            const my = (screenY - rect.top - panY) / zoom;
            
            // Token dragging
            if (draggedPlacedToken) {
                draggedPlacedToken.x = snapToGrid(mx - tokenDragOffset.x);
                draggedPlacedToken.y = snapToGrid(my - tokenDragOffset.y);
                draw();
                return;
            }
            
            // Image manipulation (Select tool only)
            if (isDM && tool === 'select' && selectedImage && imageDragStart) {
                if (imageResizeHandle === 'rotate') {
                    // Rotate around center
                    const centerX = selectedImage.x + selectedImage.width / 2;
                    const centerY = selectedImage.y + selectedImage.height / 2;
                    const angle = Math.atan2(my - centerY, mx - centerX) * 180 / Math.PI + 90;
                    selectedImage.rotation = angle;
                    draw();
                    return;
                } else if (imageResizeHandle) {
                    // Resize
                    const dx = mx - imageDragStart.x;
                    const dy = my - imageDragStart.y;
                    
                    if (imageResizeHandle === 'se') {
                        selectedImage.width = imageDragStart.origWidth + dx;
                        selectedImage.height = imageDragStart.origHeight + dy;
                    } else if (imageResizeHandle === 'nw') {
                        selectedImage.width = imageDragStart.origWidth - dx;
                        selectedImage.height = imageDragStart.origHeight - dy;
                        selectedImage.x = imageDragStart.origX + dx;
                        selectedImage.y = imageDragStart.origY + dy;
                    } else if (imageResizeHandle === 'ne') {
                        selectedImage.width = imageDragStart.origWidth + dx;
                        selectedImage.height = imageDragStart.origHeight - dy;
                        selectedImage.y = imageDragStart.origY + dy;
                    } else if (imageResizeHandle === 'sw') {
                        selectedImage.width = imageDragStart.origWidth - dx;
                        selectedImage.height = imageDragStart.origHeight + dy;
                        selectedImage.x = imageDragStart.origX + dx;
                    }
                    
                    // Minimum size
                    if (selectedImage.width < 50) selectedImage.width = 50;
                    if (selectedImage.height < 50) selectedImage.height = 50;
                    
                    draw();
                    return;
                } else {
                    // Move
                    selectedImage.x = imageDragStart.imgX + (mx - imageDragStart.x);
                    selectedImage.y = imageDragStart.imgY + (my - imageDragStart.y);
                    draw();
                    return;
                }
            }
            
            // Fog painting
            if (isDM && isFogDrawing) {
                if (fogPaintMode === 'brush') {
                    paintFog(mx, my);
                } else if (fogPaintMode === 'rect' && fogRectStart) {
                    // Just update for preview, actual painting on mouseup
                    draw();
                    
                    // Draw preview rectangle
                    ctx.save();
                    const reveal = document.getElementById('revealMode').checked;
                    ctx.strokeStyle = reveal ? '#10b981' : '#ef4444';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 5 / zoom]);
                    ctx.translate(panX, panY);
                    ctx.scale(zoom, zoom);
                    ctx.strokeRect(fogRectStart.x, fogRectStart.y, mx - fogRectStart.x, my - fogRectStart.y);
                    ctx.restore();
                }
                return;
            }
            
            // Normal panning (only when not in fog mode and not dragging anything)
            if (!isDrawing || fogMode || (isDM && tool === 'select') || draggedPlacedToken) return;
            panX += screenX - lastX;
            panY += screenY - lastY;
            lastX = screenX;
            lastY = screenY;
            draw();
        });

        canvas.addEventListener('mouseup', (e) => {
            // Token movement complete - broadcast to all
            if (draggedPlacedToken) {
                console.log('‚úÖ Token moved:', draggedPlacedToken.owner);
                broadcast({
                    type: 'tokenUpdate',
                    tokens: [...stagingTokens, ...placedTokens]
                });
                draggedPlacedToken = null;
                tokenDragOffset = { x: 0, y: 0 };
            }
            
            // Image manipulation complete
            if (imageDragStart) {
                imageDragStart = null;
                imageResizeHandle = null;
                broadcastImages();
            }
            
            if (isFogDrawing && fogPaintMode === 'rect' && fogRectStart) {
                const rect = canvas.getBoundingClientRect();
                const mx = (e.clientX - rect.left - panX) / zoom;
                const my = (e.clientY - rect.top - panY) / zoom;
                
                paintFogRect(fogRectStart.x, fogRectStart.y, mx, my);
                fogRectStart = null;
            }
            
            isFogDrawing = false;
            isDrawing = false;
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!draggedToken) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = snapToGrid((e.clientX - rect.left - panX) / zoom);
            const y = snapToGrid((e.clientY - rect.top - panY) / zoom);
            
            const placedToken = {
                ...draggedToken,
                x,
                y
            };
            
            placedTokens.push(placedToken);
            stagingTokens = stagingTokens.filter(t => t.id !== draggedToken.id);
            
            renderStagingTokens();
            draw();
            
            broadcast({
                type: 'tokenUpdate',
                tokens: [...stagingTokens, ...placedTokens]
            });
            
            draggedToken = null;
        });

        // === FOG ===
        function showFogGroupModal() {
            document.getElementById('fogGroupModal').classList.add('active');
        }

        function closeFogGroupModal() {
            document.getElementById('fogGroupModal').classList.remove('active');
        }

        function createFogGroup() {
            const name = document.getElementById('fogGroupName').value.trim();
            if (!name) return;
            
            const id = 'group_' + Date.now();
            const fogCanvas = document.createElement('canvas');
            fogCanvas.width = GRID_SIZE * 3;
            fogCanvas.height = GRID_SIZE * 3;
            const fogCtx = fogCanvas.getContext('2d');
            fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Full opacity black fog
            fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
            
            fogGroups[id] = { name, canvas: fogCanvas };
            renderFogGroups();
            closeFogGroupModal();
            
            document.getElementById('fogGroupName').value = '';
        }

        function renderFogGroups() {
            const container = document.getElementById('fogGroups');
            container.innerHTML = Object.keys(fogGroups).map(id => `
                <div class="fog-group-item ${activeFogGroup === id ? 'active' : ''}">
                    <span class="fog-group-name">${fogGroups[id].name}</span>
                    <button class="btn btn-small ${activeFogGroup === id ? 'btn-primary' : ''}" onclick="setActiveFogGroup('${id}')">
                        ${activeFogGroup === id ? 'Active' : 'Select'}
                    </button>
                </div>
            `).join('');
        }

        function setActiveFogGroup(groupId) {
            activeFogGroup = groupId;
            renderFogGroups();
            draw();
        }

        function setFogPaintMode(mode) {
            fogPaintMode = mode;
            document.getElementById('fogBrushBtn').classList.remove('btn-primary');
            document.getElementById('fogRectBtn').classList.remove('btn-primary');
            
            if (mode === 'brush') {
                document.getElementById('fogBrushBtn').classList.add('btn-primary');
            } else {
                document.getElementById('fogRectBtn').classList.add('btn-primary');
            }
        }

        function toggleFogMode() {
            if (!isDM) return;
            
            fogMode = !fogMode;
            const btn = document.getElementById('fogModeToggle');
            const controls = document.getElementById('fogControls');
            
            if (fogMode) {
                // FOG MODE ON - Orange button
                btn.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
                btn.style.borderColor = '#f97316';
                btn.textContent = 'üå´Ô∏è Fog Paint Mode: ON';
                controls.style.opacity = '1';
                controls.style.pointerEvents = 'all';
            } else {
                // FOG MODE OFF - Purple button
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.classList.add('btn-primary');
                btn.textContent = 'üå´Ô∏è Fog Paint Mode: OFF';
                controls.style.opacity = '0.5';
                controls.style.pointerEvents = 'none';
            }
        }

        function updateFogSize(value) {
            fogBrushSize = parseInt(value);
            document.getElementById('fogSizeValue').textContent = value + 'px';
        }

        function resetFog() {
            if (!isDM) return;
            if (!confirm('Reset all fog for the active group?')) return;
            
            if (fogGroups[activeFogGroup]) {
                const ctx = fogGroups[activeFogGroup].canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,1)';
                ctx.fillRect(0, 0, fogGroups[activeFogGroup].canvas.width, fogGroups[activeFogGroup].canvas.height);
                draw();
                
                broadcast({
                    type: 'fogUpdate',
                    group: activeFogGroup,
                    fogData: fogGroups[activeFogGroup].canvas.toDataURL()
                });
            }
        }

        function paintFog(x, y) {
            if (!isDM || !fogGroups[activeFogGroup]) return;
            
            const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
            const reveal = document.getElementById('revealMode').checked;
            
            fogCtx.save();
            
            if (reveal) {
                // Erase fog (reveal map)
                fogCtx.globalCompositeOperation = 'destination-out';
                fogCtx.fillStyle = 'rgba(0,0,0,1)';
            } else {
                // Add fog (hide map)
                fogCtx.globalCompositeOperation = 'source-over';
                fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Changed to full opacity
            }
            
            fogCtx.beginPath();
            fogCtx.arc(x, y, fogBrushSize, 0, Math.PI * 2);
            fogCtx.fill();
            fogCtx.restore();
            
            draw();
            
            // Broadcast fog update in real-time (every brush stroke)
            broadcastFog();
        }

        function paintFogRect(x1, y1, x2, y2) {
            if (!isDM || !fogGroups[activeFogGroup]) return;
            
            const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
            const reveal = document.getElementById('revealMode').checked;
            
            fogCtx.save();
            
            if (reveal) {
                fogCtx.globalCompositeOperation = 'destination-out';
                fogCtx.fillStyle = 'rgba(0,0,0,1)';
            } else {
                fogCtx.globalCompositeOperation = 'source-over';
                fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Changed to full opacity
            }
            
            const width = x2 - x1;
            const height = y2 - y1;
            fogCtx.fillRect(x1, y1, width, height);
            fogCtx.restore();
            
            draw();
            
            // Broadcast fog update
            broadcastFog();
        }

        function broadcastFog() {
            if (!isDM) return;
            
            // Clear any pending broadcast
            if (fogBroadcastTimeout) {
                clearTimeout(fogBroadcastTimeout);
            }
            
            // Throttle broadcasts to every 100ms for smooth real-time updates
            fogBroadcastTimeout = setTimeout(() => {
                const fogData = fogGroups[activeFogGroup].canvas.toDataURL();
                console.log('üì° Broadcasting fog update, size:', fogData.length, 'bytes');
                
                broadcast({
                    type: 'fogUpdate',
                    group: activeFogGroup,
                    fogData: fogData
                });
                
                fogBroadcastTimeout = null;
            }, 100);
        }

        // Initialize fog mode buttons
        setFogPaintMode('brush');

        // === CAMPAIGN EXPORT/IMPORT ===
        function exportCampaign() {
            if (!isDM) return;
            
            // Serialize grid cells
            const gridData = {};
            for (let key in gridCells) {
                gridData[key] = gridCells[key].toDataURL();
            }
            
            // Serialize fog groups
            const fogData = {};
            for (let group in fogGroups) {
                fogData[group] = {
                    name: fogGroups[group].name,
                    canvas: fogGroups[group].canvas.toDataURL()
                };
            }
            
            // Serialize placed images
            const imagesData = placedImages.map(pi => ({
                src: pi.img.src,
                x: pi.x,
                y: pi.y,
                width: pi.width,
                height: pi.height,
                rotation: pi.rotation,
                gridX: pi.gridX,
                gridY: pi.gridY
            }));
            
            // Get player data
            const playerData = [];
            connections.forEach(({ name, role, approved }, peerId) => {
                if (approved) {
                    playerData.push({ name, role, peerId });
                }
            });
            
            const campaignData = {
                version: '4.0',
                name: prompt('Campaign name:', 'My Campaign') || 'Untitled Campaign',
                sessionId: roomCode,
                exported: new Date().toISOString(),
                gridCells: gridData,
                lockedCells: lockedCells,
                fogGroups: fogData,
                activeFogGroup: activeFogGroup,
                stagingTokens: stagingTokens,
                placedTokens: placedTokens,
                placedImages: imagesData,
                playerData: playerData,
                zoom: zoom,
                panX: panX,
                panY: panY,
                currentCellX: currentCellX,
                currentCellY: currentCellY,
                gridSnapEnabled: gridSnapEnabled
            };
            
            // Create downloadable file
            const dataStr = JSON.stringify(campaignData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `${campaignData.name.replace(/[^a-z0-9]/gi, '_')}_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            document.getElementById('exportSuccess').classList.add('show');
            setTimeout(() => {
                document.getElementById('exportSuccess').classList.remove('show');
            }, 3000);
            
            console.log('‚úÖ Campaign exported:', campaignData.name);
            console.log('Includes:', playerData.length, 'players,', stagingTokens.length + placedTokens.length, 'tokens');
        }
        
        function importCampaign(event) {
            if (!isDM) return;
            
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (!data.version || !data.gridCells) {
                        throw new Error('Invalid campaign file format');
                    }
                    
                    // Load grid cells
                    gridCells = {};
                    let cellsLoaded = 0;
                    const totalCells = Object.keys(data.gridCells).length;
                    
                    for (let key in data.gridCells) {
                        const img = new Image();
                        img.onload = () => {
                            const cellCanvas = document.createElement('canvas');
                            cellCanvas.width = CELL_SIZE;
                            cellCanvas.height = CELL_SIZE;
                            const cellCtx = cellCanvas.getContext('2d');
                            cellCtx.drawImage(img, 0, 0);
                            gridCells[key] = cellCanvas;
                            
                            cellsLoaded++;
                            if (cellsLoaded === totalCells) {
                                draw();
                                updateMinimap();
                            }
                        };
                        img.src = data.gridCells[key];
                    }
                    
                    // Load fog groups
                    fogGroups = {};
                    for (let group in data.fogGroups) {
                        const fogCanvas = document.createElement('canvas');
                        fogCanvas.width = GRID_SIZE * 3;
                        fogCanvas.height = GRID_SIZE * 3;
                        const fogCtx = fogCanvas.getContext('2d');
                        
                        const img = new Image();
                        img.onload = () => {
                            fogCtx.drawImage(img, 0, 0);
                            draw();
                            // Broadcast fog to all players
                            broadcastFog();
                        };
                        img.src = data.fogGroups[group].canvas;
                        
                        fogGroups[group] = {
                            name: data.fogGroups[group].name,
                            canvas: fogCanvas
                        };
                    }
                    
                    // Load placed images
                    if (data.placedImages) {
                        placedImages = [];
                        data.placedImages.forEach(imgData => {
                            const img = new Image();
                            img.onload = () => {
                                placedImages.push({
                                    img: img,
                                    x: imgData.x,
                                    y: imgData.y,
                                    width: imgData.width,
                                    height: imgData.height,
                                    rotation: imgData.rotation,
                                    gridX: imgData.gridX,
                                    gridY: imgData.gridY
                                });
                                draw();
                                broadcastImages();
                            };
                            img.src = imgData.src;
                        });
                    }
                    
                    // Load other data
                    lockedCells = data.lockedCells || {};
                    activeFogGroup = data.activeFogGroup || 'everyone';
                    stagingTokens = data.stagingTokens || [];
                    placedTokens = data.placedTokens || [];
                    zoom = data.zoom || 1;
                    panX = data.panX || 0;
                    panY = data.panY || 0;
                    currentCellX = data.currentCellX || 1;
                    currentCellY = data.currentCellY || 1;
                    gridSnapEnabled = data.gridSnapEnabled !== undefined ? data.gridSnapEnabled : true;
                    
                    // Update UI
                    document.getElementById('zoomSlider').value = zoom * 100;
                    document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
                    
                    updateGridDisplay();
                    renderFogGroups();
                    renderStagingTokens();
                    draw();
                    updateMinimap();
                    
                    // Broadcast complete state to all connected players
                    connections.forEach(({conn, approved}) => {
                        if (approved) sendGameState(conn);
                    });
                    
                    document.getElementById('importSuccess').classList.add('show');
                    setTimeout(() => {
                        document.getElementById('importSuccess').classList.remove('show');
                    }, 3000);
                    
                    const playerCount = data.playerData ? data.playerData.length : 0;
                    const tokenCount = stagingTokens.length + placedTokens.length;
                    alert('‚úÖ Campaign imported: ' + (data.name || 'Untitled') + '\n' + 
                          playerCount + ' players, ' + tokenCount + ' tokens loaded');
                    console.log('‚úÖ Campaign imported:', data.name);
                    console.log('Loaded:', playerCount, 'players,', tokenCount, 'tokens');
                    
                } catch (err) {
                    console.error('Import error:', err);
                    document.getElementById('importError').textContent = 'Import failed: ' + err.message;
                    document.getElementById('importError').classList.add('show');
                    setTimeout(() => {
                        document.getElementById('importError').classList.remove('show');
                    }, 5000);
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        function saveCloudLink() {
            if (!isDM) return;
            
            const link = document.getElementById('cloudLink').value.trim();
            if (!link) {
                alert('Please enter a cloud link first');
                return;
            }
            
            // Save to session storage
            const key = 'fracturedSky_cloudLink_' + roomCode;
            localStorage.setItem(key, link);
            
            document.getElementById('linkSuccess').classList.add('show');
            setTimeout(() => {
                document.getElementById('linkSuccess').classList.remove('show');
            }, 3000);
            
            console.log('‚úÖ Cloud link saved for session:', roomCode);
        }
        
        function openCloudLink() {
            const link = document.getElementById('cloudLink').value.trim();
            if (!link) {
                // Try to load saved link
                const key = 'fracturedSky_cloudLink_' + roomCode;
                const saved = localStorage.getItem(key);
                if (saved) {
                    window.open(saved, '_blank');
                } else {
                    alert('No cloud link saved. Paste a link first.');
                }
            } else {
                window.open(link, '_blank');
            }
        }
        
        // Load saved cloud link on DM connect
        function loadSavedCloudLink() {
            if (isDM && roomCode) {
                const key = 'fracturedSky_cloudLink_' + roomCode;
                const saved = localStorage.getItem(key);
                if (saved) {
                    document.getElementById('cloudLink').value = saved;
                }
            }
        }

        function savePlayerState() {
            if (!myName || !roomCode) return;
            
            const playerStateKey = 'fracturedSky_player_' + roomCode + '_' + myName;
            const state = {
                name: myName,
                roomCode: roomCode,
                lastSeen: Date.now(),
                isDM: isDM
            };
            
            localStorage.setItem(playerStateKey, JSON.stringify(state));
        }

        // Save player state periodically
        setInterval(savePlayerState, 60000); // Every minute

        // === PLAYER PANEL DOCKING ===
        let playerPanelDocked = false;
        let playerPanelDragOffset = null;

        function togglePlayerPanelCollapse() {
            document.getElementById('playerPanelDock').classList.toggle('collapsed');
            const btn = document.getElementById('playerCollapseBtn');
            btn.textContent = document.getElementById('playerPanelDock').classList.contains('collapsed') ? '+' : '‚àí';
        }

        function togglePlayerPanelDock() {
            playerPanelDocked = !playerPanelDocked;
            const container = document.getElementById('playerPanelContainer');
            const btn = document.getElementById('playerDockBtn');
            
            if (playerPanelDocked) {
                container.style.cursor = 'default';
                btn.textContent = 'üîí';
            } else {
                container.style.cursor = 'move';
                btn.textContent = 'üîì';
            }
        }

        // Player panel dragging
        const playerPanelContainer = document.getElementById('playerPanelContainer');
        playerPanelContainer.addEventListener('mousedown', (e) => {
            if (playerPanelDocked) return;
            if (e.target.closest('.minimap-btn') || e.target.closest('.btn')) return;
            
            playerPanelDragOffset = {
                x: e.clientX - playerPanelContainer.offsetLeft,
                y: e.clientY - playerPanelContainer.offsetTop
            };
        });

        let _playerPanelRafPending = false;
        document.addEventListener('mousemove', (e) => {
            if (!playerPanelDragOffset || playerPanelDocked) return;
            if (_playerPanelRafPending) return;
            _playerPanelRafPending = true;
            requestAnimationFrame(() => {
                _playerPanelRafPending = false;
                if (!playerPanelDragOffset) return;
                playerPanelContainer.style.left = (e.clientX - playerPanelDragOffset.x) + 'px';
                playerPanelContainer.style.top = (e.clientY - playerPanelDragOffset.y) + 'px';
                playerPanelContainer.style.right = 'auto';
                playerPanelContainer.style.bottom = 'auto';
            });
        });

        document.addEventListener('mouseup', () => {
            if (playerPanelDragOffset) {
                playerPanelDragOffset = null;
            }
        });

        // === PLAYER TOKEN SIZE ===
        function updatePlayerTokenSize(value) {
            const size = parseInt(value);
            document.getElementById('playerTokenSizeValue').textContent = size;
            
            // Update all tokens owned by this player
            let updated = false;
            placedTokens.forEach(token => {
                if (token.owner === myName) {
                    token.size = size;
                    updated = true;
                }
            });
            
            if (updated) {
                draw();
                // Broadcast token update
                broadcast({
                    type: 'tokenUpdate',
                    tokens: [...stagingTokens, ...placedTokens]
                });
            }
        }

        function adjustPlayerTokenSize(delta) {
            const slider = document.getElementById('playerTokenSize');
            const newValue = Math.max(8, Math.min(30, parseInt(slider.value) + delta));
            slider.value = newValue;
            updatePlayerTokenSize(newValue);
        }

        // === MINIMAP ===
        function updateMinimap() {
            // Build a compact state string; only rebuild the DOM when something changed
            let stateKey = `${currentCellX},${currentCellY}`;
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const key = `${col},${row}`;
                    stateKey += (gridCells[key] ? '1' : '0') + (lockedCells[key] ? 'L' : '.');
                }
            }
            if (stateKey === _minimapLastState) return;
            _minimapLastState = stateKey;

            const grid = _elMinimapGrid || document.getElementById('minimapGrid');
            const cells = [];
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const key = `${col},${row}`;
                    const classes = ['minimap-cell'];
                    if (gridCells[key]) classes.push('has-content');
                    if (lockedCells[key]) classes.push('locked');
                    if (col === currentCellX && row === currentCellY) classes.push('current');
                    cells.push(`<div class="${classes.join(' ')}" onclick="minimapNavigate(${col}, ${row})"></div>`);
                }
            }
            grid.innerHTML = cells.join('');
        }

        function minimapNavigate(col, row) {
            const centerX = (col + 0.5) * GRID_SIZE;
            const centerY = (row + 0.5) * GRID_SIZE;
            panX = canvas.width / 2 - centerX * zoom;
            panY = canvas.height / 2 - centerY * zoom;
            draw();
        }

        function recenterView() {
            panX = (canvas.width - GRID_SIZE * 3 * zoom) / 2;
            panY = (canvas.height - GRID_SIZE * 3 * zoom) / 2;
            draw();
        }

        function resetZoom() {
            zoom = 1;
            document.getElementById('zoomSlider').value = 100;
            document.getElementById('zoomValue').textContent = '100%';
            recenterView();
        }

        function setZoom(v) {
            zoom = v / 100;
            document.getElementById('zoomValue').textContent = Math.round(v) + '%';
            draw();
        }

        function toggleMinimapCollapse() {
            document.getElementById('minimap').classList.toggle('collapsed');
        }

        function toggleMinimapDock() {
            minimapDocked = !minimapDocked;
            const container = document.getElementById('minimapContainer');
            const btn = document.getElementById('dockBtn');
            
            if (minimapDocked) {
                container.classList.add('docked');
                btn.textContent = 'üîí';
            } else {
                container.classList.remove('docked');
                btn.textContent = 'üîì';
            }
        }

        // Minimap dragging
        const minimapContainer = document.getElementById('minimapContainer');
        minimapContainer.addEventListener('mousedown', (e) => {
            if (minimapDocked) return;
            if (e.target.closest('.minimap-btn') || e.target.closest('.minimap-cell')) return;
            
            minimapDragOffset = {
                x: e.clientX - minimapContainer.offsetLeft,
                y: e.clientY - minimapContainer.offsetTop
            };
        });

        let _minimapRafPending = false;
        document.addEventListener('mousemove', (e) => {
            if (!minimapDragOffset || minimapDocked) return;
            if (_minimapRafPending) return;
            _minimapRafPending = true;
            requestAnimationFrame(() => {
                _minimapRafPending = false;
                if (!minimapDragOffset) return;
                minimapContainer.style.left = (e.clientX - minimapDragOffset.x) + 'px';
                minimapContainer.style.top = (e.clientY - minimapDragOffset.y) + 'px';
                minimapContainer.style.bottom = 'auto';
            });
        });

        document.addEventListener('mouseup', () => {
            minimapDragOffset = null;
        });

        // === UI ===
        function toggleDMPanel() {
            document.getElementById('dmPanel').classList.toggle('open');
        }

        // Global error handler
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('üö® JavaScript Error:', msg);
            console.error('Line:', lineNo, 'Column:', columnNo);
            console.error('Error object:', error);
            return false;
        };

        // =============================================
        // === MUSIC PLAYER ===
        // =============================================
        const MUSIC_TRACKS = [
            { id: 'combat',      label: 'Combat',      emoji: '‚öîÔ∏è',  file: 'music/combat.mp3' },
            { id: 'boss',        label: 'Boss Battle', emoji: 'üíÄ',  file: 'music/boss.mp3' },
            { id: 'exploration', label: 'Exploration', emoji: 'üó∫Ô∏è', file: 'music/exploration.mp3' },
            { id: 'dungeon',     label: 'Dungeon',     emoji: 'üïØÔ∏è', file: 'music/dungeon.mp3' },
            { id: 'tavern',      label: 'Tavern',      emoji: 'üç∫',  file: 'music/tavern.mp3' },
            { id: 'town',        label: 'Town',        emoji: 'üèòÔ∏è', file: 'music/town.mp3' },
            { id: 'rest',        label: 'Rest',        emoji: 'üåô',  file: 'music/rest.mp3' },
            { id: 'mystery',     label: 'Mystery',     emoji: 'üîÆ',  file: 'music/mystery.mp3' },
        ];
        let currentTrack = null;
        let musicPanelDragOffset = null;

        function initMusicPanel() {
            const grid = document.getElementById('musicGrid');
            grid.innerHTML = MUSIC_TRACKS.map(t => `
                <button class="music-btn" id="mBtn_${t.id}" onclick="playMusic('${t.id}')">
                    <span class="music-emoji">${t.emoji}</span>${t.label}
                </button>
            `).join('');
        }

        function toggleMusicPanel() {
            const panel = document.getElementById('musicPanel');
            panel.classList.toggle('visible');
            if (panel.classList.contains('visible') && !document.getElementById('musicGrid').innerHTML) {
                initMusicPanel();
            }
        }

        function playMusic(trackId) {
            const track = MUSIC_TRACKS.find(t => t.id === trackId);
            if (!track) return;
            const audio = document.getElementById('musicAudio');
            // Toggle off if same track playing
            if (currentTrack === trackId && !audio.paused) { stopMusic(); return; }
            // Update UI buttons
            document.querySelectorAll('.music-btn').forEach(b => b.classList.remove('playing'));
            const btn = document.getElementById('mBtn_' + trackId);
            if (btn) btn.classList.add('playing');
            // Play audio
            audio.src = track.file;
            audio.volume = document.getElementById('musicVolume').value / 100;
            audio.play().catch(() => {
                document.getElementById('musicNowPlaying').innerHTML =
                    `<span style="color:var(--danger)">‚ö† No MP3 file yet for "${track.label}" ‚Äî add music/${track.id}.mp3</span>`;
            });
            currentTrack = trackId;
            document.getElementById('musicNowPlaying').innerHTML =
                `Now Playing: <span class="track-name">${track.emoji} ${track.label}</span>`;
            // Optionally broadcast music cue to players
            if (document.getElementById('musicBroadcast').checked) {
                broadcast({ type: 'musicCue', trackId, trackLabel: track.label, emoji: track.emoji });
            }
        }

        function stopMusic() {
            const audio = document.getElementById('musicAudio');
            audio.pause();
            audio.src = '';
            currentTrack = null;
            document.querySelectorAll('.music-btn').forEach(b => b.classList.remove('playing'));
            document.getElementById('musicNowPlaying').textContent = 'Nothing playing';
            if (document.getElementById('musicBroadcast').checked) {
                broadcast({ type: 'musicCue', trackId: null });
            }
        }

        function setMusicVolume(val) {
            const audio = document.getElementById('musicAudio');
            audio.volume = val / 100;
        }


        // Music panel dragging
        const musicPanel = document.getElementById('musicPanel');
        musicPanel.addEventListener('mousedown', (e) => {
            if (e.target.closest('.music-btn') || e.target.closest('.minimap-btn') ||
                e.target.closest('input') || e.target.closest('button')) return;
            musicPanelDragOffset = { x: e.clientX - musicPanel.offsetLeft, y: e.clientY - musicPanel.offsetTop };
        });
        let _musicRafPending = false;
        document.addEventListener('mousemove', (e) => {
            if (!musicPanelDragOffset) return;
            if (_musicRafPending) return;
            _musicRafPending = true;
            requestAnimationFrame(() => {
                _musicRafPending = false;
                if (!musicPanelDragOffset) return;
                musicPanel.style.right = 'auto';
                musicPanel.style.bottom = 'auto';
                musicPanel.style.left = (e.clientX - musicPanelDragOffset.x) + 'px';
                musicPanel.style.top = (e.clientY - musicPanelDragOffset.y) + 'px';
            });
        });
        document.addEventListener('mouseup', () => { musicPanelDragOffset = null; });

        // =============================================
        // === CHARACTER SHEET ===
        // =============================================
        const SKILLS_DEF = [
            { name: 'Acrobatics',     attr: 'DEX' }, { name: 'Animal Handling', attr: 'WIS' },
            { name: 'Arcana',         attr: 'INT' }, { name: 'Athletics',       attr: 'STR' },
            { name: 'Deception',      attr: 'CHA' }, { name: 'History',         attr: 'INT' },
            { name: 'Insight',        attr: 'WIS' }, { name: 'Intimidation',    attr: 'CHA' },
            { name: 'Investigation',  attr: 'INT' }, { name: 'Medicine',        attr: 'WIS' },
            { name: 'Nature',         attr: 'INT' }, { name: 'Perception',      attr: 'WIS' },
            { name: 'Performance',    attr: 'CHA' }, { name: 'Persuasion',      attr: 'CHA' },
            { name: 'Religion',       attr: 'INT' }, { name: 'Sleight of Hand', attr: 'DEX' },
            { name: 'Stealth',        attr: 'DEX' }, { name: 'Survival',        attr: 'WIS' },
        ];
        const SAVES_DEF = ['STR','DEX','CON','INT','WIS','CHA'];
        let characters = [];     // array of character objects
        let activeCharIdx = -1;  // index into characters[]

        function showCharSheet() {
            loadCharactersFromStorage();
            renderCharList();
            buildSkillList();
            buildSavingThrows();
            document.getElementById('charOverlay').classList.add('active');
            updateAllAbilityMods();
            updateProfBonus();
        }

        function closeCharSheet() {
            document.getElementById('charOverlay').classList.remove('active');
        }

        function loadCharactersFromStorage() {
            try {
                const saved = localStorage.getItem('fracturedSky_characters');
                characters = saved ? JSON.parse(saved) : [];
            } catch(e) { characters = []; }
        }

        function saveCharactersToStorage() {
            localStorage.setItem('fracturedSky_characters', JSON.stringify(characters));
        }

        function renderCharList() {
            const el = document.getElementById('charListEl');
            if (characters.length === 0) {
                el.innerHTML = '<p style="font-size:0.85rem;color:var(--text-dim);">No characters yet. Click "+ New" to create one.</p>';
                document.getElementById('charEditor').style.display = 'none';
                document.getElementById('deleteCharBtn').style.display = 'none';
                return;
            }
            el.innerHTML = characters.map((c, i) => `
                <div class="char-list-item ${i === activeCharIdx ? 'active' : ''}" onclick="loadCharacter(${i})">
                    <div>
                        <div style="font-weight:600;">${c.name || 'Unnamed'}</div>
                        <div style="font-size:0.75rem;color:var(--text-dim);">${c.class || '?'} ${c.level || 1} ‚Ä¢ ${c.race || '?'}</div>
                    </div>
                    <div style="text-align:right;font-size:0.8rem;">
                        <div style="color:var(--danger);">‚ù§Ô∏è ${c.hp || 0}/${c.hpMax || 0}</div>
                        <div style="color:var(--text-dim);">üõ°Ô∏è AC ${c.ac || 10}</div>
                    </div>
                </div>
            `).join('');
        }

        function newCharacter() {
            const char = {
                name:'', player: myName || '', class:'Fighter', level:1, race:'', background:'', alignment:'True Neutral',
                str:10, dex:10, con:10, int:10, wis:10, cha:10,
                hp:10, hpMax:10, tempHp:0, ac:10, speed:30, hitDice:'1d10',
                skillProfs:{}, saveProfs:{},
                personality:'', ideal:'', bond:'', flaw:'',
                inventory:'', spells:'', features:'', notes:'', backstory:'',
                deathSuccesses:[false,false,false], deathFailures:[false,false,false]
            };
            characters.push(char);
            activeCharIdx = characters.length - 1;
            saveCharactersToStorage();
            renderCharList();
            populateCharEditor(char);
            document.getElementById('charEditor').style.display = 'block';
            document.getElementById('deleteCharBtn').style.display = 'inline-block';
        }

        function loadCharacter(idx) {
            activeCharIdx = idx;
            const char = characters[idx];
            populateCharEditor(char);
            document.getElementById('charEditor').style.display = 'block';
            document.getElementById('deleteCharBtn').style.display = 'inline-block';
            renderCharList();
        }

        function deleteCharacter() {
            if (activeCharIdx < 0) return;
            if (!confirm('Delete this character? This cannot be undone.')) return;
            characters.splice(activeCharIdx, 1);
            activeCharIdx = -1;
            saveCharactersToStorage();
            renderCharList();
            document.getElementById('charEditor').style.display = 'none';
            document.getElementById('deleteCharBtn').style.display = 'none';
        }

        function populateCharEditor(c) {
            document.getElementById('cName').value = c.name || '';
            document.getElementById('cPlayer').value = c.player || '';
            document.getElementById('cClass').value = c.class || 'Fighter';
            document.getElementById('cLevel').value = c.level || 1;
            document.getElementById('cRace').value = c.race || '';
            document.getElementById('cBackground').value = c.background || '';
            document.getElementById('cAlignment').value = c.alignment || 'True Neutral';
            document.getElementById('aSTR').value = c.str || 10;
            document.getElementById('aDEX').value = c.dex || 10;
            document.getElementById('aCON').value = c.con || 10;
            document.getElementById('aINT').value = c.int || 10;
            document.getElementById('aWIS').value = c.wis || 10;
            document.getElementById('aCHA').value = c.cha || 10;
            document.getElementById('cHP').value = c.hp || 10;
            document.getElementById('cHPMax').value = c.hpMax || 10;
            document.getElementById('cTempHP').value = c.tempHp || 0;
            document.getElementById('cAC').value = c.ac || 10;
            document.getElementById('cSpeed').value = c.speed || 30;
            document.getElementById('cHitDice').value = c.hitDice || '1d10';
            document.getElementById('cPersonality').value = c.personality || '';
            document.getElementById('cIdeal').value = c.ideal || '';
            document.getElementById('cBond').value = c.bond || '';
            document.getElementById('cFlaw').value = c.flaw || '';
            document.getElementById('cInventory').value = c.inventory || '';
            document.getElementById('cSpells').value = c.spells || '';
            document.getElementById('cFeatures').value = c.features || '';
            document.getElementById('cNotes').value = c.notes || '';
            document.getElementById('cBackstory').value = c.backstory || '';
            // Skill profs
            document.querySelectorAll('.skill-prof-check').forEach(cb => {
                cb.checked = !!(c.skillProfs && c.skillProfs[cb.dataset.skill]);
            });
            // Save profs
            document.querySelectorAll('.save-prof-check').forEach(cb => {
                cb.checked = !!(c.saveProfs && c.saveProfs[cb.dataset.save]);
            });
            // Death saves
            ['deathSuccesses','deathFailures'].forEach(key => {
                const type = key === 'deathSuccesses' ? 'success' : 'failure';
                document.querySelectorAll(`.death-save-pip.${type}`).forEach((pip, i) => {
                    const filled = c[key] && c[key][i];
                    pip.classList.toggle('filled', !!filled);
                });
            });
            updateAllAbilityMods();
            updateProfBonus();
        }

        function saveCharacter() {
            if (activeCharIdx < 0) { alert('No character selected. Click "+ New" first.'); return; }
            const c = characters[activeCharIdx];
            c.name = document.getElementById('cName').value;
            c.player = document.getElementById('cPlayer').value;
            c.class = document.getElementById('cClass').value;
            c.level = parseInt(document.getElementById('cLevel').value) || 1;
            c.race = document.getElementById('cRace').value;
            c.background = document.getElementById('cBackground').value;
            c.alignment = document.getElementById('cAlignment').value;
            c.str = parseInt(document.getElementById('aSTR').value) || 10;
            c.dex = parseInt(document.getElementById('aDEX').value) || 10;
            c.con = parseInt(document.getElementById('aCON').value) || 10;
            c.int = parseInt(document.getElementById('aINT').value) || 10;
            c.wis = parseInt(document.getElementById('aWIS').value) || 10;
            c.cha = parseInt(document.getElementById('aCHA').value) || 10;
            c.hp = parseInt(document.getElementById('cHP').value) || 0;
            c.hpMax = parseInt(document.getElementById('cHPMax').value) || 10;
            c.tempHp = parseInt(document.getElementById('cTempHP').value) || 0;
            c.ac = parseInt(document.getElementById('cAC').value) || 10;
            c.speed = parseInt(document.getElementById('cSpeed').value) || 30;
            c.hitDice = document.getElementById('cHitDice').value;
            c.personality = document.getElementById('cPersonality').value;
            c.ideal = document.getElementById('cIdeal').value;
            c.bond = document.getElementById('cBond').value;
            c.flaw = document.getElementById('cFlaw').value;
            c.inventory = document.getElementById('cInventory').value;
            c.spells = document.getElementById('cSpells').value;
            c.features = document.getElementById('cFeatures').value;
            c.notes = document.getElementById('cNotes').value;
            c.backstory = document.getElementById('cBackstory').value;
            // Skill profs
            c.skillProfs = {};
            document.querySelectorAll('.skill-prof-check').forEach(cb => {
                if (cb.checked) c.skillProfs[cb.dataset.skill] = true;
            });
            // Save profs
            c.saveProfs = {};
            document.querySelectorAll('.save-prof-check').forEach(cb => {
                if (cb.checked) c.saveProfs[cb.dataset.save] = true;
            });
            // Death saves
            c.deathSuccesses = [false, false, false];
            c.deathFailures = [false, false, false];
            document.querySelectorAll('.death-save-pip.success').forEach((pip, i) => {
                c.deathSuccesses[i] = pip.classList.contains('filled');
            });
            document.querySelectorAll('.death-save-pip.failure').forEach((pip, i) => {
                c.deathFailures[i] = pip.classList.contains('filled');
            });
            saveCharactersToStorage();
            renderCharList();
            // Flash save button
            const btn = document.querySelector('[onclick="saveCharacter()"]');
            const orig = btn.textContent;
            btn.textContent = '‚úì Saved!';
            btn.style.background = 'var(--success)';
            setTimeout(() => { btn.textContent = orig; btn.style.background = ''; }, 1500);
        }

        function getAbilityMod(score) { return Math.floor((parseInt(score) - 10) / 2); }

        function updateAbilityMod(attr) {
            const score = document.getElementById('a' + attr).value;
            const mod = getAbilityMod(score);
            document.getElementById('m' + attr).textContent = (mod >= 0 ? '+' : '') + mod;
            // Update initiative from DEX
            if (attr === 'DEX') document.getElementById('cInit').value = (mod >= 0 ? '+' : '') + mod;
            // Update passive perception from WIS
            if (attr === 'WIS') updatePassivePerception();
            updateSkillMods();
            updateSaveMods();
        }

        function updateAllAbilityMods() {
            ['STR','DEX','CON','INT','WIS','CHA'].forEach(a => updateAbilityMod(a));
        }

        function updateProfBonus() {
            const level = parseInt(document.getElementById('cLevel').value) || 1;
            const prof = Math.ceil(level / 4) + 1;
            document.getElementById('cProfBonus').value = '+' + prof;
            updateSkillMods();
            updateSaveMods();
            updatePassivePerception();
        }

        function getProfBonus() {
            const level = parseInt(document.getElementById('cLevel').value) || 1;
            return Math.ceil(level / 4) + 1;
        }

        function getAttrMod(attr) {
            const score = document.getElementById('a' + attr);
            return score ? getAbilityMod(score.value) : 0;
        }

        function updateSkillMods() {
            const prof = getProfBonus();
            document.querySelectorAll('.skill-mod-val').forEach(el => {
                const skill = el.dataset.skill;
                const attr = el.dataset.attr;
                const profCheck = document.querySelector(`.skill-prof-check[data-skill="${skill}"]`);
                const isProficient = profCheck && profCheck.checked;
                const mod = getAttrMod(attr) + (isProficient ? prof : 0);
                el.textContent = (mod >= 0 ? '+' : '') + mod;
            });
        }

        function updateSaveMods() {
            const prof = getProfBonus();
            document.querySelectorAll('.save-mod-val').forEach(el => {
                const attr = el.dataset.attr;
                const profCheck = document.querySelector(`.save-prof-check[data-save="${attr}"]`);
                const isProficient = profCheck && profCheck.checked;
                const mod = getAttrMod(attr) + (isProficient ? prof : 0);
                el.textContent = (mod >= 0 ? '+' : '') + mod;
            });
        }

        function updatePassivePerception() {
            const prof = getProfBonus();
            const wisMod = getAttrMod('WIS');
            const percCheck = document.querySelector('.skill-prof-check[data-skill="Perception"]');
            const isProficient = percCheck && percCheck.checked;
            const pp = 10 + wisMod + (isProficient ? prof : 0);
            const el = document.getElementById('cPassivePerception');
            if (el) el.value = pp;
        }

        function buildSkillList() {
            const el = document.getElementById('skillListEl');
            el.innerHTML = SKILLS_DEF.map(s => `
                <div class="skill-item">
                    <input type="checkbox" class="skill-prof-check" data-skill="${s.name}" onchange="updateSkillMods();updatePassivePerception()">
                    <span class="skill-mod skill-mod-val" data-skill="${s.name}" data-attr="${s.attr}">+0</span>
                    <span class="skill-name">${s.name}</span>
                    <span class="skill-attr">(${s.attr})</span>
                </div>
            `).join('');
        }

        function buildSavingThrows() {
            const el = document.getElementById('savingThrowList');
            el.innerHTML = SAVES_DEF.map(attr => `
                <div class="skill-item">
                    <input type="checkbox" class="save-prof-check" data-save="${attr}" onchange="updateSaveMods()">
                    <span class="skill-mod save-mod-val" data-attr="${attr}">+0</span>
                    <span class="skill-name">${attr}</span>
                </div>
            `).join('');
        }

        function switchCharTab(tab) {
            document.querySelectorAll('.char-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.char-tab-content').forEach(t => t.classList.remove('active'));
            document.querySelector(`.char-tab[onclick="switchCharTab('${tab}')"]`).classList.add('active');
            document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');
        }

        function changeHP(delta) {
            const input = document.getElementById('cHP');
            const max = parseInt(document.getElementById('cHPMax').value) || 10;
            input.value = Math.max(0, Math.min(max, parseInt(input.value || 0) + delta));
        }

        function toggleDeathSave(pip) {
            pip.classList.toggle('filled');
        }


        // =============================================
        // BOOT
        // =============================================
        try {
            init();
        } catch (err) {
            console.error('‚ùå Init failed:', err);
            alert('Error loading VTT: ' + err.message);
        }
    </script>
</body>
</html>
