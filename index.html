<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>From Sunnyville VTT v4.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Firebase v9 compat (matches existing firebase.X() call style) -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0e0b08;
            --bg-card: #1a1510;
            --bg-hover: #261e14;
            --accent: #c8922a;
            --accent-secondary: #e8b84b;
            --gold: #f5c518;
            --text: #e8dcc8;
            --text-dim: #9e8e72;
            --border: rgba(200, 146, 42, 0.35);
            --success: #22c55e;
            --danger: #dc2626;
            --crimson: #9b2335;
            --parchment: #f4e4c1;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }

        /* HEADER */
        .header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            position: relative;
            z-index: 100;
        }

        .title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .campaign-badge {
            padding: 0.5rem 1rem;
            background: var(--bg-hover);
            border-radius: 8px;
            border: 1px solid var(--border);
            color: var(--gold);
            font-weight: 600;
            font-size: 0.9rem;
        }

        /* BUTTONS */
        .btn {
            padding: 0.6rem 1.2rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.2s;
            font-family: 'Cinzel', serif;
            letter-spacing: 0.03em;
            text-transform: uppercase;
        }

        .btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(200,146,42,0.4);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            border: 1px solid var(--accent);
            color: var(--bg-dark);
            font-weight: 700;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, var(--accent-secondary), var(--gold));
            color: var(--bg-dark);
        }

        .btn-small {
            padding: 0.3rem 0.7rem;
            font-size: 0.75rem;
        }

        .btn-success {
            background: var(--success);
            border-color: var(--success);
            color: #0e0b08;
        }

        .btn-danger {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }

        /* WELCOME SCREEN */
        .welcome-screen {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, #1a1008 0%, #0e0b08 60%, #000 100%);
            background-image: radial-gradient(ellipse at center, #1a1008 0%, #0e0b08 60%, #000 100%),
                url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23c8922a' fill-opacity='0.04'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        .welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .welcome-content {
            text-align: center;
            padding: 3rem;
        }

        .welcome-title {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            color: var(--text-dim);
            margin-bottom: 3rem;
        }

        .welcome-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .welcome-btn {
            padding: 1rem 2rem;
            font-size: 1rem;
            border-radius: 2px;
            cursor: pointer;
            border: 2px solid var(--border);
            font-weight: 700;
            transition: all 0.3s;
            font-family: 'Cinzel', serif;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .welcome-btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            color: var(--bg-dark);
            border-color: var(--gold);
        }

        .welcome-btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(200,146,42,0.5);
            background: linear-gradient(135deg, var(--gold), var(--accent-secondary));
        }

        .welcome-btn-secondary {
            background: var(--bg-card);
            color: var(--text);
            border: 2px solid var(--border);
        }

        .welcome-btn-secondary:hover {
            border-color: var(--accent);
            background: var(--bg-hover);
            color: var(--gold);
        }

        /* MODALS */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.3s;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .modal-content {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 3px;
            padding: 2rem;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7), inset 0 0 80px rgba(200,146,42,0.03);
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .modal-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-dim);
            font-weight: 500;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 2px;
            color: var(--text);
            font-size: 0.95rem;
            font-family: 'Inter', sans-serif;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .error, .success, .info {
            padding: 0.75rem;
            border-radius: 6px;
            margin: 1rem 0;
            display: none;
        }

        .error { background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); color: var(--danger); }
        .success { background: rgba(16, 185, 129, 0.1); border: 1px solid var(--success); color: var(--success); }
        .info { background: rgba(139, 92, 246, 0.1); border: 1px solid var(--accent); color: var(--accent); }

        .error.show, .success.show, .info.show { display: block; }

        /* CONNECTION TAB */
        .connection-tab-container {
            position: fixed;
            top: 70px;
            left: 20px;
            z-index: 501;
            display: none;
        }

        .connection-tab {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-top: none;
            padding: 0.5rem 1.5rem;
            border-radius: 0 0 8px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .connection-tab:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .connection-tab.open {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .connection-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--danger);
        }

        .connection-indicator.connected {
            background: var(--success);
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* CONNECTION PANEL */
        .connection-panel {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border-bottom: 2px solid var(--border);
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s;
            z-index: 500;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }

        .connection-panel.open {
            max-height: 400px;
            padding: 1.5rem;
        }

        .connection-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .connection-section {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
        }

        .connection-section h3 {
            color: var(--gold);
            margin-bottom: 0.75rem;
            font-size: 1rem;
        }

        .room-code {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-family: monospace;
            font-size: 0.85rem;
            word-break: break-all;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            color: var(--accent);
        }

        .room-code:hover {
            border-color: var(--accent);
            transform: scale(1.02);
        }

        .user-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .user-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: var(--bg-dark);
            border-radius: 6px;
        }

        .user-role {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: var(--accent);
            color: white;
        }

        /* MAIN LAYOUT */
        .container {
            display: flex;
            height: calc(100vh - 70px);
        }

        .main-area {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .tabletop {
            flex: 1;
            background: var(--bg-card);
            border-radius: 2px;
            border: 2px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4), 0 0 0 1px rgba(200,146,42,0.1);
        }

        .tabletop-header {
            padding: 1rem 1.5rem;
            background: var(--bg-hover);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-name {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .slider {
            width: 120px;
            height: 4px;
            background: var(--bg-dark);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        /* CANVAS */
        /* CHAR TRAY */
        .char-tray {
            position: fixed;
            bottom: 44px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            align-items: flex-end;
            z-index: 7500;
            padding: 6px 12px;
            background: rgba(14,11,8,0.9);
            border: 2px solid var(--border);
            border-radius: 3px 3px 0 0;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.5), 0 0 0 1px rgba(200,146,42,0.1);
            transition: all 0.3s;
            pointer-events: auto;
            max-width: calc(100vw - 40px);
            overflow-x: auto;
        }
        .char-tray:empty { display: none; }
        .char-tray-label {
            font-size: 0.6rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.12em;
            font-family: 'Cinzel', serif;
            margin-right: 4px;
            white-space: nowrap;
            align-self: center;
        }
        .char-tray-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 6px 10px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 2px 2px 0 0;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 70px;
            position: relative;
        }
        .char-tray-btn:hover, .char-tray-btn.active {
            background: var(--bg-hover);
            border-color: var(--gold);
            box-shadow: 0 -2px 10px rgba(200,146,42,0.3);
        }
        .char-tray-btn .tray-name {
            font-size: 0.7rem;
            font-family: 'Cinzel', serif;
            color: var(--gold);
            white-space: nowrap;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .char-tray-btn .tray-hp {
            font-size: 0.6rem;
            color: var(--danger);
        }
        .char-tray-btn .tray-class {
            font-size: 0.55rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .char-tray-hp-bar {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            height: 3px;
            background: var(--bg-dark);
        }
        .char-tray-hp-fill {
            height: 100%;
            background: var(--danger);
            transition: width 0.4s;
        }

        /* CHAR QUICK-VIEW POPUP */
        .char-quickview {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            width: 380px;
            max-width: calc(100vw - 20px);
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 3px;
            box-shadow: 0 -8px 40px rgba(0,0,0,0.6);
            z-index: 7600;
            opacity: 0;
            pointer-events: none;
            transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .char-quickview.show {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-50%) scale(1);
        }
        .char-qv-header {
            background: var(--bg-hover);
            padding: 0.6rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }
        .char-qv-name { font-family: 'Cinzel', serif; color: var(--gold); font-size: 1rem; }
        .char-qv-sub  { font-size: 0.7rem; color: var(--text-dim); }
        .char-qv-body { padding: 0.75rem; }
        .char-qv-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-bottom: 0.6rem; }
        .char-qv-stat {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 2px;
            padding: 0.4rem;
            text-align: center;
        }
        .char-qv-stat-val { font-size: 1.2rem; font-weight: 700; color: var(--text); font-family: 'Cinzel', serif; }
        .char-qv-stat-lbl { font-size: 0.55rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.08em; }
        .char-qv-hp-bar-wrap { margin: 0.3rem 0 0.6rem; }
        .char-qv-hp-bar-bg { background: var(--bg-dark); border-radius: 2px; height: 8px; overflow: hidden; }
        .char-qv-hp-bar-fill { height: 100%; background: var(--danger); border-radius: 2px; transition: width 0.4s; }
        .char-qv-actions { display: flex; gap: 0.5rem; }

        .canvas-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a1208 0%, var(--bg-dark) 100%);
            overflow: hidden;
        }

        #mainCanvas {
            display: block;
            cursor: grab;
        }

        #mainCanvas:active {
            cursor: grabbing;
        }

        /* TOKEN STAGING ZONE */
        .staging-zone {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 2px solid var(--gold);
            border-radius: 2px;
            padding: 1rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            max-width: 80%;
            overflow-x: auto;
            z-index: 50;
        }

        .staging-label {
            font-size: 0.85rem;
            color: var(--gold);
            font-weight: 600;
            white-space: nowrap;
        }

        .staging-tokens {
            display: flex;
            gap: 0.5rem;
        }

        .token-item {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--border);
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            flex-shrink: 0;
            transition: all 0.2s;
            position: relative;
        }

        .token-item:hover {
            transform: scale(1.1);
            border-color: var(--accent);
            z-index: 10;
        }

        .token-owner {
            position: absolute;
            bottom: -20px;
            font-size: 0.65rem;
            color: var(--text-dim);
            white-space: nowrap;
        }

        /* MINIMAP NAVIGATOR */
        .minimap-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 600;
            cursor: move;
        }

        .minimap-container.docked {
            cursor: default;
        }

        .minimap {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 2px;
            padding: 0.75rem;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4), 0 0 0 1px rgba(200,146,42,0.1);
            width: 180px;
            transition: all 0.3s;
        }

        .minimap.collapsed {
            width: auto;
            padding: 0.5rem 1rem;
        }

        .minimap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .minimap.collapsed .minimap-header {
            margin-bottom: 0;
        }

        .minimap-title {
            font-size: 0.75rem;
            color: var(--gold);
            font-weight: 600;
        }

        .minimap-controls {
            display: flex;
            gap: 0.25rem;
        }

        .minimap-btn {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            width: 20px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: all 0.2s;
        }

        .minimap-btn:hover {
            background: var(--accent);
            color: white;
        }

        .minimap-content {
            display: block;
        }

        .minimap.collapsed .minimap-content {
            display: none;
        }

        .minimap-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 2px;
            margin-bottom: 0.5rem;
        }

        .minimap-cell {
            aspect-ratio: 1;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s;
            position: relative;
        }

        .minimap-cell:hover {
            border-color: var(--accent);
            transform: scale(1.1);
            z-index: 1;
        }

        .minimap-cell.has-content {
            background: var(--accent);
            opacity: 0.6;
        }

        .minimap-cell.locked::after {
            content: 'ðŸ”’';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
        }

        .minimap-cell.current {
            border: 2px solid var(--gold);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        .minimap-actions {
            display: flex;
            gap: 0.25rem;
        }

        .minimap-action-btn {
            flex: 1;
            padding: 0.4rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.2s;
            color: var(--text);
            text-align: center;
        }

        .minimap-action-btn:hover {
            background: var(--accent);
            color: white;
        }

        /* DM PANEL */
        .dm-panel {
            width: 420px;
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s;
            box-shadow: -4px 0 24px rgba(0,0,0,0.4);
        }

        .dm-panel.open {
            transform: translateX(0);
        }

        .dm-header {
            position: sticky;
            top: 0;
            background: var(--bg-hover);
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .dm-header h2 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
        }

        .dm-content {
            padding: 1rem;
        }

        .section {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 2px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s;
        }

        .section.active {
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
            background: rgba(139, 92, 246, 0.05);
        }

        .section h3 {
            margin-bottom: 0.75rem;
            color: var(--gold);
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin: 0.75rem 0;
        }

        .tool-btn {
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .tool-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0.75rem 0;
        }

        .control-row label {
            min-width: 60px;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        input[type="color"] {
            width: 50px;
            height: 36px;
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            background: var(--bg-dark);
        }

        .grid-selector {
            background: var(--bg-dark);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border: 2px solid var(--border);
        }

        .grid-info {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .grid-info .current {
            color: var(--accent);
            font-weight: 600;
            font-size: 1.1rem;
        }

        .grid-nav {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.5rem;
        }

        #mapCanvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: white;
            cursor: crosshair;
            margin: 0.5rem 0;
        }

        .history-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .asset-indicator {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--text-dim);
            text-align: center;
            margin-top: 0.5rem;
        }

        .asset-indicator .current-asset {
            color: var(--accent);
            font-weight: 600;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .fog-groups {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin: 0.75rem 0;
        }

        .fog-group-item {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 0.75rem;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fog-group-item.active {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }

        .fog-group-name {
            font-weight: 600;
            color: var(--text);
        }

        .fog-group-controls {
            display: flex;
            gap: 0.5rem;
        }

        .pending-requests {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .request-item {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .request-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .request-name {
            font-weight: 600;
            color: var(--text);
        }

        .request-detail {
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .request-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }

        /* UTILITY */
        .hidden {
            display: none !important;
        }

        /* RESUME PROMPT */
        .resume-prompt {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            text-align: left;
        }
        .resume-prompt-title {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .resume-prompt-name {
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--gold);
            margin-bottom: 0.75rem;
        }
        .resume-buttons {
            display: flex;
            gap: 0.5rem;
        }
        .resume-btn {
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            border: none;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s;
        }
        .resume-btn-yes {
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            color: white;
        }
        .resume-btn-no {
            background: var(--bg-hover);
            color: var(--text-dim);
            border: 1px solid var(--border);
        }
        .resume-btn:hover { transform: translateY(-1px); }
        .welcome-divider {
            color: var(--text-dim);
            font-size: 0.8rem;
            margin: 1rem 0;
            position: relative;
        }
        .welcome-divider::before, .welcome-divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 80px;
            height: 1px;
            background: var(--border);
        }
        .welcome-divider::before { right: calc(50% + 1.5rem); }
        .welcome-divider::after { left: calc(50% + 1.5rem); }

        /* DICE ROLLER */
        .dice-roller-btn {
            position: fixed; bottom: 160px; right: calc(28% - 38px);
            width: 76px; height: 76px;
            background: linear-gradient(135deg, #9b2335, #6b0f1a);
            border: 2px solid #c8922a; border-radius: 50%;
            cursor: pointer; font-size: 2rem;
            display: none; align-items: center; justify-content: center; flex-direction: column;
            box-shadow: 0 4px 18px rgba(200,146,42,0.45);
            z-index: 8000; color: var(--gold); line-height: 1;
            transition: transform 0.15s, box-shadow 0.15s;
        }
        .dice-roller-btn.visible { display: flex; }
        .dice-roller-btn:hover { transform: scale(1.12); box-shadow: 0 6px 22px rgba(200,146,42,0.5); }
        .dice-roller-btn.rolling { animation: diceRollAnim 0.5s ease-out; }
        @keyframes diceRollAnim {
            0%   { transform: rotate(0deg) scale(1); }
            25%  { transform: rotate(120deg) scale(1.2); }
            50%  { transform: rotate(240deg) scale(0.9); }
            75%  { transform: rotate(320deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }
        .dice-roll-log {
            position: fixed; bottom: 248px; right: calc(28% - 100px);
            width: 200px; display: none; flex-direction: column-reverse;
            gap: 0.3rem; z-index: 7999; max-height: 220px; overflow: hidden; pointer-events: none;
        }
        .dice-roll-log.visible { display: flex; }
        .dice-log-entry {
            background: rgba(18,23,42,0.96); border: 1px solid var(--border);
            border-radius: 8px; padding: 0.35rem 0.6rem; font-size: 0.78rem;
            display: flex; justify-content: space-between; align-items: center;
            animation: slideRight 0.3s ease-out;
        }
        @keyframes slideRight { from { transform: translateX(110%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .dice-log-num { font-size: 1.1rem; font-weight: 700; color: var(--accent); }
        .dice-log-num.nat20 { color: #fbbf24; }
        .dice-log-num.nat1  { color: #ef4444; }
        .dice-result-toast {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #12172a, #1e2440);
            border: 2px solid var(--accent); border-radius: 20px;
            padding: 1.75rem 2.5rem; text-align: center;
            z-index: 15000; pointer-events: none;
            transition: transform 0.25s cubic-bezier(0.34,1.56,0.64,1), opacity 0.2s;
            opacity: 0; min-width: 190px;
        }
        .dice-result-toast.show { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        .toast-roller { font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.4rem; }
        .toast-num { font-family: 'Cinzel', serif; font-size: 4rem; font-weight: 700; color: var(--accent); line-height: 1; }
        .toast-num.nat20 { color: #fbbf24; text-shadow: 0 0 24px rgba(251,191,36,0.7); }
        .toast-num.nat1  { color: #ef4444; text-shadow: 0 0 24px rgba(239,68,68,0.5); }
        .toast-label { font-size: 0.75rem; color: var(--text-dim); margin-top: 0.3rem; letter-spacing: 0.05em; }
        .toast-bonus { font-size: 1.1rem; color: var(--text-dim); margin-top: 0.2rem; }

        /* DICE ADVANTAGE PANEL */
        .dice-advantage-panel {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-bottom: none;
            border-radius: 12px 12px 0 0;
            z-index: 7600;
            max-width: 820px;
            width: calc(100vw - 40px);
            box-shadow: 0 -4px 20px rgba(0,0,0,0.5);
            display: none;
        }
        .dice-advantage-panel.panel-visible { display: block; }
        .dice-advantage-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.45rem 1rem;
            cursor: pointer;
            user-select: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }
        .dice-advantage-header.open { border-bottom-color: var(--border); }
        .dice-advantage-header h4 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .dice-advantage-body {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.6rem 0.85rem 0.75rem;
        }
        .dice-advantage-body.open { display: flex; }
        .advantage-chars-row {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
            align-items: center;
        }
        .advantage-chars-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.06em;
            margin-right: 0.25rem;
        }
        .advantage-char-btn {
            padding: 0.25rem 0.65rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            color: var(--text-dim);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.78rem;
            font-family: 'Cinzel', serif;
            transition: all 0.15s;
        }
        .advantage-char-btn:hover { border-color: var(--accent); color: var(--accent); }
        .advantage-char-btn.active {
            background: rgba(200,146,42,0.15);
            border-color: var(--accent);
            color: var(--accent);
        }
        .advantage-skills-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
        }
        .advantage-skill-btn {
            padding: 0.35rem 0.9rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-weight: 600;
            transition: all 0.15s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px;
            min-width: 64px;
        }
        .advantage-skill-btn:hover { border-color: var(--accent); background: var(--bg-hover); }
        .advantage-skill-btn.selected {
            background: var(--crimson);
            border-color: #c8394e;
            color: white;
        }
        .advantage-skill-btn .adv-attr { font-size: 0.6rem; opacity: 0.75; text-transform: uppercase; letter-spacing: 0.07em; }
        .advantage-skill-btn .adv-mod { font-size: 1rem; font-weight: 700; color: var(--accent); }
        .advantage-skill-btn.selected .adv-mod { color: white; }
        .advantage-clear-btn {
            padding: 0.25rem 0.6rem;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-dim);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.72rem;
            transition: all 0.15s;
            margin-left: auto;
        }
        .advantage-clear-btn:hover { border-color: var(--danger); color: var(--danger); }

        /* FEATURES TAB */
        .class-intro { background: linear-gradient(135deg, var(--bg-card), var(--bg-dark)); border: 1px solid var(--border); border-radius: 12px; padding: 1rem 1.1rem; margin-bottom: 1rem; }
        .class-intro-name { font-family: 'Cinzel', serif; font-size: 1.1rem; color: var(--gold); margin-bottom: 0.3rem; }
        .class-intro-desc { font-size: 0.85rem; color: var(--text-dim); line-height: 1.5; }
        .feature-card { background: var(--bg-dark); border: 1px solid var(--border); border-radius: 10px; padding: 0.8rem 1rem; margin-bottom: 0.55rem; border-left: 3px solid var(--accent); }
        .feature-card-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem; flex-wrap: wrap; }
        .feature-lvl-badge { background: var(--accent); color: white; font-size: 0.62rem; padding: 0.12rem 0.4rem; border-radius: 8px; white-space: nowrap; font-weight: 700; opacity: 0.9; }
        .feature-name { font-weight: 700; font-size: 0.9rem; flex: 1; }
        .feature-blurb { font-size: 0.82rem; color: var(--text-dim); line-height: 1.55; }
        .feature-choice { margin-top: 0.5rem; display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
        .feature-choice label { font-size: 0.75rem; color: var(--text-dim); white-space: nowrap; }
        .feature-choice select { background: var(--bg-card); border: 1px solid var(--accent); color: var(--text); border-radius: 5px; padding: 0.2rem 0.45rem; font-size: 0.8rem; cursor: pointer; }

        /* CHARACTER SHEET OVERLAY */
        .char-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f3a 100%);
            z-index: 20000;
            display: none;
            overflow-y: auto;
        }
        .char-overlay.active { display: block; }
        .char-header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .char-header h1 {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .char-body {
            max-width: 900px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        .char-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 2px;
            padding: 1.25rem;
            margin-bottom: 1rem;
        }
        .char-section h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            margin-bottom: 1rem;
            font-size: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }
        .char-grid-6 {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.75rem;
        }
        .char-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
        }
        .char-grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        .ability-block {
            background: var(--bg-hover);
            border: 2px solid var(--border);
            border-radius: 2px;
            padding: 0.75rem;
            text-align: center;
            transition: border-color 0.2s;
        }
        .ability-block:hover { border-color: var(--gold); box-shadow: 0 0 12px rgba(245,197,24,0.2); }
        .ability-name {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
        }
        .ability-score {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text);
            line-height: 1.2;
        }
        .ability-score input {
            width: 100%;
            font-size: 2rem;
            font-weight: 700;
            color: var(--text);
            background: transparent;
            border: none;
            text-align: center;
            font-family: 'Inter', sans-serif;
            outline: none;
        }
        .ability-mod {
            font-size: 1.1rem;
            color: var(--accent);
            font-weight: 700;
        }
        .stat-block {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 2px;
            padding: 0.75rem;
            text-align: center;
        }
        .stat-block label {
            display: block;
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }
        .stat-block input {
            width: 100%;
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text);
            background: transparent;
            border: none;
            text-align: center;
            font-family: 'Inter', sans-serif;
            outline: none;
        }
        .char-input {
            width: 100%;
            padding: 0.6rem 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 2px;
            color: var(--text);
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }
        .char-input:focus { outline: none; border-color: var(--accent); }
        .char-label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 0.35rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .skill-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.4rem;
        }
        .skill-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem;
            border-radius: 5px;
            transition: background 0.15s;
        }
        .skill-item:hover { background: var(--bg-hover); }
        .skill-item input[type="checkbox"] { accent-color: var(--accent); width: 14px; height: 14px; }
        .skill-item .skill-mod {
            font-size: 0.75rem;
            color: var(--accent);
            font-weight: 700;
            min-width: 28px;
        }
        .skill-item .skill-name { font-size: 0.8rem; color: var(--text); }
        .skill-item .skill-attr { font-size: 0.7rem; color: var(--text-dim); }
        .hp-track {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .hp-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: var(--bg-hover);
            color: var(--text);
            cursor: pointer;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .hp-btn:hover { background: var(--accent); border-color: var(--accent); }
        .char-list-panel {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .char-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 0.75rem;
            background: var(--bg-dark);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .char-list-item:hover { border-color: var(--accent); }
        .char-list-item.active { border-color: var(--gold); background: rgba(251,191,36,0.05); }
        .char-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.75rem;
        }
        .char-tab {
            padding: 0.4rem 1rem;
            border-radius: 2px 2px 0 0;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 700;
            border: 1px solid transparent;
            transition: all 0.2s;
            color: var(--text-dim);
            font-family: 'Cinzel', serif;
            letter-spacing: 0.04em;
        }
        .char-tab.active { background: var(--accent); color: var(--bg-dark); border-color: var(--accent); }
        .char-tab-content { display: none; }
        .char-tab-content.active { display: block; }
        .death-saves {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .death-save-pip {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.15s;
        }
        .death-save-pip.success.filled { background: var(--success); border-color: var(--success); }
        .death-save-pip.failure.filled { background: var(--danger); border-color: var(--danger); }
        .notes-textarea {
            width: 100%;
            min-height: 120px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            padding: 0.75rem;
            resize: vertical;
        }
        .notes-textarea:focus { outline: none; border-color: var(--accent); }

        /* EXHAUSTION PIPS */
        .exhaustion-pip {
            width: 26px; height: 26px;
            border: 2px solid var(--border);
            border-radius: 2px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.7rem; font-weight: 700; font-family: 'Cinzel', serif;
            color: var(--text-dim);
            transition: all 0.15s;
        }
        .exhaustion-pip:hover { border-color: var(--danger); color: var(--danger); }
        .exhaustion-pip.active { background: var(--danger); border-color: var(--danger); color: white; }

        /* CONDITIONS */
        .condition-tag {
            padding: 3px 8px;
            border-radius: 2px;
            border: 1px solid var(--border);
            font-size: 0.65rem;
            font-family: 'Cinzel', serif;
            cursor: pointer;
            transition: all 0.15s;
            color: var(--text-dim);
            user-select: none;
        }
        .condition-tag:hover { border-color: var(--danger); color: var(--danger); }
        .condition-tag.active { background: var(--danger); border-color: var(--danger); color: white; }

        /* ATTACK ROWS */
        .attack-row {
            display: grid;
            grid-template-columns: 2fr 1fr 2fr 1fr auto;
            gap: 0.4rem;
            align-items: center;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 2px;
            padding: 0.4rem;
        }
        .attack-row input {
            background: transparent;
            border: none;
            border-bottom: 1px solid var(--border);
            color: var(--text);
            font-size: 0.8rem;
            padding: 0.2rem 0.3rem;
            outline: none;
            width: 100%;
            font-family: 'Inter', sans-serif;
        }
        .attack-row input:focus { border-bottom-color: var(--accent); }
        .attack-row .atk-del {
            background: none; border: none; color: var(--danger);
            cursor: pointer; font-size: 1rem; padding: 0 0.3rem;
            transition: transform 0.15s;
        }
        .attack-row .atk-del:hover { transform: scale(1.2); }

        /* SPELL SLOT ROWS */
        .spell-slot-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 2px;
        }
        .spell-slot-label { font-size: 0.75rem; color: var(--gold); font-family: 'Cinzel', serif; min-width: 60px; }
        .spell-slot-pips { display: flex; gap: 4px; flex:1; }
        .ss-pip {
            width: 20px; height: 20px; border-radius: 2px;
            border: 2px solid var(--border);
            cursor: pointer; transition: all 0.15s;
        }
        .ss-pip.used { background: var(--bg-hover); border-color: var(--text-dim); }
        .ss-pip.available { background: var(--accent); border-color: var(--accent); box-shadow: 0 0 6px rgba(200,146,42,0.4); }
        .ss-pip:hover { transform: scale(1.15); }
        .spell-slot-max { display: flex; align-items: center; gap: 4px; font-size: 0.75rem; color: var(--text-dim); }
        .spell-slot-max input { width: 36px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 2px; color: var(--text); text-align: center; font-size: 0.75rem; padding: 2px; }

        /* MUSIC PLAYER */
        .music-panel {
            position: fixed;
            bottom: 20px;
            right: 220px;
            width: 300px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            z-index: 600;
            display: none;
            cursor: move;
            user-select: none;
        }
        .music-panel.visible { display: block; }
        .music-header {
            padding: 0.75rem 1rem;
            background: var(--bg-hover);
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }
        .music-header-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--gold);
        }
        .music-now-playing {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            color: var(--text-dim);
            border-bottom: 1px solid var(--border);
            min-height: 28px;
        }
        .music-now-playing .track-name { color: var(--accent); font-weight: 600; }
        .music-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            padding: 0.75rem;
        }
        .music-btn {
            padding: 0.6rem 0.5rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text);
            transition: all 0.2s;
            font-family: 'Inter', sans-serif;
        }
        .music-btn:hover { border-color: var(--accent); background: rgba(139,92,246,0.1); }
        .music-btn.playing { background: var(--accent); border-color: var(--accent); color: white; animation: pulse-glow 2s infinite; }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139,92,246,0.4); }
            50% { box-shadow: 0 0 0 6px rgba(139,92,246,0); }
        }
        .music-btn .music-emoji { font-size: 1.2rem; display: block; margin-bottom: 0.25rem; }
        .music-controls {
            padding: 0.5rem 0.75rem 0.75rem;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .music-vol {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            accent-color: var(--accent);
        }
        .music-stop-btn {
            padding: 0.35rem 0.75rem;
            background: var(--danger);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            transition: opacity 0.2s;
        }
        .music-stop-btn:hover { opacity: 0.8; }

        /* CO-DM BADGE */
        .user-role.co-dm { background: #f97316; }

        /* ===== SUB-MAP / LANDMARK MODALS ===== */
        .submap-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.88);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99998;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.3s;
        }
        .submap-modal.active {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }
        .submap-modal-content {
            background: var(--bg-card);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 1.5rem;
            max-width: 860px;
            width: 95%;
            max-height: 92vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.85), 0 0 40px rgba(200,146,42,0.18);
        }
        .submap-toolbar {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-dark);
            border-radius: 4px;
            border: 1px solid var(--border);
        }
        #subMapCanvas, #subMapViewerCanvas {
            border: 2px solid var(--border);
            cursor: crosshair;
            display: block;
            max-width: 100%;
            border-radius: 4px;
            background: #1a1f2e;
        }
        #subMapViewerCanvas { cursor: default; }
        .stamp-glow-hint {
            display: inline-block;
            font-size: 0.72rem;
            color: var(--gold);
            background: rgba(200,146,42,0.12);
            border: 1px solid rgba(200,146,42,0.3);
            border-radius: 4px;
            padding: 0.15rem 0.5rem;
            margin-top: 0.3rem;
        }
    </style>
</head>
<body>
    <!-- WELCOME SCREEN -->
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-content" style="max-width: 520px; width: 90%;">
            <div class="welcome-title">âš”ï¸ FROM SUNNYVILLE</div>
            <div class="welcome-subtitle">Ultimate Virtual Tabletop v4.0 FINAL</div>
            <div class="welcome-buttons" id="welcomeButtons" style="flex-wrap: wrap; gap: 0.75rem; justify-content: center;">
                <button class="welcome-btn welcome-btn-primary" onclick="showDMLogin()">ðŸŽ­ Create Room (DM)</button>
                <button class="welcome-btn" style="background:linear-gradient(135deg,#f97316,#ea580c);color:white;border:none;" onclick="showCoDMLogin()">ðŸ§™ Join as Co-DM</button>
                <button class="welcome-btn welcome-btn-secondary" onclick="showPlayerLogin()">ðŸ‘¤ Join Room (Player)</button>
                <button class="welcome-btn welcome-btn-secondary" onclick="showCharSheet()">ðŸ“œ My Characters</button>
            </div>
            <div id="welcomeReconnect" style="display:none; text-align:center;">
                <p id="welcomeReconnectMsg" style="color:var(--text-dim); margin-bottom:1rem; font-size:0.95rem;"></p>
                <div style="display:flex; gap:0.75rem; justify-content:center; flex-wrap:wrap;">
                    <button class="welcome-btn welcome-btn-secondary" onclick="cancelAutoReconnect()">âœ• Start Fresh Instead</button>
                </div>
            </div>
            <p style="position: absolute; bottom: 20px; width: 100%; text-align: center; font-size: 0.75rem; color: var(--text-dim);">
                v4.0 â€¢ Multi-DM â€¢ Character Sheets â€¢ Ambient Music
            </p>
        </div>
    </div>

    <!-- DM LOGIN MODAL -->
    <div class="modal" id="dmModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">ðŸ§™</div>
                <div class="modal-title">Dungeon Master</div>
            </div>
            <!-- First-time setup notice -->
            <div id="dmFirstTimeNotice" style="display:none; background:rgba(139,92,246,0.15); border:1px solid var(--accent); border-radius:8px; padding:0.65rem 0.75rem; margin-bottom:0.75rem; font-size:0.83rem; color:var(--text-dim);">
                ðŸ‘‹ First time? Create your DM username and password below â€” you'll use these every time you create a room.
            </div>
            <form onsubmit="dmLogin(event)">
                <div class="form-group">
                    <label>USERNAME</label>
                    <input type="text" id="dmUser" placeholder="Choose a username" required>
                </div>
                <div class="form-group">
                    <label>PASSWORD</label>
                    <input type="password" id="dmPass" placeholder="Choose a password" required>
                </div>
                <div class="form-group">
                    <label>SESSION ID (Optional - leave blank for new session)</label>
                    <input type="text" id="sessionId" placeholder="Paste previous session ID to rejoin">
                    <p style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.25rem;">ðŸ’¡ Save your session ID to rejoin this campaign later!</p>
                </div>
                <div class="error" id="dmError">Invalid credentials</div>
                <div class="info" id="dmInfo" style="display: none;">Rejoining previous session...</div>
                <button type="submit" class="btn btn-primary" style="width: 100%;" id="dmLoginBtn">LOGIN & CREATE ROOM</button>
                <button type="button" class="btn" onclick="closeDMModal()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
            </form>
            <!-- Change credentials section -->
            <div style="margin-top:1rem; border-top:1px solid var(--border); padding-top:0.75rem;">
                <button type="button" onclick="toggleDMSetup()" style="background:none;border:none;color:var(--text-dim);font-size:0.78rem;cursor:pointer;padding:0;text-decoration:underline;">âš™ï¸ Change DM credentials</button>
                <div id="dmSetupPanel" style="display:none; margin-top:0.75rem;">
                    <div class="form-group">
                        <label>NEW USERNAME</label>
                        <input type="text" id="dmNewUser" placeholder="New username">
                    </div>
                    <div class="form-group">
                        <label>NEW PASSWORD</label>
                        <input type="password" id="dmNewPass" placeholder="New password">
                    </div>
                    <div class="form-group">
                        <label>CONFIRM PASSWORD</label>
                        <input type="password" id="dmNewPassConfirm" placeholder="Repeat new password">
                    </div>
                    <div class="error" id="dmSetupError">Passwords do not match</div>
                    <div class="success" id="dmSetupSuccess" style="display:none; background:rgba(16,185,129,0.15); border:1px solid #10b981; border-radius:6px; padding:0.4rem 0.6rem; font-size:0.82rem; color:#10b981;">âœ“ Credentials saved!</div>
                    <button type="button" class="btn btn-primary" onclick="saveDMCredentials()" style="width:100%;">Save Credentials</button>
                </div>
            </div>
        </div>
    </div>

    <!-- PLAYER LOGIN MODAL -->
    <div class="modal" id="playerModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">ðŸ‘¤</div>
                <div class="modal-title">Join as Player</div>
            </div>
            <form onsubmit="playerLogin(event)">
                <div class="form-group">
                    <label>YOUR NAME</label>
                    <input type="text" id="playerName" placeholder="Enter character name" required>
                </div>
                <div class="form-group">
                    <label>ROOM CODE</label>
                    <input type="text" id="roomCodeInput" placeholder="Paste full room code" required>
                </div>
                <div class="error" id="playerError">Connection failed</div>
                <div class="success" id="playerSuccess">Request sent! Waiting for DM approval...</div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">REQUEST TO JOIN</button>
                <button type="button" class="btn" onclick="closePlayerModal()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <!-- TOKEN REQUEST MODAL (DM) -->
    <div class="modal" id="tokenRequestModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">ðŸŽ²</div>
                <div class="modal-title">Create Token</div>
            </div>
            <div class="form-group">
                <label>TOKEN TYPE</label>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <button class="btn btn-primary" onclick="setTokenType('emoji')" id="emojiTokenBtn" style="flex: 1;">Emoji</button>
                    <button class="btn" onclick="setTokenType('image')" id="imageTokenBtn" style="flex: 1;">Image</button>
                </div>
            </div>
            <div id="emojiTokenInputs">
                <div class="form-group">
                    <label>TOKEN EMOJI</label>
                    <input type="text" id="tokenEmoji" placeholder="âš”ï¸" maxlength="2">
                </div>
            </div>
            <div id="imageTokenInputs" style="display: none;">
                <div class="form-group">
                    <label>TOKEN IMAGE</label>
                    <input type="file" id="tokenImageFile" accept="image/*" style="width: 100%; padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text);">
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-dim);">Upload PNG, JPG, or GIF (will be resized to 60x60)</div>
                </div>
            </div>
            <div class="form-group">
                <label>ASSIGN TO PLAYER</label>
                <select id="tokenOwner" style="width:100%;padding:0.5rem;background:var(--bg-dark);border:1px solid var(--border);border-radius:6px;color:var(--text);">
                    <option value="DM">DM (unassigned)</option>
                </select>
            </div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="createToken()" style="flex: 1;">Create</button>
                <button class="btn" onclick="closeTokenModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- FOG GROUP MODAL -->
    <div class="modal" id="fogGroupModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">ðŸ‘¥</div>
                <div class="modal-title">Create Fog Group</div>
            </div>
            <div class="form-group">
                <label>GROUP NAME</label>
                <input type="text" id="fogGroupName" placeholder="e.g., Party A, Solo Explorer" required>
            </div>
            <div class="info">Players in this group will share fog visibility</div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="createFogGroup()" style="flex: 1;">Create Group</button>
                <button class="btn" onclick="closeFogGroupModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- CO-DM LOGIN MODAL -->
    <div class="modal" id="coDMModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">ðŸ§™</div>
                <div class="modal-title">Join as Co-DM</div>
            </div>
            <p style="font-size:0.85rem;color:var(--text-dim);margin-bottom:1rem;text-align:center;">
                Co-DMs can edit the map, move tokens, and paint fog alongside the host DM.
            </p>
            <form onsubmit="coDMLogin(event)">
                <div class="form-group">
                    <label>YOUR NAME</label>
                    <input type="text" id="coDMName" placeholder="Second DM" required>
                </div>
                <div class="form-group">
                    <label>ROOM CODE</label>
                    <input type="text" id="coDMRoomCode" placeholder="Paste host DM's room code" required>
                </div>
                <div class="form-group">
                    <label>DM PASSWORD</label>
                    <input type="password" id="coDMPass" placeholder="DM's password" required>
                </div>
                <div class="error" id="coDMError">Invalid password or connection failed</div>
                <button type="submit" class="btn btn-primary" style="width:100%;">JOIN AS CO-DM</button>
                <button type="button" class="btn" onclick="closeCoDMModal()" style="width:100%;margin-top:0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <!-- HEADER -->
    <div class="header">
        <div class="title">âš”ï¸ FROM SUNNYVILLE</div>
        <div class="campaign-badge" id="campaignBadge" style="display: none;">Campaign Name</div>
        <div class="header-actions">
            <div id="firebaseSection" style="display: none; align-items: center; gap: 0.4rem;">
                <span id="firebaseStatus" style="font-size: 0.75rem; color: var(--text-dim);"></span>
            </div>
            <button class="btn" id="musicToggleBtn" onclick="toggleMusicPanel()" style="display:none;" title="Jukebox">ðŸŽµ Music</button>
            <button class="btn" id="charSheetBtn" onclick="showCharSheet()" title="Character Sheet">ðŸ“œ Characters</button>
            <button class="btn" id="dmControlsBtn" onclick="toggleDMPanel()" style="display: none;">ðŸŽ­ DM Controls</button>
        </div>
    </div>

    <!-- CONNECTION TAB -->
    <div class="connection-tab-container" id="connectionTabContainer">
        <div class="connection-tab" onclick="toggleConnectionPanel()" id="connectionTab">
            <div class="connection-indicator" id="tabIndicator"></div>
            <span id="tabText">Connection</span>
            <span id="tabArrow">â–¼</span>
        </div>
    </div>

    <!-- DICE ROLLER -->
    <div class="dice-roll-log" id="diceRollLog"></div>
    <button class="dice-roller-btn" id="diceRollerBtn" onclick="rollD20()" title="Roll d20 â€” everyone sees it">
        ðŸŽ²<span style="font-size:0.5rem;margin-top:2px;opacity:0.85;">d20</span>
    </button>
    <div class="dice-result-toast" id="diceToast">
        <div class="toast-roller" id="toastRoller"></div>
        <div class="toast-num" id="toastNum">â€”</div>
        <div class="toast-label">d20</div>
    </div>

    <!-- CONNECTION PANEL -->
    <div class="connection-panel" id="connectionPanel">
        <div class="connection-content">
            <div class="connection-section" id="roomCodeSection" style="display: none;">
                <h3>ðŸŽ­ Room Code</h3>
                <p style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Share this code with players:</p>
                <div class="room-code" id="roomCode" onclick="copyRoomCode()" style="user-select: text; cursor: pointer;" title="Click to copy">----</div>
                <p style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem; text-align: center;">
                    ðŸ’¡ Click to copy â€¢ Or select text manually (Ctrl+C)
                </p>
            </div>
            <div class="connection-section">
                <h3>ðŸ“¡ Status</h3>
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                    <div class="connection-indicator" id="statusIndicator"></div>
                    <span id="statusText">Disconnected</span>
                </div>
                <button id="startFreshBtn" onclick="confirmLeaveSession()" style="display:none; margin-top:0.6rem; width:100%; padding:0.45rem 0.75rem; background:#6b7280; color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:0.85rem;">âœ• Start Fresh / Change Session</button>
            </div>
            <div class="connection-section" id="firebaseStatusSection" style="display: none;">
                <h3>ðŸ”¥ Cloud Sync</h3>
                <div style="padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                    <span id="firebaseStatusPanel" style="font-size: 0.85rem; color: var(--text-dim);">Connecting...</span>
                </div>
            </div>
            <div class="connection-section">
                <h3>ðŸ‘¥ Connected Users</h3>
                <div class="user-list" id="userList">
                    <p style="font-size: 0.85rem; color: var(--text-dim);">No users</p>
                </div>
            </div>
            <div class="connection-section">
                <button onclick="confirmLeaveSession()" style="width:100%; padding:0.55rem 0.75rem; background:#dc2626; color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:0.9rem; font-weight:600; letter-spacing:0.03em;">ðŸšª Leave Session</button>
            </div>
        </div>
    </div>
    <!-- Hidden stub so clearDMSession/clearPlayerSession never throw on missing element -->
    <div id="resumeArea" style="display:none;"></div>

    <!-- LEAVE SESSION CONFIRM MODAL (DM only) -->
    <div class="modal" id="leaveConfirmModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">ðŸ—ºï¸</div>
                <div class="modal-title">Save Before Leaving?</div>
            </div>
            <p style="text-align:center; color:var(--text-dim); margin-bottom:1.5rem; font-size:0.95rem;">
                Save the current map to a JSON file before leaving the session?
            </p>
            <div style="display:flex; flex-direction:column; gap:0.6rem;">
                <button onclick="saveAndLeaveSession()" style="padding:0.65rem 1rem; background:#10b981; color:#fff; border:none; border-radius:8px; cursor:pointer; font-size:0.95rem; font-weight:600;">ðŸ’¾ Save Map &amp; Leave</button>
                <button onclick="closeLeaveConfirmModal(); cancelAutoReconnect();" style="padding:0.65rem 1rem; background:#dc2626; color:#fff; border:none; border-radius:8px; cursor:pointer; font-size:0.95rem; font-weight:600;">ðŸšª Leave Without Saving</button>
                <button onclick="closeLeaveConfirmModal()" style="padding:0.65rem 1rem; background:#4b5563; color:#fff; border:none; border-radius:8px; cursor:pointer; font-size:0.95rem;">âœ• Cancel</button>
            </div>
        </div>
    </div>

    <!-- MAIN CONTAINER -->
    <div class="container">
        <div class="main-area">
            <div class="tabletop">
                <div class="tabletop-header">
                    <div style="display:flex;align-items:center;gap:0.5rem;">
                        <div class="session-name" id="sessionNameDisplay">Session</div>
                        <button id="editCampaignBtn" onclick="editCampaignName()" style="display:none;background:none;border:none;cursor:pointer;font-size:0.85rem;opacity:0.55;padding:0.15rem 0.3rem;line-height:1;" title="Rename campaign">âœï¸</button>
                    </div>
                    <div class="zoom-controls">
                        <span style="font-size: 0.9rem; color: var(--text-dim);">Zoom:</span>
                        <input type="range" class="slider" id="zoomSlider" min="25" max="200" value="100" oninput="setZoom(this.value)">
                        <span id="zoomValue" style="min-width: 50px; font-size: 0.9rem;">100%</span>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                    
                    <!-- TOKEN STAGING ZONE -->
                    <div class="staging-zone" id="stagingZone" style="display: none;">
                        <div class="staging-label">ðŸŽ² TOKENS</div>
                        <div class="staging-tokens" id="stagingTokens"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DM PANEL -->
        <div class="dm-panel" id="dmPanel">
            <div class="dm-header">
                <h2>ðŸŽ­ DM Controls</h2>
                <button class="btn btn-small" onclick="toggleDMPanel()">âœ•</button>
            </div>
            <div class="dm-content">
                <!-- PLAYER REQUESTS â€” always at top so DM cannot miss them -->
                <div class="section" id="requestsSection">
                    <h3>ðŸ“¬ Player Requests</h3>
                    <div class="pending-requests" id="pendingRequests">
                        <p style="font-size: 0.85rem; color: var(--text-dim);">No pending requests</p>
                    </div>
                </div>

                <!-- CAMPAIGN MANAGER -->
                <div class="section" id="campaignSection">
                    <h3>ðŸ’¾ Campaign Manager</h3>

                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Export/Import Campaign:</div>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="exportCampaign()" style="flex: 1;">ðŸ“¥ Export .JSON</button>
                            <button class="btn" onclick="document.getElementById('importFile').click()" style="flex: 1;">ðŸ“¤ Import .JSON</button>
                        </div>
                        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importCampaign(event)">
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Cloud Campaign Link (Google Drive, Dropbox, etc.):</div>
                        <input type="text" id="cloudLink" placeholder="Paste shareable link here" style="width: 100%; padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 0.85rem; margin-bottom: 0.5rem;">
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="saveCloudLink()" style="flex: 1;">ðŸ’¾ Save Link</button>
                            <button class="btn" onclick="openCloudLink()" style="flex: 1;">ðŸ”— Open Link</button>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                            ðŸ’¡ Upload exported .json to Google Drive â†’ Get shareable link â†’ Paste here â†’ Save<br>
                            Other DMs can use this link to access the campaign!
                        </div>
                    </div>

                    <div class="success" id="exportSuccess">Campaign exported!</div>
                    <div class="success" id="importSuccess">Campaign imported!</div>
                    <div class="success" id="linkSuccess">Cloud link saved!</div>
                    <div class="error" id="importError">Import failed. Check file format.</div>
                </div>

                <!-- MAP BUILDER -->
                <div class="section active" id="mapSection">
                    <h3>ðŸ—ºï¸ Map Builder</h3>
                    
                    <div class="grid-selector">
                        <div class="grid-info">
                            Cell: <span class="current" id="currentCell">Center</span>
                        </div>
                        <div class="grid-nav">
                            <button class="btn btn-small" onclick="selectCell(0,0)">â†–</button>
                            <button class="btn btn-small" onclick="selectCell(1,0)">â†‘</button>
                            <button class="btn btn-small" onclick="selectCell(2,0)">â†—</button>
                            <button class="btn btn-small" onclick="selectCell(0,1)">â†</button>
                            <button class="btn btn-small" onclick="selectCell(1,1)">â—</button>
                            <button class="btn btn-small" onclick="selectCell(2,1)">â†’</button>
                            <button class="btn btn-small" onclick="selectCell(0,2)">â†™</button>
                            <button class="btn btn-small" onclick="selectCell(1,2)">â†“</button>
                            <button class="btn btn-small" onclick="selectCell(2,2)">â†˜</button>
                        </div>
                    </div>

                    <div class="history-controls">
                        <button class="btn btn-small" onclick="undo()" id="undoBtn" disabled>â†¶ Undo</button>
                        <button class="btn btn-small" onclick="redo()" id="redoBtn" disabled>â†· Redo</button>
                    </div>

                    <div class="tool-grid">
                        <div class="tool-btn active" onclick="setTool('brush')" id="brushBtn">ðŸ–Œï¸<br>Brush</div>
                        <div class="tool-btn" onclick="setTool('fill')" id="fillBtn">ðŸª£<br>Fill</div>
                        <div class="tool-btn" onclick="setTool('eraser')" id="eraserBtn">ðŸ§¹<br>Erase</div>
                        <div class="tool-btn" onclick="setTool('stamp')" id="stampBtn">ðŸ°<br>Stamp</div>
                        <div class="tool-btn" onclick="setTool('image')" id="imageBtn">ðŸ–¼ï¸<br>Image</div>
                        <div class="tool-btn" onclick="setTool('select')" id="selectBtn">ðŸ‘†<br>Select</div>
                    </div>

                    <div class="asset-indicator">
                        Active: <span class="current-asset" id="currentAsset">Brush</span>
                    </div>

                    <!-- STAMP LIBRARY -->
                    <div id="stampLibraryToggle" style="display: none; margin: 0.75rem 0;">
                        <button class="btn" onclick="toggleStampLibrary()" style="width: 100%;">ðŸ“š Open Stamp Library</button>
                    </div>

                    <!-- ERASER MODE TOGGLE -->
                    <div id="eraserOptions" style="display: none; margin: 0.75rem 0; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Eraser Mode:</div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-small btn-primary" onclick="setEraserMode('content')" id="eraseContentBtn" style="flex: 1;">Content Only</button>
                            <button class="btn btn-small" onclick="setEraserMode('all')" id="eraseAllBtn" style="flex: 1;">Everything</button>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem;" id="eraserModeDesc">
                            Erases drawn content without touching background
                        </div>
                    </div>

                    <div class="control-row">
                        <label>Color:</label>
                        <input type="color" id="colorPicker" value="#4a7c59" onchange="updateColor(this.value)">
                    </div>
                    <div class="control-row">
                        <label>Size:</label>
                        <input type="range" class="slider" id="sizeSlider" min="1" max="30" value="8" oninput="setSize(this.value)" style="flex: 1;">
                        <span id="sizeValue">8px</span>
                    </div>

                    <canvas id="mapCanvas" width="400" height="400"></canvas>

                    <div class="btn-group">
                        <input type="file" id="mapImport" accept="image/*" style="display: none;" onchange="importMapImage(event)">
                        <input type="file" id="imageImport" accept="image/*" style="display: none;" onchange="importImageToCanvas(event)">
                        <button class="btn" onclick="document.getElementById('imageImport').click()">ðŸ–¼ï¸ Place Image</button>
                        <button class="btn btn-primary" onclick="submitCell()">âœ“ Submit</button>
                        <button class="btn" onclick="clearMapCanvas()">Clear</button>
                    </div>
                    
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-dim); padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                        ðŸ’¡ <strong>Place Image:</strong> Upload images to main canvas - they can be moved, resized & rotated! Use Select tool (ðŸ‘†) to manipulate them.
                    </div>
                </div>

                <!-- FOG OF WAR -->
                <div class="section" id="fogSection">
                    <h3>ðŸŒ«ï¸ Fog of War</h3>
                    
                    <button class="btn btn-primary" onclick="toggleFogMode()" id="fogModeToggle" style="width: 100%; margin-bottom: 1rem; transition: all 0.3s;">
                        ðŸŒ«ï¸ Fog Paint Mode: OFF
                    </button>
                    
                    <div id="fogControls" style="opacity: 0.5; pointer-events: none; transition: all 0.3s;">
                        <div class="fog-groups" id="fogGroups">
                            <div class="fog-group-item active">
                                <span class="fog-group-name">Everyone</span>
                                <button class="btn btn-small btn-primary" onclick="setActiveFogGroup('everyone')">Active</button>
                            </div>
                        </div>

                        <button class="btn" onclick="showFogGroupModal()" style="width: 100%; margin-bottom: 0.75rem;">+ New Group</button>

                        <div style="margin-bottom: 0.75rem;">
                            <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Fog Paint Mode:</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <button class="btn btn-small btn-primary" onclick="setFogPaintMode('brush')" id="fogBrushBtn">ðŸ–Œï¸ Brush</button>
                                <button class="btn btn-small" onclick="setFogPaintMode('rect')" id="fogRectBtn">â–­ Rectangle</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Brush Size:</label>
                            <input type="range" class="slider" id="fogSize" min="20" max="150" value="60" oninput="updateFogSize(this.value)" style="flex: 1;">
                            <span id="fogSizeValue">60px</span>
                        </div>

                        <div class="control-row">
                            <label>
                                <input type="checkbox" id="revealMode" checked> Reveal Fog
                            </label>
                        </div>

                        <div class="btn-group">
                            <button class="btn" onclick="resetFog()">Reset All Fog</button>
                        </div>
                        
                        <div style="margin-top: 0.75rem; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; font-size: 0.75rem; color: var(--text-dim);">
                            ðŸ’¡ Hold Ctrl + Click on the map to paint fog
                        </div>
                    </div>
                </div>

                <!-- TOKENS -->
                <div class="section" id="tokenSection">
                    <h3>ðŸŽ² Tokens</h3>
                    
                    <div class="control-row">
                        <label>
                            <input type="checkbox" id="gridSnap" onchange="toggleGridSnap()" checked> Grid Snap (25px)
                        </label>
                    </div>

                    <button class="btn btn-primary" onclick="showTokenModal()" style="width: 100%;">+ Create Token</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MINIMAP NAVIGATOR -->
    <div class="minimap-container" id="minimapContainer">
        <div class="minimap" id="minimap">
            <div class="minimap-header">
                <div class="minimap-title">ðŸ—ºï¸ Navigator</div>
                <div class="minimap-controls">
                    <div class="minimap-btn" onclick="toggleMinimapCollapse()" title="Collapse">âˆ’</div>
                    <div class="minimap-btn" onclick="toggleMinimapDock()" title="Lock/Unlock" id="dockBtn">ðŸ”“</div>
                </div>
            </div>
            <div class="minimap-content">
                <div class="minimap-grid" id="minimapGrid"></div>
                <div class="minimap-actions">
                    <div class="minimap-action-btn" onclick="recenterView()">âŠ™ Center</div>
                    <div class="minimap-action-btn" onclick="resetZoom()">ðŸ” Reset</div>
                </div>
            </div>
        </div>
    </div>

    <!-- STAMP LIBRARY PANEL -->
    <div class="minimap-container" id="stampLibraryContainer" style="display: none; left: 220px; cursor: move;">
        <div class="minimap" id="stampLibraryPanel" style="width: 280px;">
            <div class="minimap-header">
                <div class="minimap-title">ðŸ“š Stamp Library</div>
                <div class="minimap-controls">
                    <div class="minimap-btn" onclick="toggleStampLibraryCollapse()" title="Collapse" id="stampCollapseBtn">âˆ’</div>
                    <div class="minimap-btn" onclick="toggleStampLibraryDock()" title="Lock/Unlock" id="stampDockBtn">ðŸ”“</div>
                    <div class="minimap-btn" onclick="closeStampLibrary()" title="Close">âœ•</div>
                </div>
            </div>
            <div class="minimap-content" id="stampLibraryContent">
                <!-- Nature & Terrain -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">ðŸŒ² Nature & Terrain</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('ðŸŒ²')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸŒ²</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸŒ³')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸŒ³</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸŒ´')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸŒ´</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸŒ¿')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸŒ¿</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸƒ')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸƒ</div>
                        <div class="tool-btn" onclick="selectStamp('â›°ï¸')" style="padding: 0.5rem; font-size: 1.5rem;">â›°ï¸</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ”ï¸')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ”ï¸</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ—»')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ—»</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸžï¸')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸžï¸</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸŒŠ')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸŒŠ</div>
                    </div>
                </div>
                
                <!-- Buildings & Structures -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">ðŸ° Buildings</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('ðŸ°')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ°</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ›ï¸')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ›ï¸</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ•Œ')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ•Œ</div>
                        <div class="tool-btn" onclick="selectStamp('â›ª')" style="padding: 0.5rem; font-size: 1.5rem;">â›ª</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸšï¸')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸšï¸</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ ')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ </div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ¡')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ¡</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ˜ï¸')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ˜ï¸</div>
                        <div class="tool-btn" onclick="selectStamp('â›º')" style="padding: 0.5rem; font-size: 1.5rem;">â›º</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ—¿')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ—¿</div>
                    </div>
                </div>
                
                <!-- Items & Objects -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">âš”ï¸ Items</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('âš”ï¸')" style="padding: 0.5rem; font-size: 1.5rem;">âš”ï¸</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ—¡ï¸')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ—¡ï¸</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ›¡ï¸')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ›¡ï¸</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ¹')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ¹</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸª“')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸª“</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ”¥')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ”¥</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ’Ž')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ’Ž</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ‘‘')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ‘‘</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ“œ')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ“œ</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸª™')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸª™</div>
                    </div>
                </div>
                
                <!-- Creatures & Monsters -->
                <div>
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">ðŸ‰ Creatures</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('ðŸ‰')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ‰</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ§™')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ§™</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ§›')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ§›</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ§Ÿ')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ§Ÿ</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ‘»')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ‘»</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ¦‡')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ¦‡</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ•·ï¸')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ•·ï¸</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸº')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸº</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ¦…')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ¦…</div>
                        <div class="tool-btn" onclick="selectStamp('ðŸ')" style="padding: 0.5rem; font-size: 1.5rem;">ðŸ</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- PLAYER PANEL (Dockable) -->
    <div class="minimap-container" id="playerPanelContainer" style="display: none; right: 20px; bottom: 20px; left: auto; cursor: move;">
        <div class="minimap" id="playerPanelDock" style="width: 240px;">
            <div class="minimap-header">
                <div class="minimap-title">ðŸ‘¤ Player Actions</div>
                <div class="minimap-controls">
                    <div class="minimap-btn" onclick="togglePlayerPanelCollapse()" title="Collapse" id="playerCollapseBtn">âˆ’</div>
                    <div class="minimap-btn" onclick="togglePlayerPanelDock()" title="Lock/Unlock" id="playerDockBtn">ðŸ”“</div>
                </div>
            </div>
            <div class="minimap-content" id="playerPanelContent">
                <button class="btn btn-primary" onclick="showPlayerTokenModal()" style="width: 100%; margin-bottom: 0.75rem;">+ Create My Token</button>
                
                <div style="padding-top: 0.75rem; border-top: 1px solid var(--border);">
                    <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">My Token Size:</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <button class="btn btn-small" onclick="adjustPlayerTokenSize(-2)" style="flex: 0;">âˆ’</button>
                        <input type="range" class="slider" id="playerTokenSize" min="8" max="30" value="12" oninput="updatePlayerTokenSize(this.value)" style="flex: 1;">
                        <button class="btn btn-small" onclick="adjustPlayerTokenSize(2)" style="flex: 0;">+</button>
                    </div>
                    <div style="text-align: center; font-size: 0.75rem; color: var(--text-dim); margin-top: 0.25rem;">
                        Size: <span id="playerTokenSizeValue">12</span>px
                    </div>
                    <div style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.5rem; text-align: center;">
                        ðŸ’¡ 12px fits perfectly in one grid square
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- PLAYER TOKEN MODAL -->
    <div class="modal" id="playerTokenModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">ðŸŽ²</div>
                <div class="modal-title">Request Token</div>
            </div>
            <div class="form-group">
                <label>TOKEN TYPE</label>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <button class="btn btn-primary" onclick="setPlayerTokenType('emoji')" id="playerEmojiTokenBtn" style="flex: 1;">Emoji</button>
                    <button class="btn" onclick="setPlayerTokenType('image')" id="playerImageTokenBtn" style="flex: 1;">Image</button>
                </div>
            </div>
            <div id="playerEmojiTokenInputs">
                <div class="form-group">
                    <label>TOKEN EMOJI</label>
                    <input type="text" id="playerTokenEmoji" placeholder="âš”ï¸" maxlength="2">
                </div>
            </div>
            <div id="playerImageTokenInputs" style="display: none;">
                <div class="form-group">
                    <label>TOKEN IMAGE</label>
                    <input type="file" id="playerTokenImageFile" accept="image/*" style="width: 100%; padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text);">
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-dim);">Upload PNG, JPG, or GIF</div>
                </div>
            </div>
            <div class="info">Your token will be sent to the DM for approval</div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="requestPlayerToken()" style="flex: 1;">Request Token</button>
                <button class="btn" onclick="closePlayerTokenModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- MUSIC PLAYER PANEL -->
    <div class="music-panel" id="musicPanel">
        <div class="music-header">
            <span class="music-header-title">ðŸŽµ Jukebox</span>
            <div style="display:flex;gap:0.25rem;align-items:center;">
                <span id="musicBroadcastIcon" title="Broadcasting to players" style="font-size:0.8rem;display:none;">ðŸ“¡</span>
                <div class="minimap-btn" onclick="toggleMusicPanel()" title="Close">âœ•</div>
            </div>
        </div>
        <div class="music-now-playing" id="musicNowPlaying">Nothing playing</div>
        <div class="music-grid" id="musicGrid">
            <!-- filled by JS -->
        </div>
        <div class="music-controls">
            <span style="font-size:0.75rem;color:var(--text-dim);">Vol</span>
            <input type="range" class="music-vol" id="musicVolume" min="0" max="100" value="70" oninput="setMusicVolume(this.value)">
            <label style="font-size:0.7rem;color:var(--text-dim);display:flex;align-items:center;gap:0.25rem;">
                <input type="checkbox" id="musicBroadcast" checked style="accent-color:var(--accent);"> Broadcast
            </label>
            <button class="music-stop-btn" onclick="stopMusic()">â–  Stop</button>
        </div>
        <audio id="musicAudio" loop></audio>
    </div>

    <!-- CHARACTER SHEET OVERLAY -->
    <div class="char-overlay" id="charOverlay">
        <div class="char-header">
            <h1>ðŸ“œ Characters</h1>
            <div style="display:flex;gap:0.5rem;align-items:center;">
                <button class="btn btn-primary btn-small" onclick="saveCharacter()">ðŸ’¾ Save</button>
                <button class="btn btn-small" onclick="newCharacter()">+ New</button>
                <button class="btn btn-small" onclick="closeCharSheet()">âœ• Close</button>
            </div>
        </div>
        <div class="char-body">
            <!-- Character List -->
            <div class="char-list-panel">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;">
                    <span style="font-size:0.85rem;color:var(--gold);font-weight:600;font-family:'Cinzel',serif;">Your Characters</span>
                    <button class="btn btn-small btn-danger" onclick="deleteCharacter()" id="deleteCharBtn" style="display:none;">ðŸ—‘ Delete</button>
                </div>
                <div id="charListEl"><p style="font-size:0.85rem;color:var(--text-dim);">No characters yet. Click "+ New" to create one.</p></div>
            </div>

            <!-- Character Editor -->
            <div id="charEditor" style="display:none;">
                <!-- TABS -->
                <div class="char-tabs">
                    <div class="char-tab active" onclick="switchCharTab('basics')">âš”ï¸ Basics</div>
                    <div class="char-tab" onclick="switchCharTab('abilities')">ðŸ’ª Abilities</div>
                    <div class="char-tab" onclick="switchCharTab('combat')">ðŸ›¡ï¸ Combat</div>
                    <div class="char-tab" onclick="switchCharTab('skills')">ðŸŽ² Skills</div>
                    <div class="char-tab" onclick="switchCharTab('spells')">âœ¨ Spells</div>
                    <div class="char-tab" onclick="switchCharTab('equipment')">ðŸŽ’ Equipment</div>
                    <div class="char-tab" onclick="switchCharTab('notes')">ðŸ“ Notes</div>
                    <div class="char-tab" onclick="switchCharTab('features')">ðŸ“– Features</div>
                </div>

                <!-- BASICS TAB -->
                <div class="char-tab-content active" id="tabBasics">
                    <div class="char-section">
                        <h3>Identity</h3>
                        <div class="char-grid-2" style="margin-bottom:0.75rem;">
                            <div><label class="char-label">Character Name</label><input class="char-input" id="cName" placeholder="Thorin Oakenshield"></div>
                            <div><label class="char-label">Player Name</label><input class="char-input" id="cPlayer" placeholder="Your name"></div>
                        </div>
                        <div style="display:grid;grid-template-columns:2fr 1fr 1fr 1fr;gap:0.75rem;margin-bottom:0.75rem;">
                            <div><label class="char-label">Class (& Subclass)</label>
                                <select class="char-input" id="cClass" onchange="updateProfBonus();updateSpellcastingAbility()">
                                    <option>Artificer</option><option>Barbarian</option><option>Bard</option><option>Cleric</option>
                                    <option>Druid</option><option selected>Fighter</option><option>Monk</option>
                                    <option>Paladin</option><option>Ranger</option><option>Rogue</option>
                                    <option>Sorcerer</option><option>Warlock</option><option>Wizard</option>
                                </select>
                            </div>
                            <div><label class="char-label">Level</label><input class="char-input" id="cLevel" type="number" min="1" max="20" value="1" oninput="updateProfBonus();updateSpellcastingAbility()"></div>
                            <div><label class="char-label">Prof Bonus</label><input class="char-input" id="cProfBonus" readonly style="background:var(--bg-card);color:var(--accent);font-weight:700;text-align:center;"></div>
                            <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
                                <label class="char-label" style="margin-bottom:0.5rem;">Inspiration</label>
                                <input type="checkbox" id="cInspiration" style="width:24px;height:24px;accent-color:var(--gold);cursor:pointer;" title="Inspiration">
                            </div>
                        </div>
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:0.75rem;margin-bottom:0.75rem;">
                            <div><label class="char-label">Race</label><input class="char-input" id="cRace" placeholder="Human"></div>
                            <div><label class="char-label">Background</label><input class="char-input" id="cBackground" placeholder="Soldier"></div>
                            <div><label class="char-label">Alignment</label>
                                <select class="char-input" id="cAlignment">
                                    <option>Lawful Good</option><option>Neutral Good</option><option>Chaotic Good</option>
                                    <option>Lawful Neutral</option><option>True Neutral</option><option>Chaotic Neutral</option>
                                    <option>Lawful Evil</option><option>Neutral Evil</option><option>Chaotic Evil</option>
                                </select>
                            </div>
                            <div><label class="char-label">XP</label><input class="char-input" id="cXP" type="number" min="0" value="0" placeholder="0"></div>
                        </div>
                        <div class="char-grid-2">
                            <div><label class="char-label">Multiclass (optional)</label><input class="char-input" id="cMulticlass" placeholder="e.g. Rogue 3"></div>
                            <div><label class="char-label">Token / Portrait Emoji</label><input class="char-input" id="cEmoji" placeholder="ðŸ§™" maxlength="2" style="font-size:1.3rem;text-align:center;"></div>
                        </div>
                    </div>
                    <div class="char-section">
                        <h3>Exhaustion & Conditions</h3>
                        <div style="display:flex;gap:1rem;align-items:flex-start;flex-wrap:wrap;">
                            <div>
                                <label class="char-label">Exhaustion (0-6)</label>
                                <div style="display:flex;gap:4px;margin-top:0.4rem;">
                                    <div class="exhaustion-pip" data-level="1" onclick="toggleExhaustion(1)" title="Lv 1: Disadvantage on checks">1</div>
                                    <div class="exhaustion-pip" data-level="2" onclick="toggleExhaustion(2)" title="Lv 2: Speed halved">2</div>
                                    <div class="exhaustion-pip" data-level="3" onclick="toggleExhaustion(3)" title="Lv 3: Dis. on attacks & saves">3</div>
                                    <div class="exhaustion-pip" data-level="4" onclick="toggleExhaustion(4)" title="Lv 4: HP max halved">4</div>
                                    <div class="exhaustion-pip" data-level="5" onclick="toggleExhaustion(5)" title="Lv 5: Speed = 0">5</div>
                                    <div class="exhaustion-pip" data-level="6" onclick="toggleExhaustion(6)" title="Lv 6: Death">6</div>
                                </div>
                                <div id="exhaustionLabel" style="font-size:0.7rem;color:var(--text-dim);margin-top:0.3rem;">No exhaustion</div>
                            </div>
                            <div style="flex:1;">
                                <label class="char-label">Active Conditions</label>
                                <div id="conditionsGrid" style="display:flex;flex-wrap:wrap;gap:4px;margin-top:0.4rem;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="char-section">
                        <h3>Personality</h3>
                        <div class="char-grid-2">
                            <div><label class="char-label">Personality Trait</label><textarea class="notes-textarea" id="cPersonality" style="min-height:70px;" placeholder="I always tell the truth, even when it's not what people want to hear..."></textarea></div>
                            <div><label class="char-label">Ideal</label><textarea class="notes-textarea" id="cIdeal" style="min-height:70px;" placeholder="Greater Good. It is each person's responsibility to make the most good for the whole tribe..."></textarea></div>
                            <div><label class="char-label">Bond</label><textarea class="notes-textarea" id="cBond" style="min-height:70px;" placeholder="I would die for my village's freedom..."></textarea></div>
                            <div><label class="char-label">Flaw</label><textarea class="notes-textarea" id="cFlaw" style="min-height:70px;" placeholder="I'm too proud to admit when I'm wrong..."></textarea></div>
                        </div>
                    </div>
                    <div class="char-section">
                        <h3>Appearance & Backstory</h3>
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:0.75rem;margin-bottom:0.75rem;">
                            <div><label class="char-label">Age</label><input class="char-input" id="cAge" placeholder="35"></div>
                            <div><label class="char-label">Height</label><input class="char-input" id="cHeight" placeholder="6'2&quot;"></div>
                            <div><label class="char-label">Weight</label><input class="char-input" id="cWeight" placeholder="180 lbs"></div>
                            <div><label class="char-label">Eyes</label><input class="char-input" id="cEyes" placeholder="Blue"></div>
                        </div>
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:0.75rem;margin-bottom:0.75rem;">
                            <div><label class="char-label">Skin</label><input class="char-input" id="cSkin" placeholder="Tan"></div>
                            <div><label class="char-label">Hair</label><input class="char-input" id="cHair" placeholder="Dark brown"></div>
                            <div><label class="char-label">Distinguishing Marks</label><input class="char-input" id="cMarks" placeholder="Scar over left eye"></div>
                        </div>
                        <label class="char-label">Backstory</label>
                        <textarea class="notes-textarea" id="cBackstory" style="min-height:100px;" placeholder="Your character's backstory, origin, and motivations..."></textarea>
                    </div>
                </div>

                <!-- ABILITIES TAB -->
                <div class="char-tab-content" id="tabAbilities">
                    <div class="char-section">
                        <h3>Ability Scores</h3>
                        <div class="char-grid-6">
                            <div class="ability-block">
                                <div class="ability-name">STR</div>
                                <div class="ability-score"><input type="number" id="aSTR" value="10" min="1" max="30" oninput="updateAbilityMod('STR')"></div>
                                <div class="ability-mod" id="mSTR">+0</div>
                            </div>
                            <div class="ability-block">
                                <div class="ability-name">DEX</div>
                                <div class="ability-score"><input type="number" id="aDEX" value="10" min="1" max="30" oninput="updateAbilityMod('DEX')"></div>
                                <div class="ability-mod" id="mDEX">+0</div>
                            </div>
                            <div class="ability-block">
                                <div class="ability-name">CON</div>
                                <div class="ability-score"><input type="number" id="aCON" value="10" min="1" max="30" oninput="updateAbilityMod('CON')"></div>
                                <div class="ability-mod" id="mCON">+0</div>
                            </div>
                            <div class="ability-block">
                                <div class="ability-name">INT</div>
                                <div class="ability-score"><input type="number" id="aINT" value="10" min="1" max="30" oninput="updateAbilityMod('INT')"></div>
                                <div class="ability-mod" id="mINT">+0</div>
                            </div>
                            <div class="ability-block">
                                <div class="ability-name">WIS</div>
                                <div class="ability-score"><input type="number" id="aWIS" value="10" min="1" max="30" oninput="updateAbilityMod('WIS')"></div>
                                <div class="ability-mod" id="mWIS">+0</div>
                            </div>
                            <div class="ability-block">
                                <div class="ability-name">CHA</div>
                                <div class="ability-score"><input type="number" id="aCHA" value="10" min="1" max="30" oninput="updateAbilityMod('CHA')"></div>
                                <div class="ability-mod" id="mCHA">+0</div>
                            </div>
                        </div>
                        <div style="margin-top:0.75rem;padding:0.5rem 0.75rem;background:var(--bg-dark);border-radius:2px;font-size:0.75rem;color:var(--text-dim);">
                            ðŸ’¡ Roll 4d6 drop lowest (or use Standard Array: 15, 14, 13, 12, 10, 8) and assign to each ability.
                        </div>
                    </div>
                    <div class="char-section">
                        <h3>Saving Throws</h3>
                        <div class="skill-list" id="savingThrowList"></div>
                    </div>
                    <div class="char-section">
                        <h3>Languages & Proficiencies</h3>
                        <div class="char-grid-2">
                            <div><label class="char-label">Languages</label><textarea class="notes-textarea" id="cLanguages" style="min-height:60px;" placeholder="Common, Elvish, Dwarvish..."></textarea></div>
                            <div><label class="char-label">Tool / Weapon / Armor Proficiencies</label><textarea class="notes-textarea" id="cOtherProfs" style="min-height:60px;" placeholder="Smith's tools, longswords, heavy armor..."></textarea></div>
                        </div>
                    </div>
                </div>

                <!-- COMBAT TAB -->
                <div class="char-tab-content" id="tabCombat">
                    <div class="char-section">
                        <h3>Hit Points & Defenses</h3>
                        <div class="char-grid-3" style="margin-bottom:0.75rem;">
                            <div class="stat-block">
                                <label>Max HP</label>
                                <input type="number" id="cHPMax" value="10" min="0">
                            </div>
                            <div class="stat-block" style="border-color:var(--danger);">
                                <label style="color:var(--danger);">Current HP</label>
                                <div class="hp-track">
                                    <button class="hp-btn" onclick="changeHP(-1)">âˆ’</button>
                                    <input type="number" id="cHP" value="10" min="0" style="flex:1;">
                                    <button class="hp-btn" onclick="changeHP(1)">+</button>
                                </div>
                            </div>
                            <div class="stat-block">
                                <label>Temp HP</label>
                                <input type="number" id="cTempHP" value="0" min="0">
                            </div>
                        </div>
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr 1fr;gap:0.5rem;margin-bottom:0.75rem;">
                            <div class="stat-block"><label>AC</label><input type="number" id="cAC" value="10" min="0"></div>
                            <div class="stat-block"><label>Initiative</label><input type="number" id="cInit" value="0" readonly style="color:var(--accent);" title="DEX modifier"></div>
                            <div class="stat-block"><label>Speed</label><input type="number" id="cSpeed" value="30" min="0"></div>
                            <div class="stat-block"><label>Hit Dice</label><input type="text" id="cHitDice" value="1d10" style="font-size:0.9rem;text-align:center;width:100%;background:transparent;border:none;color:var(--text);outline:none;"></div>
                            <div class="stat-block"><label>Used HD</label><input type="number" id="cHitDiceUsed" value="0" min="0"></div>
                        </div>
                        <div style="display:flex;gap:0.75rem;align-items:center;margin-bottom:0.75rem;flex-wrap:wrap;">
                            <div>
                                <label class="char-label">Death Saves</label>
                                <div style="display:flex;gap:0.75rem;margin-top:0.4rem;">
                                    <div>
                                        <span style="font-size:0.7rem;color:var(--success);margin-right:0.3rem;">âœ“ Successes</span>
                                        <div class="death-saves">
                                            <div class="death-save-pip success" onclick="toggleDeathSave(this)"></div>
                                            <div class="death-save-pip success" onclick="toggleDeathSave(this)"></div>
                                            <div class="death-save-pip success" onclick="toggleDeathSave(this)"></div>
                                        </div>
                                    </div>
                                    <div>
                                        <span style="font-size:0.7rem;color:var(--danger);margin-right:0.3rem;">âœ— Failures</span>
                                        <div class="death-saves">
                                            <div class="death-save-pip failure" onclick="toggleDeathSave(this)"></div>
                                            <div class="death-save-pip failure" onclick="toggleDeathSave(this)"></div>
                                            <div class="death-save-pip failure" onclick="toggleDeathSave(this)"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div style="flex:1;">
                                <label class="char-label">Concentration (spell name)</label>
                                <input class="char-input" id="cConcentration" placeholder="e.g. Bless, Fog Cloud...">
                            </div>
                        </div>
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:0.75rem;">
                            <div><label class="char-label">Passive Perception</label><input class="char-input" id="cPassivePerception" readonly style="background:var(--bg-card);color:var(--accent);font-weight:700;text-align:center;"></div>
                            <div><label class="char-label">Passive Investigation</label><input class="char-input" id="cPassiveInvestigation" readonly style="background:var(--bg-card);color:var(--accent);font-weight:700;text-align:center;"></div>
                        </div>
                    </div>

                    <div class="char-section">
                        <h3>Attacks & Weapons</h3>
                        <div id="attacksList" style="display:flex;flex-direction:column;gap:0.5rem;margin-bottom:0.75rem;"></div>
                        <button class="btn btn-small" onclick="addAttack()" style="width:100%;">+ Add Attack / Weapon</button>
                    </div>

                    <div class="char-section">
                        <h3>Resistances, Immunities & Vulnerabilities</h3>
                        <div class="char-grid-3">
                            <div><label class="char-label">Damage Resistances</label><textarea class="notes-textarea" id="cResistances" style="min-height:60px;" placeholder="Fire, Poison..."></textarea></div>
                            <div><label class="char-label">Damage Immunities</label><textarea class="notes-textarea" id="cImmunities" style="min-height:60px;" placeholder="Psychic (Divination Wizard)..."></textarea></div>
                            <div><label class="char-label">Vulnerabilities</label><textarea class="notes-textarea" id="cVulnerabilities" style="min-height:60px;" placeholder="Fire (Yeti)..."></textarea></div>
                        </div>
                    </div>
                </div>

                <!-- SKILLS TAB -->
                <div class="char-tab-content" id="tabSkills">
                    <div class="char-section">
                        <h3>Skills</h3>
                        <div class="skill-list" id="skillListEl"></div>
                    </div>
                </div>

                <!-- SPELLS TAB -->
                <div class="char-tab-content" id="tabSpells">
                    <div class="char-section">
                        <h3>Spellcasting</h3>
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:0.75rem;margin-bottom:0.75rem;">
                            <div><label class="char-label">Spellcasting Class</label><input class="char-input" id="cSpellClass" placeholder="Wizard" readonly style="background:var(--bg-card);"></div>
                            <div><label class="char-label">Spellcasting Ability</label><input class="char-input" id="cSpellAbility" placeholder="INT" readonly style="background:var(--bg-card);color:var(--accent);font-weight:700;text-align:center;"></div>
                            <div><label class="char-label">Spell Save DC</label><input class="char-input" id="cSpellSaveDC" readonly style="background:var(--bg-card);color:var(--accent);font-weight:700;text-align:center;"></div>
                            <div><label class="char-label">Spell Attack Bonus</label><input class="char-input" id="cSpellAttackBonus" readonly style="background:var(--bg-card);color:var(--accent);font-weight:700;text-align:center;"></div>
                        </div>
                        <div style="padding:0.5rem 0.75rem;background:var(--bg-dark);border-radius:2px;font-size:0.75rem;color:var(--text-dim);">
                            Spell Save DC = 8 + Prof Bonus + Spellcasting Ability Modifier &nbsp;|&nbsp; Spell Attack = Prof Bonus + Spellcasting Ability Modifier
                        </div>
                    </div>

                    <div class="char-section">
                        <h3>Spell Slots</h3>
                        <div id="spellSlotsGrid" style="display:flex;flex-direction:column;gap:0.5rem;"></div>
                    </div>

                    <div class="char-section">
                        <h3>Cantrips (âˆž)</h3>
                        <textarea class="notes-textarea" id="cCantrips" style="min-height:70px;" placeholder="Fire Bolt, Mage Hand, Prestidigitation, Minor Illusion..."></textarea>
                    </div>

                    <div class="char-section">
                        <h3>Prepared / Known Spells</h3>
                        <textarea class="notes-textarea" id="cSpells" style="min-height:200px;" placeholder="Level 1: Magic Missile, Shield, Sleep, Thunderwave&#10;Level 2: Misty Step, Shatter&#10;Level 3: Fireball, Counterspell&#10;..."></textarea>
                    </div>
                </div>

                <!-- EQUIPMENT TAB -->
                <div class="char-tab-content" id="tabEquipment">
                    <div class="char-section">
                        <h3>Currency</h3>
                        <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:0.5rem;">
                            <div class="stat-block" style="border-color:#a97142;">
                                <label style="color:#a97142;">PP</label>
                                <input type="number" id="cPP" value="0" min="0">
                                <div style="font-size:0.6rem;color:var(--text-dim);">Platinum</div>
                            </div>
                            <div class="stat-block" style="border-color:var(--gold);">
                                <label style="color:var(--gold);">GP</label>
                                <input type="number" id="cGP" value="0" min="0">
                                <div style="font-size:0.6rem;color:var(--text-dim);">Gold</div>
                            </div>
                            <div class="stat-block" style="border-color:#7ec8e3;">
                                <label style="color:#7ec8e3;">EP</label>
                                <input type="number" id="cEP" value="0" min="0">
                                <div style="font-size:0.6rem;color:var(--text-dim);">Electrum</div>
                            </div>
                            <div class="stat-block" style="border-color:#c0c0c0;">
                                <label style="color:#c0c0c0;">SP</label>
                                <input type="number" id="cSP" value="0" min="0">
                                <div style="font-size:0.6rem;color:var(--text-dim);">Silver</div>
                            </div>
                            <div class="stat-block" style="border-color:#b87333;">
                                <label style="color:#b87333;">CP</label>
                                <input type="number" id="cCP" value="0" min="0">
                                <div style="font-size:0.6rem;color:var(--text-dim);">Copper</div>
                            </div>
                        </div>
                    </div>

                    <div class="char-section">
                        <h3>Equipment & Inventory</h3>
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:0.75rem;margin-bottom:0.75rem;">
                            <div><label class="char-label">Carrying Capacity (STR Ã— 15 lbs)</label><input class="char-input" id="cCarryingCap" readonly style="background:var(--bg-card);color:var(--accent);text-align:center;"></div>
                            <div><label class="char-label">Current Weight (lbs, manual)</label><input class="char-input" id="cCurrentWeight" type="number" min="0" value="0" placeholder="0"></div>
                        </div>
                        <textarea class="notes-textarea" id="cInventory" style="min-height:180px;" placeholder="Longsword (3 lbs)&#10;Chain Mail (55 lbs)&#10;Shield (6 lbs)&#10;Explorer's Pack&#10;  - Backpack, bedroll, mess kit, tinderbox, 10 torches...&#10;3 daggers (3 lbs)"></textarea>
                    </div>

                    <div class="char-section">
                        <h3>Attuned Magic Items (max 3)</h3>
                        <div style="display:flex;flex-direction:column;gap:0.4rem;">
                            <input class="char-input" id="cAttune1" placeholder="1. (none)">
                            <input class="char-input" id="cAttune2" placeholder="2. (none)">
                            <input class="char-input" id="cAttune3" placeholder="3. (none)">
                        </div>
                    </div>

                    <div class="char-section">
                        <h3>Treasure & Other</h3>
                        <textarea class="notes-textarea" id="cTreasure" style="min-height:100px;" placeholder="Sapphire (500 gp)&#10;Ancient Map&#10;Letter from the King..."></textarea>
                    </div>
                </div>

                <!-- NOTES TAB -->
                <div class="char-tab-content" id="tabNotes">
                    <div class="char-section">
                        <h3>Features & Traits</h3>
                        <textarea class="notes-textarea" id="cFeatures" style="min-height:100px;" placeholder="Class features, racial traits, feats, fighting styles..."></textarea>
                    </div>
                    <div class="char-section">
                        <h3>Campaign Notes</h3>
                        <textarea class="notes-textarea" id="cNotes" style="min-height:120px;" placeholder="Session notes, plot hooks, NPCs met, important locations..."></textarea>
                    </div>
                    <div class="char-section">
                        <h3>Allies & Organizations</h3>
                        <textarea class="notes-textarea" id="cAllies" style="min-height:80px;" placeholder="The Harpers - allied faction&#10;Gandalf the Grey - mentor&#10;..."></textarea>
                    </div>
                    <div class="char-section">
                        <h3>Additional Notes</h3>
                        <textarea class="notes-textarea" id="cExtra" style="min-height:80px;" placeholder="Anything else worth noting..."></textarea>
                    </div>
                </div>

                <!-- FEATURES TAB -->
                <div class="char-tab-content" id="tabFeatures">
                    <div id="featuresPanel">
                        <p style="font-size:0.85rem;color:var(--text-dim);">Select a character to view class features.</p>
                    </div>
                </div>
            </div><!-- end charEditor -->
        </div>
    </div>

    <!-- CHARACTER TRAY (bottom of screen) -->
    <div class="char-tray" id="charTray"></div>

    <!-- DICE ADVANTAGE PANEL -->
    <div class="dice-advantage-panel" id="diceAdvantagePanel">
        <div class="dice-advantage-header" id="diceAdvantageHeader" onclick="toggleDiceAdvantageBody()">
            <h4>ðŸŽ² Dice Advantage</h4>
            <div style="display:flex;align-items:center;gap:0.6rem;">
                <span id="advantageSelectedLabel" style="font-size:0.75rem;color:var(--accent);font-family:'Cinzel',serif;"></span>
                <span id="diceAdvArrow" style="color:var(--text-dim);font-size:0.7rem;">â–²</span>
            </div>
        </div>
        <div class="dice-advantage-body" id="diceAdvantageBody">
            <div class="advantage-chars-row" id="advantageCharsRow">
                <span class="advantage-chars-label">Character:</span>
                <!-- populated by JS -->
            </div>
            <div class="advantage-skills-row" id="advantageSkillsRow">
                <!-- populated by JS -->
                <button class="advantage-clear-btn" onclick="clearDiceAdvantage()">âœ• Clear</button>
            </div>
        </div>
    </div>

    <!-- CHARACTER QUICK-VIEW POPUP -->
    <div class="char-quickview" id="charQuickView">
        <div class="char-qv-header">
            <div>
                <div class="char-qv-name" id="qvName">Character</div>
                <div class="char-qv-sub" id="qvSub">Class â€¢ Race</div>
            </div>
            <button onclick="closeQuickView()" style="background:none;border:none;color:var(--text-dim);cursor:pointer;font-size:1.1rem;padding:0;">âœ•</button>
        </div>
        <div class="char-qv-body">
            <div class="char-qv-hp-bar-wrap">
                <div style="display:flex;justify-content:space-between;font-size:0.7rem;color:var(--text-dim);margin-bottom:2px;">
                    <span>HP</span><span id="qvHPText">10/10</span>
                </div>
                <div class="char-qv-hp-bar-bg"><div class="char-qv-hp-bar-fill" id="qvHPBar" style="width:100%"></div></div>
            </div>
            <div class="char-qv-stats">
                <div class="char-qv-stat"><div class="char-qv-stat-val" id="qvAC">10</div><div class="char-qv-stat-lbl">AC</div></div>
                <div class="char-qv-stat"><div class="char-qv-stat-val" id="qvInit">+0</div><div class="char-qv-stat-lbl">Init</div></div>
                <div class="char-qv-stat"><div class="char-qv-stat-val" id="qvSpeed">30</div><div class="char-qv-stat-lbl">Speed</div></div>
                <div class="char-qv-stat"><div class="char-qv-stat-val" id="qvProf">+2</div><div class="char-qv-stat-lbl">Prof</div></div>
            </div>
            <div style="display:grid;grid-template-columns:repeat(6,1fr);gap:4px;margin-bottom:0.6rem;">
                <div class="char-qv-stat"><div class="char-qv-stat-val" style="font-size:0.85rem;" id="qvSTR">10</div><div class="char-qv-stat-lbl">STR</div></div>
                <div class="char-qv-stat"><div class="char-qv-stat-val" style="font-size:0.85rem;" id="qvDEX">10</div><div class="char-qv-stat-lbl">DEX</div></div>
                <div class="char-qv-stat"><div class="char-qv-stat-val" style="font-size:0.85rem;" id="qvCON">10</div><div class="char-qv-stat-lbl">CON</div></div>
                <div class="char-qv-stat"><div class="char-qv-stat-val" style="font-size:0.85rem;" id="qvINT">10</div><div class="char-qv-stat-lbl">INT</div></div>
                <div class="char-qv-stat"><div class="char-qv-stat-val" style="font-size:0.85rem;" id="qvWIS">10</div><div class="char-qv-stat-lbl">WIS</div></div>
                <div class="char-qv-stat"><div class="char-qv-stat-val" style="font-size:0.85rem;" id="qvCHA">10</div><div class="char-qv-stat-lbl">CHA</div></div>
            </div>
            <div class="char-qv-actions">
                <button class="btn btn-primary btn-small" onclick="openFullSheetFromTray()" style="flex:1;">ðŸ“œ Full Sheet</button>
                <button class="btn btn-small" onclick="closeQuickView()" style="flex:0;">Close</button>
            </div>
        </div>
    </div>

    <script>
        console.clear();
        console.log('%cðŸŽ® THE FRACTURED SKY VTT v4.0 FINAL', 'font-size: 24px; font-weight: bold; color: #8b5cf6; background: #1a1f2e; padding: 10px;');
        console.log('%câœ… JavaScript Loading...', 'font-size: 16px; color: #10b981;');
        console.log('%cBuild: 1770523324', 'font-size: 14px; color: #fbbf24;');
        console.log('%cTime:', 'font-weight: bold;', new Date().toLocaleTimeString());
        console.log('%c--- If you see this, JavaScript is working! ---', 'color: #10b981; font-weight: bold;');

        // === CORE STATE ===
        let peer = null;
        let isDM = false;
        let myId = null;
        let myName = null;
        let roomCode = null;
        let connections = new Map();
        let savedPeerId = null; // For DM session persistence

        // === CO-DM STATE ===
        let isCoDM = false;      // true when this instance joined as a co-DM
        let hostDMConn = null;   // co-DM's connection to the host DM
        let coDMs = new Map();   // host DM's map of approved co-DM connections
        let coDMOriginalCode = null;  // room code stored for co-DM reconnects
        let coDMOriginalName = null;  // co-DM display name for reconnects
        let coDMReconnectTimer = null;

        // === CONNECTION RESILIENCE STATE ===
        let playerFirebaseWatcher = null; // Firestore onSnapshot unsubscribe fn
        let dmHeartbeatTimer = null;      // setInterval handle for DM Firebase keepalive

        // === FIREBASE ===
        const firebaseConfig = {
            apiKey: "AIzaSyDDl5BjZUW-RmT6MG_z9MTsfdedK75fSrc",
            authDomain: "ddddd-f276d.firebaseapp.com",
            projectId: "ddddd-f276d",
            storageBucket: "ddddd-f276d.firebasestorage.app",
            messagingSenderId: "260370337802",
            appId: "1:260370337802:web:e7310129ef9533de4b8ff3",
            measurementId: "G-4X38GGZZ3S"
        };
        let fbDb = null;
        try {
            if (typeof firebase !== 'undefined') {
                if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
                fbDb = firebase.firestore();
            }
        } catch(e) {
            console.warn('âš ï¸ Firebase unavailable â€” running without cloud persistence:', e.message);
        }
        let firebaseUser = null;
        let firebaseSaveTimeout = null;
        let firebaseRoomRef = null; // set to roomCode string once DM opens room
        let playerFirebaseRoomId = null; // set when player is approved (from canonicalRoomId)
        let diceRollsUnsubscribe = null; // Firestore dice roll listener cleanup fn
        let shownRollIds = new Set(); // roll IDs already displayed â€” prevents P2P + Firebase double-show
        let diceListenSince = 0; // timestamp when dice listener started (filters out pre-join rolls)

        async function firebaseSignIn() {
            if (typeof firebase === 'undefined' || !fbDb) return;
            try {
                const result = await firebase.auth().signInAnonymously();
                firebaseUser = result.user;
                console.log('ðŸ”¥ Firebase signed in:', firebaseUser.uid);
            } catch (err) {
                console.error('ðŸ”¥ Firebase auth error:', err);
                updateFirebaseStatus('âš ï¸ Auth failed', '#ef4444');
            }
        }

        // Watch Firestore for DM peer ID changes; fires callback immediately with the
        // current value then on every future change. Stores the unsubscribe fn in
        // playerFirebaseWatcher so the watcher can be torn down cleanly.
        function startFirebaseWatch(roomId, callback) {
            stopFirebaseWatch();
            if (!roomId || !fbDb) return;
            firebaseSignIn().then(() => {
                const unsub = fbDb
                    .collection('vtt_rooms').doc(roomId)
                    .onSnapshot(doc => {
                        const peerId = doc.exists && doc.data() && doc.data().currentPeerId;
                        if (peerId) callback(peerId);
                    }, err => console.error('ðŸ”¥ Watch error:', err));
                playerFirebaseWatcher = unsub;
            }).catch(err => console.error('ðŸ”¥ Watch sign-in error:', err));
        }

        function stopFirebaseWatch() {
            if (typeof playerFirebaseWatcher === 'function') {
                try { playerFirebaseWatcher(); } catch(e) {}
            }
            playerFirebaseWatcher = null;
        }

        // DM refreshes currentPeerId + lastSeen in Firebase every 20 s so that
        // onSnapshot watchers on players/co-DMs wake up if the first write was missed.
        function startDMHeartbeat() {
            stopDMHeartbeat();
            dmHeartbeatTimer = setInterval(() => {
                if (!isDM || isCoDM || !firebaseRoomRef || !firebaseUser || !fbDb) return;
                fbDb.collection('vtt_rooms').doc(firebaseRoomRef)
                    .set({ currentPeerId: myId, lastSeen: Date.now() }, { merge: true })
                    .catch(e => console.error('ðŸ”¥ Heartbeat error:', e));
            }, 20000);
        }

        function stopDMHeartbeat() {
            if (dmHeartbeatTimer) { clearInterval(dmHeartbeatTimer); dmHeartbeatTimer = null; }
        }

        // Re-connect a co-DM to the host using the latest Firebase peer ID.
        function coDMAutoReconnect() {
            if (!isCoDM || !coDMOriginalCode) return;
            clearTimeout(coDMReconnectTimer);
            joinAsCoDM(coDMOriginalName || myName || 'Co-DM', coDMOriginalCode);
        }

        // Firestore has a 1MB document limit, so we split state across
        // sibling documents â€” all matched by the {roomId} wildcard in your rules.
        // Main doc:  vtt_rooms/{roomId}           â†’ tokens, zoom, pan, lockedCells
        // Cell docs: vtt_rooms/{roomId}__cell_X_Y â†’ one canvas dataURL per grid cell
        // Fog docs:  vtt_rooms/{roomId}__fog_NAME â†’ one canvas dataURL per fog group
        // Image doc: vtt_rooms/{roomId}__images   â†’ placed image list

        function scheduleSave() {
            if (!isDM || !firebaseRoomRef || !firebaseUser) return;
            clearTimeout(firebaseSaveTimeout);
            updateFirebaseStatus('â˜ï¸ Unsaved...', '#fbbf24');
            firebaseSaveTimeout = setTimeout(saveToFirebase, 1500);
        }

        async function saveToFirebase() {
            if (!isDM || !firebaseRoomRef || !firebaseUser || !fbDb) return;
            try {
                updateFirebaseStatus('â˜ï¸ Saving...', '#fbbf24');
                const col = fbDb.collection('vtt_rooms');
                const batch = fbDb.batch();

                // Collect connected player info
                const playerData = [];
                connections.forEach(({ name, role, approved }, peerId) => {
                    if (approved) playerData.push({ name, role, peerId });
                });

                // Main document â€” lightweight state
                batch.set(col.doc(firebaseRoomRef), {
                    tokens: [...stagingTokens, ...placedTokens],
                    lockedCells,
                    zoom, panX, panY,
                    fogGroupNames: Object.keys(fogGroups),
                    campaignName,
                    playerData,
                    savedAt: Date.now()
                });

                // One document per grid cell
                for (const key in gridCells) {
                    const safeKey = key.replace(/,/g, '_');
                    batch.set(col.doc(firebaseRoomRef + '__cell_' + safeKey), {
                        data: gridCells[key].toDataURL()
                    });
                }

                // One document per fog group
                for (const group in fogGroups) {
                    const safeGroup = group.replace(/[^a-zA-Z0-9_-]/g, '_');
                    batch.set(col.doc(firebaseRoomRef + '__fog_' + safeGroup), {
                        name: group,
                        data: fogGroups[group].canvas.toDataURL()
                    });
                }

                // Placed images
                const imagesData = placedImages.map(pi => ({
                    src: pi.img.src,
                    x: pi.x, y: pi.y,
                    width: pi.width, height: pi.height,
                    rotation: pi.rotation,
                    gridX: pi.gridX, gridY: pi.gridY
                }));
                batch.set(col.doc(firebaseRoomRef + '__images'), { images: imagesData });

                // Placed stamps (positions only â€” lightweight)
                batch.set(col.doc(firebaseRoomRef + '__stamps'), { placedStamps });

                await batch.commit();

                // Stamp sub-maps are large (dataURLs) â€” save each as its own doc outside the batch
                for (const sid in stampSubMaps) {
                    const safeId = sid.replace(/[^a-zA-Z0-9_-]/g, '_');
                    await col.doc(firebaseRoomRef + '__submap_' + safeId).set({
                        stampId: sid,
                        imageData: stampSubMaps[sid].toDataURL()
                    }).catch(() => {});
                }
                updateFirebaseStatus('â˜ï¸ Saved', '#10b981');
                console.log('ðŸ”¥ Saved to Firestore');
            } catch (err) {
                console.error('ðŸ”¥ Firebase save error:', err);
                updateFirebaseStatus('âš ï¸ Save failed', '#ef4444');
            }
        }

        async function loadFromFirebase(roomId) {
            if (!fbDb) return;
            try {
                updateFirebaseStatus('â˜ï¸ Loading...', '#fbbf24');
                const col = fbDb.collection('vtt_rooms');
                const mainSnap = await col.doc(roomId).get();

                if (!mainSnap.exists) {
                    updateFirebaseStatus('â˜ï¸ New room', '#9ca3af');
                    console.log('ðŸ”¥ No saved state â€” starting fresh');
                    return;
                }

                const main = mainSnap.data();

                // Load all 9 possible grid cells
                const gridData = {};
                const cellFetches = [];
                for (let cy = 0; cy < 3; cy++) {
                    for (let cx = 0; cx < 3; cx++) {
                        const key = `${cx},${cy}`;
                        const safeKey = `${cx}_${cy}`;
                        cellFetches.push(
                            col.doc(roomId + '__cell_' + safeKey).get().then(snap => {
                                if (snap.exists) gridData[key] = snap.data().data;
                            })
                        );
                    }
                }

                // Load fog groups
                const fogData = {};
                const fogNames = main.fogGroupNames || ['everyone'];
                const fogFetches = fogNames.map(name => {
                    const safeGroup = name.replace(/[^a-zA-Z0-9_-]/g, '_');
                    return col.doc(roomId + '__fog_' + safeGroup).get().then(snap => {
                        if (snap.exists) fogData[snap.data().name] = snap.data().data;
                    });
                });

                // Load placed images
                const imagesSnap = await col.doc(roomId + '__images').get();
                const imagesData = imagesSnap.exists ? imagesSnap.data().images : [];

                // Load placed stamps (positions)
                const stampsSnap = await col.doc(roomId + '__stamps').get();
                const loadedStamps = stampsSnap.exists ? (stampsSnap.data().placedStamps || []) : [];

                await Promise.all([...cellFetches, ...fogFetches]);

                // Load stamp sub-maps (one doc per stamp that has an illustration)
                const subMapsData = {};
                const subMapFetches = loadedStamps.map(stamp => {
                    const safeId = stamp.id.replace(/[^a-zA-Z0-9_-]/g, '_');
                    return col.doc(roomId + '__submap_' + safeId).get().then(snap => {
                        if (snap.exists) subMapsData[stamp.id] = snap.data().imageData;
                    }).catch(() => {});
                });
                await Promise.all(subMapFetches);

                loadGameState({
                    tokens: main.tokens || [],
                    lockedCells: main.lockedCells || {},
                    zoom: main.zoom || 1,
                    panX: main.panX || 0,
                    panY: main.panY || 0,
                    gridCells: gridData,
                    fogGroups: fogData,
                    placedImages: imagesData,
                    placedStamps: loadedStamps,
                    stampSubMaps: subMapsData
                });

                if (main.campaignName) {
                    campaignName = main.campaignName;
                    localStorage.setItem('fracturedSkyCampaignName', campaignName);
                    updateCampaignNameDisplay();
                }
                updateFirebaseStatus('â˜ï¸ Loaded', '#10b981');
                console.log('ðŸ”¥ Loaded from Firestore');
            } catch (err) {
                console.error('ðŸ”¥ Firebase load error:', err);
                updateFirebaseStatus('âš ï¸ Load failed', '#ef4444');
            }
        }

        function updateFirebaseStatus(text, color) {
            const header = document.getElementById('firebaseStatus');
            const panel = document.getElementById('firebaseStatusPanel');
            const section = document.getElementById('firebaseStatusSection');
            if (header) { header.textContent = text; header.style.color = color; }
            if (panel)  { panel.textContent = text; panel.style.color = color; }
            if (section) section.style.display = 'block';
        }

        // Campaign name
        let campaignName = localStorage.getItem('fracturedSkyCampaignName') || 'From Sunnyville';
        function updateCampaignNameDisplay() {
            const el = document.getElementById('sessionNameDisplay');
            if (el) el.textContent = campaignName;
        }
        function editCampaignName() {
            const newName = prompt('Campaign name:', campaignName);
            if (newName !== null && newName.trim()) {
                campaignName = newName.trim();
                localStorage.setItem('fracturedSkyCampaignName', campaignName);
                updateCampaignNameDisplay();
                scheduleSave();
            }
        }

        // Game state
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let gridSnapEnabled = true;
        const GRID_SNAP_SIZE = 25;
        const GRID_SIZE = 400;
        const CELL_SIZE = 400;

        // Map builder
        let currentCellX = 1;
        let currentCellY = 1;
        let gridCells = {};
        let lockedCells = {};
        let tool = 'brush';
        let color = '#4a7c59';
        let size = 8;
        let currentAsset = 'Brush';
        let lastToolBeforeEraser = 'brush'; // Track tool before eraser
        let eraserMode = 'content'; // 'content' or 'all'
        let currentStamp = 'ðŸ°';

        // === LANDMARK STAMP TRACKING (sub-map feature) ===
        let placedStamps = [];   // [{ id, emoji, worldX, worldY }]
        let stampSubMaps = {};   // stampId -> HTMLCanvasElement (the vertical illustration)
        let activeSubMapId = null;
        let subMapTool = 'brush';
        let subMapColor = '#4a7c59';
        let subMapSize = 8;
        let isSubMapDrawing = false;
        let subMapLastX = 0, subMapLastY = 0;
        let glowAnimating = false;

        let tokenType = 'emoji'; // 'emoji' or 'image'
        let tokenImageData = null;
        
        // Image layer for DM
        let placedImages = []; // { img, x, y, width, height, rotation, gridX, gridY }
        let selectedImage = null;
        let imageResizeHandle = null; // 'nw', 'ne', 'sw', 'se', 'rotate'
        let imageDragStart = null;
        
        // History tracking
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // Drawing state
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Tokens
        let stagingTokens = [];
        let placedTokens = [];
        const tokenImageCache = new Map(); // keyed by token id â†’ {img, srcKey}
        let draggedToken = null;
        let draggedPlacedToken = null; // For moving tokens already on the map
        let tokenDragOffset = { x: 0, y: 0 };

        // Fog
        let activeFogGroup = 'everyone';
        let fogGroups = { everyone: { name: 'Everyone', canvas: null } };
        let fogMode = false;
        let fogPaintMode = 'brush'; // 'brush' or 'rect'
        let fogBrushSize = 60;
        let fogRectStart = null;
        let isFogDrawing = false;
        let dmFogOpacity = 0.3; // DM sees through fog
        let fogBroadcastTimeout = null; // For throttling broadcasts

        // Player requests
        let pendingRequests = [];
        let approvedPlayerNames = new Set(); // tracks names of ever-approved players for auto-reapprove

        // Minimap
        let minimapDocked = false;
        let minimapDragOffset = null;
        let _minimapLastState = ''; // dirty-check: skip rebuild when nothing changed

        const gridNames = [
            ['Top-Left', 'Top-Center', 'Top-Right'],
            ['Middle-Left', 'Center', 'Middle-Right'],
            ['Bottom-Left', 'Bottom-Center', 'Bottom-Right']
        ];

        // Canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');

        // Initialize fog canvases
        for (let group in fogGroups) {
            const fogCanvas = document.createElement('canvas');
            fogCanvas.width = GRID_SIZE * 3;
            fogCanvas.height = GRID_SIZE * 3;
            const fogCtx = fogCanvas.getContext('2d');
            fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Full opacity black fog
            fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
            fogGroups[group].canvas = fogCanvas;
        }

        // === INITIALIZATION ===
        // Cached DOM references â€” set once in init() to avoid repeated getElementById on hot paths
        let _elStatusText, _elStatusIndicator, _elTabIndicator, _elCurrentCell, _elCurrentAsset, _elMinimapGrid;

        function init() {
            _elStatusText      = document.getElementById('statusText');
            _elStatusIndicator = document.getElementById('statusIndicator');
            _elTabIndicator    = document.getElementById('tabIndicator');
            _elCurrentCell     = document.getElementById('currentCell');
            _elCurrentAsset    = document.getElementById('currentAsset');
            _elMinimapGrid     = document.getElementById('minimapGrid');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Load char tray on startup
            try { loadCharactersFromStorage(); renderCharTray(); } catch(e) {}

            // On page hide/close: flush any pending Firebase save immediately
            // so game state is never lost on DM refresh.
            function flushSave() {
                if (isDM && firebaseRoomRef && firebaseUser && fbDb) {
                    clearTimeout(firebaseSaveTimeout);
                    firebaseSaveTimeout = null;
                    saveToFirebase(); // best-effort async save
                }
            }
            // visibilitychange fires reliably on tab switch, phone sleep, refresh
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') flushSave();
            });
            // beforeunload fires on browser close / navigation
            window.addEventListener('beforeunload', () => {
                flushSave();
                if (peer && !peer.destroyed) peer.destroy();
            });

            // Listen for another tab taking over as DM â€” surrender peer immediately
            try {
                const dmChannel = new BroadcastChannel('fracturedSky_dm');
                dmChannel.onmessage = (e) => {
                    if (e.data.type === 'surrender' && isDM && peer && !peer.destroyed && roomCode === e.data.id) {
                        console.log('ðŸ“¡ Surrendering peer ID to new tab:', e.data.id);
                        peer.destroy();
                    }
                };
            } catch(e) {}
            
            mapCtx.fillStyle = '#f5f5dc';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            
            updateGridDisplay();
            updateMinimap();
            saveHistory();
            
            // Close DM panel when double-clicking outside
            document.addEventListener('dblclick', (e) => {
                if (!isDM) return;
                const panel = document.getElementById('dmPanel');
                if (!panel.contains(e.target) && panel.classList.contains('open')) {
                    toggleDMPanel();
                    deselectAllTools();
                }
            });

            // Check for saved sessions and offer to resume.
            // tabRole (sessionStorage) is per-tab and survives refresh but NOT
            // browser restart, so it's safe to use in split-tab same-browser setups.
            // localStorage holds the actual data (room IDs, names) that persists
            // longer term but must never be used alone to decide which role THIS tab has.
            const tabRole = sessionStorage.getItem('fracturedSkyTabRole');
            const savedDMSession = localStorage.getItem('fracturedSkySessionId');
            const savedPlayerRoom = localStorage.getItem('fracturedSkyPlayerRoom');
            const savedPlayerName = localStorage.getItem('fracturedSkyPlayerName');

            // Decide which role this tab should resume.
            // Priority: sessionStorage role (refresh-safe, tab-isolated) >
            //           localStorage isDM flag (browser-restart fallback, single-tab only).
            const resumeAsDM = tabRole === 'dm'
                || (tabRole === null && localStorage.getItem('fracturedSkyIsDM') === 'true');
            const resumeAsPlayer = !resumeAsDM && (tabRole === 'player'
                || (tabRole === null && !!(savedPlayerRoom && savedPlayerName)));

            if (resumeAsDM && savedDMSession) {
                // Auto-reconnect DM immediately â€” no click required.
                // Show a "Start Fresh" cancel button in case they want a new session.
                document.getElementById('welcomeButtons').style.display = 'none';
                document.getElementById('welcomeReconnect').style.display = 'block';
                document.getElementById('welcomeReconnectMsg').textContent = 'ðŸ‘‘ Resuming your DM session...';
                document.getElementById('connectionTabContainer').style.display = 'block';
                document.getElementById('startFreshBtn').style.display = 'block';
                try {
                    const saved = localStorage.getItem('fracturedSkyApprovedNames');
                    if (saved) JSON.parse(saved).forEach(n => approvedPlayerNames.add(n));
                } catch(e) {}
                createRoom(savedDMSession);
            } else if (resumeAsPlayer && savedPlayerRoom && savedPlayerName) {
                // Auto-reconnect player immediately.
                // Keep welcome screen visible so user can cancel if stuck.
                document.getElementById('welcomeButtons').style.display = 'none';
                document.getElementById('welcomeReconnect').style.display = 'block';
                document.getElementById('welcomeReconnectMsg').textContent = `ðŸ‘¤ Reconnecting as "${savedPlayerName}"...`;
                document.getElementById('connectionTabContainer').style.display = 'block';
                document.getElementById('startFreshBtn').style.display = 'block';
                myName = savedPlayerName;
                roomCode = savedPlayerRoom;
                updateConnectionStatus('Reconnecting...', false);
                playerAutoReconnect();
            }
        }

        function doAutoReconnect() {
            document.getElementById('welcomeReconnect').style.display = 'none';
            document.getElementById('welcomeButtons').style.display = 'flex';
            const savedDMSession = localStorage.getItem('fracturedSkySessionId');
            const wasDM = localStorage.getItem('fracturedSkyIsDM') === 'true';
            if (wasDM && savedDMSession) {
                try {
                    const saved = localStorage.getItem('fracturedSkyApprovedNames');
                    if (saved) JSON.parse(saved).forEach(n => approvedPlayerNames.add(n));
                } catch(e) {}
                sessionStorage.setItem('fracturedSkyTabRole', 'dm');
                updateConnectionStatus('Reconnecting...', false);
                createRoom(savedDMSession);
            } else {
                const savedPlayerRoom = localStorage.getItem('fracturedSkyPlayerRoom');
                const savedPlayerName = localStorage.getItem('fracturedSkyPlayerName');
                if (savedPlayerRoom && savedPlayerName) {
                    sessionStorage.setItem('fracturedSkyTabRole', 'player');
                    myName = savedPlayerName;
                    roomCode = savedPlayerRoom;
                    document.getElementById('welcomeScreen').classList.add('hidden');
                    document.getElementById('connectionTabContainer').style.display = 'block';
                    updateConnectionStatus('Reconnecting...', false);
                    playerAutoReconnect();
                }
            }
        }

        function resumeDMSession() {
            try {
                const saved = localStorage.getItem('fracturedSkyApprovedNames');
                if (saved) JSON.parse(saved).forEach(n => approvedPlayerNames.add(n));
            } catch(e) {}
            const savedDMSession = localStorage.getItem('fracturedSkySessionId');
            sessionStorage.setItem('fracturedSkyTabRole', 'dm');
            // Hide welcome screen & show connection tab immediately so user sees feedback
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('connectionTabContainer').style.display = 'block';
            updateConnectionStatus('Reconnecting...', false);
            createRoom(savedDMSession);
        }
        function clearDMSession() {
            localStorage.removeItem('fracturedSkySessionId');
            localStorage.removeItem('fracturedSkyIsDM');
            document.getElementById('resumeArea').innerHTML = '';
        }
        function resumePlayerSession() {
            const savedPlayerRoom = localStorage.getItem('fracturedSkyPlayerRoom');
            const savedPlayerName = localStorage.getItem('fracturedSkyPlayerName');
            sessionStorage.setItem('fracturedSkyTabRole', 'player');
            myName = savedPlayerName;
            roomCode = savedPlayerRoom;
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('connectionTabContainer').style.display = 'block';
            updateConnectionStatus('Reconnecting as ' + savedPlayerName + '...', false);
            playerAutoReconnect();
        }
        function clearPlayerSession() {
            localStorage.removeItem('fracturedSkyPlayerRoom');
            localStorage.removeItem('fracturedSkyPlayerName');
            document.getElementById('resumeArea').innerHTML = '';
        }

        function confirmLeaveSession() {
            if (!isDM) {
                cancelAutoReconnect();
                return;
            }
            document.getElementById('leaveConfirmModal').classList.add('active');
        }

        function closeLeaveConfirmModal() {
            document.getElementById('leaveConfirmModal').classList.remove('active');
        }

        function saveAndLeaveSession() {
            exportCampaign();
            closeLeaveConfirmModal();
            cancelAutoReconnect();
        }

        function cancelAutoReconnect() {
            // Abort any in-flight reconnect attempt
            stopFirebaseWatch();
            if (peer && !peer.destroyed) { try { peer.destroy(); } catch(e) {} }
            peer = null;
            isDM = false;
            // Clear all saved session data
            sessionStorage.removeItem('fracturedSkyTabRole');
            sessionStorage.removeItem('fracturedSkyPlayerRoom');
            localStorage.removeItem('fracturedSkyIsDM');
            localStorage.removeItem('fracturedSkySessionId');
            localStorage.removeItem('fracturedSkyPlayerRoom');
            localStorage.removeItem('fracturedSkyPlayerName');
            // Clear DM game settings so they don't bleed into a new session
            localStorage.removeItem('fracturedSkyCampaignName');
            localStorage.removeItem('fracturedSkyApprovedNames');
            // Restore welcome screen
            document.getElementById('welcomeReconnect').style.display = 'none';
            document.getElementById('welcomeButtons').style.display = 'flex';
            document.getElementById('welcomeScreen').classList.remove('hidden');
            document.getElementById('connectionTabContainer').style.display = 'none';
            document.getElementById('diceRollerBtn').classList.remove('visible');
            document.getElementById('diceRollLog').classList.remove('visible');
            const advPanel = document.getElementById('diceAdvantagePanel');
            if (advPanel) advPanel.classList.remove('panel-visible');
            document.getElementById('editCampaignBtn').style.display = 'none';
        }

        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            const prevW = canvas.width;
            const prevH = canvas.height;
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            // Only center on first load (prevW === 0), not on every resize
            if (prevW === 0) {
                panX = (canvas.width - GRID_SIZE * 3) / 2;
                panY = (canvas.height - GRID_SIZE * 3) / 2;
            }
            draw();
        }

        // === AUTHENTICATION ===
        function showDMLogin() {
            const savedSession = localStorage.getItem('fracturedSkySessionId');
            if (savedSession) document.getElementById('sessionId').value = savedSession;
            const creds = getDMCredentials();
            const firstTime = !creds.user || !creds.pass;
            document.getElementById('dmFirstTimeNotice').style.display = firstTime ? 'block' : 'none';
            document.getElementById('dmLoginBtn').textContent = firstTime ? 'CREATE ACCOUNT & OPEN ROOM' : 'LOGIN & CREATE ROOM';
            if (creds.user) document.getElementById('dmUser').value = creds.user;
            document.getElementById('dmSetupPanel').style.display = 'none';
            document.getElementById('dmError').classList.remove('show');
            document.getElementById('dmModal').classList.add('active');
        }

        function getDMCredentials() {
            return {
                user: localStorage.getItem('fracturedSkyDMUser') || null,
                pass: localStorage.getItem('fracturedSkyDMPass') || null
            };
        }

        function closeDMModal() {
            document.getElementById('dmModal').classList.remove('active');
            document.getElementById('dmError').classList.remove('show');
            document.getElementById('dmInfo').style.display = 'none';
            document.getElementById('dmSetupPanel').style.display = 'none';
        }

        function toggleDMSetup() {
            const panel = document.getElementById('dmSetupPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            document.getElementById('dmSetupError').classList.remove('show');
            document.getElementById('dmSetupSuccess').style.display = 'none';
        }

        function saveDMCredentials() {
            const newUser = document.getElementById('dmNewUser').value.trim();
            const newPass = document.getElementById('dmNewPass').value;
            const confirm = document.getElementById('dmNewPassConfirm').value;
            const errEl = document.getElementById('dmSetupError');
            errEl.classList.remove('show');
            document.getElementById('dmSetupSuccess').style.display = 'none';
            if (!newUser || !newPass) { errEl.textContent = 'Username and password are required.'; errEl.classList.add('show'); return; }
            if (newPass !== confirm) { errEl.textContent = 'Passwords do not match.'; errEl.classList.add('show'); return; }
            localStorage.setItem('fracturedSkyDMUser', newUser);
            localStorage.setItem('fracturedSkyDMPass', newPass);
            document.getElementById('dmSetupSuccess').style.display = 'block';
            document.getElementById('dmNewUser').value = '';
            document.getElementById('dmNewPass').value = '';
            document.getElementById('dmNewPassConfirm').value = '';
            // Update login field hints
            document.getElementById('dmUser').value = newUser;
            document.getElementById('dmFirstTimeNotice').style.display = 'none';
            document.getElementById('dmLoginBtn').textContent = 'LOGIN & CREATE ROOM';
        }

        function dmLogin(e) {
            e.preventDefault();
            const user = document.getElementById('dmUser').value;
            const pass = document.getElementById('dmPass').value;
            const sessionId = document.getElementById('sessionId').value.trim();
            const creds = getDMCredentials();
            // If no credentials saved yet, treat this submission as first-time setup
            if (!creds.user || !creds.pass) {
                localStorage.setItem('fracturedSkyDMUser', user);
                localStorage.setItem('fracturedSkyDMPass', pass);
                closeDMModal();
                createRoom(sessionId || null);
                return;
            }
            if (user === creds.user && pass === creds.pass) {
                closeDMModal();
                createRoom(sessionId || null);
            } else {
                document.getElementById('dmError').classList.add('show');
            }
        }

        function showPlayerLogin() {
            document.getElementById('playerModal').classList.add('active');
        }

        function closePlayerModal() {
            document.getElementById('playerModal').classList.remove('active');
            document.getElementById('playerError').classList.remove('show');
            document.getElementById('playerSuccess').classList.remove('show');
        }

        function playerLogin(e) {
            e.preventDefault();
            myName = document.getElementById('playerName').value;
            const code = document.getElementById('roomCodeInput').value.trim();
            // Mark THIS TAB as player in sessionStorage.
            // Do NOT touch fracturedSkyIsDM / fracturedSkySessionId in localStorage â€”
            // those belong to the DM tab. Wiping them here was the root cause of the
            // DM being unable to auto-reconnect after a refresh in split-tab same-browser use.
            sessionStorage.setItem('fracturedSkyTabRole', 'player');

            roomCode = code;
            localStorage.setItem('fracturedSkyPlayerRoom', code);
            localStorage.setItem('fracturedSkyPlayerName', myName);

            peer = new Peer();
            peer.on('open', (id) => {
                myId = id;
                const conn = peer.connect(code);

                setupConnection(conn, true);

                conn.on('open', () => {
                    // Send join request
                    sendToPeer(conn, {
                        type: 'playerJoinRequest',
                        name: myName,
                        peerId: myId
                    });
                    
                    document.getElementById('playerSuccess').classList.add('show');
                    
                    setTimeout(() => {
                        closePlayerModal();
                        document.getElementById('welcomeScreen').classList.add('hidden');
                        document.getElementById('connectionTabContainer').style.display = 'block';
                        updateConnectionStatus('Waiting for approval...', false);
                    }, 2000);
                });
                
                conn.on('error', (err) => {
                    document.getElementById('playerError').textContent = 'Connection failed: ' + err.type;
                    document.getElementById('playerError').classList.add('show');
                });
            });
        }

        function playerAutoReconnect() {
            const savedRoom = localStorage.getItem('fracturedSkyPlayerRoom');
            const savedName = localStorage.getItem('fracturedSkyPlayerName');
            if (!savedRoom || !savedName || isDM) return;
            myName = savedName;
            roomCode = savedRoom;

            // Track the peer ID we most recently tried so we don't open
            // duplicate connections when the Firebase watcher fires multiple times.
            let lastAttemptedPeerId = null;
            // The latest peer ID we know about (from Firebase or savedRoom).
            // Used by scheduleRetry so we keep knocking on the same door while
            // waiting for the DM to come back online.
            let currentBestPeerId = null;
            // ONE shared timeout handle â€” always cancelled before starting a new
            // connect attempt, so a stale timeout from attempt N can never reset
            // lastAttemptedPeerId while attempt N+1 is already in flight.
            let activeConnTimeout = null;

            // After a failed attempt, retry with the best-known peer ID after 15 s.
            // This handles the case where the DM comes back with the SAME peer ID
            // (the Firebase watcher won't fire again if the value didn't change).
            function scheduleRetry() {
                setTimeout(() => {
                    if (isDM) return; // user switched to DM â€” stop retrying
                    if (lastAttemptedPeerId === null) doConnect(currentBestPeerId || savedRoom);
                }, 15000);
            }

            function doConnect(targetPeerId) {
                if (isDM) return; // user switched to DM â€” abort
                if (targetPeerId === lastAttemptedPeerId) return; // already trying
                currentBestPeerId = targetPeerId;
                lastAttemptedPeerId = targetPeerId;

                // Cancel any timeout from the previous attempt before we destroy
                // that peer â€” prevents the old callback from firing after we move on.
                if (activeConnTimeout) { clearTimeout(activeConnTimeout); activeConnTimeout = null; }

                if (peer && !peer.destroyed) { try { peer.destroy(); } catch(e) {} }
                peer = new Peer();
                peer.on('open', (id) => {
                    myId = id;
                    const conn = peer.connect(targetPeerId);
                    setupConnection(conn, true);

                    activeConnTimeout = setTimeout(() => {
                        activeConnTimeout = null;
                        if (isDM) return; // user became DM â€” don't overwrite DM status
                        lastAttemptedPeerId = null;
                        updateConnectionStatus('Waiting for DM...', false);
                        scheduleRetry(); // keep trying every 15 s while DM is offline
                    }, 12000);

                    conn.on('open', () => {
                        clearTimeout(activeConnTimeout); activeConnTimeout = null;
                        sendToPeer(conn, { type: 'playerJoinRequest', name: myName, peerId: myId, isReconnect: true });
                        updateConnectionStatus('Waiting for approval...', false);
                    });
                    conn.on('error', () => {
                        clearTimeout(activeConnTimeout); activeConnTimeout = null;
                        if (isDM) return; // user became DM â€” don't overwrite DM status
                        lastAttemptedPeerId = null;
                        updateConnectionStatus('Waiting for DM...', false);
                        scheduleRetry(); // keep trying every 15 s while DM is offline
                    });
                });
                peer.on('error', () => {
                    lastAttemptedPeerId = null;
                    if (!isDM) setTimeout(playerAutoReconnect, 5000);
                });
            }

            updateConnectionStatus('Looking up room...', false);

            // Prefer Firebase onSnapshot: fires immediately with current value
            // AND fires again whenever the DM publishes a new peer ID after refresh.
            if (fbDb) {
                // Watch Firebase for live peer ID â€” fires immediately if already set,
                // and again whenever the DM publishes a new peer ID after refresh.
                startFirebaseWatch(savedRoom, (peerId) => doConnect(peerId));
                // Fallback: if Firebase doesn't deliver within 4 s, try saved code directly.
                setTimeout(() => { if (lastAttemptedPeerId === null) doConnect(savedRoom); }, 4000);
            } else {
                // No Firebase â€” connect directly to the saved peer ID
                doConnect(savedRoom);
            }
        }

        // === MULTIPLAYER ===
        function createRoom(existingId = null) {
            isDM = true;
            isCoDM = false;
            myName = 'Dungeon Master';
            // NOTE: do NOT clear fracturedSkyPlayerRoom / fracturedSkyPlayerName here.
            // Both tabs share localStorage; wiping those keys kills the player tab's
            // ability to reconnect whenever the DM refreshes in the same browser.
            // playerAutoReconnect already guards itself with `if (isDM) return`, so
            // the DM tab is safe even without the removal.

            // Keep old room ID so we can load campaign data from Firebase
            // even if we end up with a different peer ID
            const fbLoadId = existingId;

            // --- Shared "peer is ready" logic ---
            function onPeerReady(id) {
                myId = id;
                roomCode = id;
                savedPeerId = id;
                // Only persist the session ID on first room creation (fbLoadId is null).
                // On reconnects fbLoadId holds the *canonical* room ID â€” we must NOT
                // overwrite it with the fresh peer ID or every subsequent refresh will
                // load from the wrong Firebase doc and the room dies.
                if (!fbLoadId) {
                    localStorage.setItem('fracturedSkySessionId', id);
                }
                localStorage.setItem('fracturedSkyIsDM', 'true');
                // Mark THIS TAB as DM in sessionStorage (tab-isolated, survives refresh).
                // This is the canonical way to detect the role on refresh without
                // being confused by another tab's localStorage writes.
                sessionStorage.setItem('fracturedSkyTabRole', 'dm');
                onDMReady();
                document.getElementById('firebaseSection').style.display = 'flex';
                document.getElementById('firebaseStatus').style.display = 'inline';
                firebaseSignIn().then(() => {
                    const loadId = fbLoadId || roomCode;
                    // Always save/heartbeat to the canonical room doc (loadId) so
                    // data never splits across multiple Firestore documents when the
                    // DM gets a new peer ID after refresh.
                    firebaseRoomRef = loadId;

                    // Publish the DM's live peer ID to the canonical room doc so
                    // players/co-DMs watching it always learn the latest peer ID,
                    // even when a fresh peer ID was assigned after refresh.
                    if (fbDb) {
                        const stamp = { currentPeerId: id, lastSeen: Date.now() };
                        fbDb.collection('vtt_rooms').doc(loadId).set(stamp, { merge: true }).catch(() => {});
                    }

                    loadFromFirebase(loadId);
                    loadAndListenDiceRolls(loadId);

                    // Keep Firebase updated every 20 s so onSnapshot watchers on
                    // players and co-DMs receive a timely wake-up call even if
                    // they missed the first write.
                    startDMHeartbeat();
                });
            }

            // --- Fall back to a fresh random peer ID (with retry) ---
            function startFreshPeer(attempt = 1) {
                updateConnectionStatus('Getting new session...', false);
                if (peer) { try { peer.destroy(); } catch(e) {} }
                peer = new Peer();
                let done = false;
                const t = setTimeout(() => {
                    if (done) return;
                    done = true;
                    if (attempt < 5) {
                        startFreshPeer(attempt + 1);
                    } else {
                        updateConnectionStatus('Server not responding â€” try refreshing', false);
                    }
                }, 8000);
                peer.on('open', id => {
                    if (done) return;
                    done = true;
                    clearTimeout(t);
                    onPeerReady(id);
                });
                peer.on('connection', conn => setupConnection(conn));
                peer.on('error', e => {
                    if (done) return;
                    done = true;
                    clearTimeout(t);
                    console.error('Peer error (fresh):', e.type, 'attempt', attempt);
                    if (attempt < 5) {
                        const delay = Math.min(attempt * 2000, 8000);
                        updateConnectionStatus('Reconnecting...', false);
                        setTimeout(() => startFreshPeer(attempt + 1), delay);
                    } else {
                        updateConnectionStatus('Connection failed â€” refresh and try again', false);
                    }
                });
            }

            // --- Try to claim a specific peer ID, with up to 3 retries ---
            function tryClaimId(idToClaim, attempt) {
                if (peer) { try { peer.destroy(); } catch(e) {} }
                peer = new Peer(idToClaim);
                // Guard so the timeout and the error event can't both call startFreshPeer
                let alreadyDone = false;

                // 4-second timeout per attempt â€” if the signalling server hasn't
                // responded by then, fall through to a fresh random peer ID fast.
                const timeout = setTimeout(() => {
                    if (alreadyDone) return;
                    alreadyDone = true;
                    updateConnectionStatus('Server slow â€” switching to new session...', false);
                    startFreshPeer();
                }, 4000);

                peer.on('open', id => {
                    if (alreadyDone) return;
                    alreadyDone = true;
                    clearTimeout(timeout);
                    onPeerReady(id);
                });
                peer.on('connection', conn => setupConnection(conn));
                peer.on('error', err => {
                    if (alreadyDone) return;
                    alreadyDone = true;
                    clearTimeout(timeout);
                    if (err.type === 'unavailable-id' && attempt < 3) {
                        // Short delays: 500 ms, 1 s â€” fast fallthrough to fresh ID
                        const delay = attempt * 500;
                        updateConnectionStatus(`Reclaiming session... (${attempt}/3)`, false);
                        setTimeout(() => tryClaimId(idToClaim, attempt + 1), delay);
                    } else {
                        // All retries exhausted or other error â€” fall back to fresh ID
                        // Campaign data will still load from Firebase
                        startFreshPeer();
                    }
                });
            }

            if (existingId) {
                // Tell any other tab holding this peer ID to release it
                try {
                    const bc = new BroadcastChannel('fracturedSky_dm');
                    bc.postMessage({ type: 'surrender', id: existingId });
                    bc.close();
                } catch(e) {}
                // Short pause for the release, then try to claim
                setTimeout(() => tryClaimId(existingId, 1), 500);
            } else {
                startFreshPeer();
            }
        }

        // Called whenever this tab successfully claims the DM role
        function onDMReady() {
            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('welcomeReconnect').style.display = 'none';
            document.getElementById('welcomeButtons').style.display = 'flex';
            document.getElementById('startFreshBtn').style.display = 'none';
            document.getElementById('connectionTabContainer').style.display = 'block';
            document.getElementById('diceRollerBtn').classList.add('visible');
            document.getElementById('diceRollLog').classList.add('visible');
            showDiceAdvantagePanel();
            document.getElementById('roomCodeSection').style.display = 'block';
            document.getElementById('roomCode').textContent = roomCode;
            document.getElementById('dmControlsBtn').style.display = 'block';
            document.getElementById('musicToggleBtn').style.display = 'block';
            document.getElementById('stagingZone').style.display = 'flex';
            document.getElementById('editCampaignBtn').style.display = 'inline-block';
            updateCampaignNameDisplay();
            updateConnectionStatus('Connected as DM', true);
            updateUserList();
            loadSavedCloudLink();
            initMusicPanel();
            // Open the connection panel to show the room code â€” stays open until DM closes it
            const panel = document.getElementById('connectionPanel');
            if (!panel.classList.contains('open')) toggleConnectionPanel();
        }

        // === CO-DM ===
        function showCoDMLogin() {
            document.getElementById('coDMModal').classList.add('active');
        }
        function closeCoDMModal() {
            document.getElementById('coDMModal').classList.remove('active');
            document.getElementById('coDMError').classList.remove('show');
        }
        function coDMLogin(e) {
            e.preventDefault();
            const name = document.getElementById('coDMName').value.trim();
            const code = document.getElementById('coDMRoomCode').value.trim();
            const pass = document.getElementById('coDMPass').value;
            const dmCreds = getDMCredentials();
            const validPass = dmCreds.pass || 'FracturedSky2025!';
            if (pass !== validPass) {
                document.getElementById('coDMError').classList.add('show');
                return;
            }
            closeCoDMModal();
            joinAsCoDM(name, code);
        }
        function joinAsCoDM(name, code) {
            isDM = true;
            isCoDM = true;
            myName = name;
            roomCode = code;
            // Remember for automatic reconnects
            coDMOriginalCode = code;
            coDMOriginalName = name;
            clearTimeout(coDMReconnectTimer);

            function doConnect(targetPeerId) {
                if (peer && !peer.destroyed) { try { peer.destroy(); } catch(e) {} }
                peer = new Peer();
                peer.on('open', (id) => {
                    myId = id;
                    hostDMConn = peer.connect(targetPeerId);
                    setupConnection(hostDMConn, false); // isPlayer=false â†’ DM-side connection

                    // Give the host up to 12 s to answer; schedule reconnect if it doesn't.
                    const connTimeout = setTimeout(() => {
                        updateConnectionStatus('Host not reachable â€” retrying...', false);
                        coDMReconnectTimer = setTimeout(coDMAutoReconnect, 5000);
                    }, 12000);

                    hostDMConn.on('open', () => {
                        clearTimeout(connTimeout);
                        sendToPeer(hostDMConn, { type: 'coDMJoinRequest', name, peerId: myId });
                        document.getElementById('welcomeScreen').classList.add('hidden');
                        document.getElementById('connectionTabContainer').style.display = 'block';
                        updateConnectionStatus('Connecting as Co-DM...', false);
                    });
                    hostDMConn.on('error', () => {
                        clearTimeout(connTimeout);
                        updateConnectionStatus('Co-DM connection failed â€” retrying...', false);
                        coDMReconnectTimer = setTimeout(coDMAutoReconnect, 5000);
                    });
                });
                peer.on('error', () => {
                    updateConnectionStatus('Peer error â€” retrying...', false);
                    coDMReconnectTimer = setTimeout(coDMAutoReconnect, 5000);
                });
            }

            // Look up the host DM's current live peer ID from Firebase first,
            // in case they refreshed and got a new peer ID since we last connected.
            if (fbDb) {
                updateConnectionStatus('Co-DM: Looking up host...', false);
                firebaseSignIn().then(() => {
                    return fbDb.collection('vtt_rooms').doc(code).get();
                }).then(doc => {
                    const livePeerId = doc.exists && doc.data() && doc.data().currentPeerId;
                    doConnect(livePeerId || code);
                }).catch(() => doConnect(code));
            } else {
                doConnect(code);
            }
        }

        function setupConnection(conn, isPlayer = false) {
            conn.on('data', (data) => handleMessage(conn, data));

            function onConnOpen() {
                if (!isPlayer) {
                    connections.set(conn.peer, { conn, name: 'Unknown', role: 'player', approved: false });
                } else {
                    connections.set(conn.peer, { conn, name: 'Dungeon Master', role: 'dm', approved: true });
                }
                updateUserList();
            }

            // PeerJS can fire 'connection' after the DataChannel is already
            // open, meaning conn.on('open') would never fire. Guard against
            // that race by running onConnOpen immediately if already open.
            if (conn.open) {
                onConnOpen();
            } else {
                conn.on('open', onConnOpen);
            }

            conn.on('close', () => {
                connections.delete(conn.peer);
                updateUserList();
                if (isCoDM && conn === hostDMConn) {
                    // Co-DM lost its connection to the host DM â€” reconnect via Firebase
                    updateConnectionStatus('Host DM disconnected â€” reconnecting...', false);
                    clearTimeout(coDMReconnectTimer);
                    coDMReconnectTimer = setTimeout(coDMAutoReconnect, 3000);
                } else if (isPlayer) {
                    // Regular player lost connection to DM
                    updateConnectionStatus('Disconnected â€” reconnecting...', false);
                    stopFirebaseWatch(); // will be restarted inside playerAutoReconnect
                    setTimeout(playerAutoReconnect, 3000);
                }
            });
        }

        function handleMessage(conn, data) {
            switch (data.type) {
                // --- Co-DM handshake ---
                case 'coDMJoinRequest':
                    if (isDM && !isCoDM) {
                        // Accept co-DM: give them full game state + co-DM role
                        const connData = connections.get(conn.peer);
                        if (connData) {
                            connData.name = data.name + ' (Co-DM)';
                            connData.role = 'co-dm';
                            connData.approved = true;
                        }
                        coDMs.set(conn.peer, conn);
                        sendToPeer(conn, { type: 'coDMApproved', name: data.name, roomCode });
                        sendGameState(conn);
                        updateUserList();
                    }
                    break;

                case 'coDMApproved':
                    // We are the co-DM, host approved us
                    myName = data.name + ' (Co-DM)';
                    roomCode = data.roomCode;
                    document.getElementById('roomCodeSection').style.display = 'block';
                    document.getElementById('roomCode').textContent = roomCode;
                    document.getElementById('dmControlsBtn').style.display = 'block';
                    document.getElementById('musicToggleBtn').style.display = 'block';
                    document.getElementById('stagingZone').style.display = 'flex';
                    document.getElementById('diceRollerBtn').classList.add('visible');
                    document.getElementById('diceRollLog').classList.add('visible');
                    showDiceAdvantagePanel();
                    updateConnectionStatus('Connected as Co-DM', true);
                    updateUserList();
                    initMusicPanel();
                    break;

                case 'coDMBroadcast':
                    // Host DM receives a change from a co-DM, applies it and re-broadcasts
                    if (isDM && !isCoDM) {
                        handleIncomingChange(data.payload);
                        // Re-broadcast to every approved client EXCEPT the originating
                        // co-DM â€” this includes players AND other co-DMs so they all
                        // stay in sync when multiple co-DMs are connected.
                        const originPeer = conn.peer;
                        connections.forEach(({ conn: c, approved }) => {
                            if (approved && c.peer !== originPeer) sendToPeer(c, data.payload);
                        });
                    }
                    break;

                case 'playerJoinRequest':
                    if (isDM) {
                        // Auto-approve players whose name was previously approved (handles restarts too)
                        if (approvedPlayerNames.has(data.name)) {
                            // Connection entry may not exist yet if the data message
                            // arrived before PeerJS fired conn.on('open') (race condition).
                            let connData = connections.get(conn.peer);
                            if (!connData) {
                                connData = { conn, name: data.name, role: 'player', approved: false };
                                connections.set(conn.peer, connData);
                            }
                            connData.approved = true;
                            connData.name = data.name;
                            sendToPeer(conn, { type: 'playerApproved', name: data.name, canonicalRoomId: firebaseRoomRef || roomCode });
                            sendGameState(conn);
                            updateUserList();
                            console.log('âœ… Auto-approved reconnecting player:', data.name);
                        } else {
                            pendingRequests.push({
                                peerId: conn.peer,
                                name: data.name,
                                conn: conn
                            });
                            showJoinToast(data.name);
                            renderPendingRequests();
                        }
                    }
                    break;
                    
                case 'playerApproved':
                    // Successfully joined â€” stop watching Firebase for peer ID changes.
                    stopFirebaseWatch();
                    myName = data.name;
                    // Keep roomCode as the DM's live peer ID for this session's P2P use.
                    roomCode = conn.peer;
                    // But persist the *canonical* room ID (sent by the DM) so that after
                    // future DM refreshes the player watches the same Firebase doc that
                    // the DM always writes its new peer ID to. Saving conn.peer here
                    // caused the watch chain to drift and the room to "die" after 2 refreshes.
                    playerFirebaseRoomId = data.canonicalRoomId || conn.peer;
                    loadAndListenDiceRolls(playerFirebaseRoomId);
                    localStorage.setItem('fracturedSkyPlayerRoom', data.canonicalRoomId || conn.peer);
                    localStorage.setItem('fracturedSkyPlayerName', myName);
                    // Keep sessionStorage in sync so refresh always uses the canonical room ID.
                    sessionStorage.setItem('fracturedSkyTabRole', 'player');
                    sessionStorage.setItem('fracturedSkyPlayerRoom', data.canonicalRoomId || conn.peer);
                    updateConnectionStatus('Connected to room', true);
                    requestGameState(conn);
                    document.getElementById('welcomeScreen').classList.add('hidden');
                    document.getElementById('welcomeReconnect').style.display = 'none';
                    document.getElementById('welcomeButtons').style.display = 'none';
                    document.getElementById('startFreshBtn').style.display = 'none';
                    document.getElementById('playerPanelContainer').style.display = 'block';
                    document.getElementById('diceRollerBtn').classList.add('visible');
                    document.getElementById('diceRollLog').classList.add('visible');
                    showDiceAdvantagePanel();
                    savePlayerState();
                    break;
                    
                case 'playerRejected':
                    alert('Your join request was denied by the DM.');
                    break;
                    
                case 'tokenRequest':
                    if (isDM) {
                        // Add to pending requests
                        pendingRequests.push({
                            type: 'token',
                            peerId: conn.peer,
                            name: data.playerName,
                            tokenData: data.tokenData,
                            conn: conn
                        });
                        showJoinToast(`${data.playerName} wants a token`);
                        renderPendingRequests();
                    }
                    break;
                    
                case 'tokenApproved':
                    // Token was approved, add to staging
                    stagingTokens.push(data.token);
                    renderStagingTokens();
                    break;
                    
                case 'requestState':
                    // Player asking DM to send the full game state (sent right after playerApproved)
                    if (isDM) sendGameState(conn);
                    break;

                case 'gameState':
                    loadGameState(data.state);
                    break;
                    
                case 'gridUpdate':
                    updateGridFromNetwork(data);
                    break;
                    
                case 'tokenUpdate':
                    // Separate staging and placed tokens
                    stagingTokens = [];
                    placedTokens = [];
                    
                    data.tokens.forEach(token => {
                        if (token.x !== undefined && token.y !== undefined) {
                            // Has position = placed token
                            placedTokens.push(token);
                        } else {
                            // No position = staging token
                            stagingTokens.push(token);
                        }
                    });
                    
                    console.log('ðŸŽ² Token update:', stagingTokens.length, 'staging,', placedTokens.length, 'placed');
                    renderStagingTokens();
                    draw();
                    break;
                    
                case 'fogUpdate':
                    updateFogFromNetwork(data);
                    break;
                    
                case 'imagesUpdate':
                    placedImages = [];
                    data.images.forEach(imgData => {
                        const img = new Image();
                        img.onload = () => {
                            placedImages.push({
                                img: img,
                                x: imgData.x,
                                y: imgData.y,
                                width: imgData.width,
                                height: imgData.height,
                                rotation: imgData.rotation,
                                gridX: imgData.gridX,
                                gridY: imgData.gridY
                            });
                            draw();
                        };
                        img.src = imgData.src;
                    });
                    break;

                case 'musicCue':
                    if (isCoDM) {
                        // Co-DM relays musicCue to its own approved players
                        connections.forEach(({ conn: c, approved, role }) => {
                            if (approved && role === 'player') sendToPeer(c, data);
                        });
                    } else if (!isDM) {
                        // Player plays the cued track
                        const track = MUSIC_TRACKS.find(t => t.id === data.trackId);
                        const audio = document.getElementById('musicAudio');
                        if (track) {
                            audio.src = track.file;
                            audio.volume = 0.6;
                            audio.play().catch(() => {});
                            const notice = document.createElement('div');
                            notice.style.cssText = 'position:fixed;bottom:70px;left:50%;transform:translateX(-50%);background:var(--bg-card);border:1px solid var(--accent);padding:0.5rem 1rem;border-radius:8px;font-size:0.8rem;z-index:9999;pointer-events:none;';
                            notice.textContent = `${track.emoji} DM playing: ${track.label}`;
                            document.body.appendChild(notice);
                            setTimeout(() => notice.remove(), 4500);
                        } else {
                            audio.pause();
                        }
                    }
                    break;

                case 'diceRoll':
                    // Re-broadcast from DM to all, then display
                    if (isDM && !isCoDM) {
                        connections.forEach(({ conn: c, approved }) => {
                            if (approved && c.peer !== conn.peer) sendToPeer(c, data);
                        });
                    }
                    showDiceResult(data.result, data.rollerName, false, data.rollId, data.bonus || 0, data.advLabel || null);
                    break;
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Delete selected image
            if (e.key === 'Delete' && selectedImage && isDM) {
                const index = placedImages.indexOf(selectedImage);
                if (index > -1) {
                    placedImages.splice(index, 1);
                    selectedImage = null;
                    draw();
                    broadcastImages();
                }
            }
        });

        function sendToPeer(conn, data) {
            if (!conn || !conn.open) return;
            try {
                conn.send(data);
            } catch (err) {
                console.error('Send error:', err);
            }
        }

        function broadcast(data) {
            if (isCoDM && hostDMConn) {
                // Co-DM: route through host DM who will re-broadcast to players
                sendToPeer(hostDMConn, { type: 'coDMBroadcast', payload: data });
            } else {
                // Host DM: broadcast directly to approved players and co-DMs
                connections.forEach(({ conn, approved }) => {
                    if (approved) sendToPeer(conn, data);
                });
            }
            scheduleSave();
        }

        // Apply an incoming state change from a co-DM without re-broadcasting
        function handleIncomingChange(data) {
            switch (data.type) {
                case 'gridUpdate':     updateGridFromNetwork(data); updateMinimap(); break;
                case 'tokenUpdate':
                    stagingTokens = [];
                    placedTokens = [];
                    (data.tokens || []).forEach(t => {
                        if (t.x !== undefined) placedTokens.push(t);
                        else stagingTokens.push(t);
                    });
                    renderStagingTokens(); draw();
                    break;
                case 'fogUpdate':      updateFogFromNetwork(data); break;
                case 'imagesUpdate':
                    placedImages = [];
                    (data.images || []).forEach(imgData => {
                        const img = new Image();
                        img.onload = () => { placedImages.push({ img, x:imgData.x, y:imgData.y, width:imgData.width, height:imgData.height, rotation:imgData.rotation, gridX:imgData.gridX, gridY:imgData.gridY }); draw(); };
                        img.src = imgData.src;
                    });
                    break;
                case 'diceRoll':
                    showDiceResult(data.result, data.rollerName, false, data.rollId, data.bonus || 0, data.advLabel || null);
                    break;
                // --- Landmark stamps ---
                case 'stampUpdate':
                    placedStamps = data.placedStamps || [];
                    draw();
                    break;
                case 'subMapUpdate':
                    if (data.stampId && data.imageData) {
                        const img = new Image();
                        img.onload = () => {
                            const c = document.createElement('canvas');
                            c.width = 800; c.height = 500;
                            c.getContext('2d').drawImage(img, 0, 0);
                            stampSubMaps[data.stampId] = c;
                            startGlowAnimation();
                            draw();
                        };
                        img.src = data.imageData;
                    }
                    break;
            }
        }

        function approvePlayer(index) {
            const request = pendingRequests[index];
            if (!request || request.type === 'token') return;

            // Ensure the connection entry exists â€” it may not if the data message
            // (playerJoinRequest) arrived before PeerJS fired conn.on('open') on
            // the DM side (a known PeerJS race condition).
            let connData = connections.get(request.peerId);
            if (!connData) {
                connData = { conn: request.conn, name: request.name, role: 'player', approved: false };
                connections.set(request.peerId, connData);
            }
            connData.approved = true;
            connData.name = request.name;
            approvedPlayerNames.add(request.name);
            localStorage.setItem('fracturedSkyApprovedNames', JSON.stringify([...approvedPlayerNames]));

            sendToPeer(request.conn, {
                type: 'playerApproved',
                name: request.name,
                canonicalRoomId: firebaseRoomRef || roomCode
            });

            sendGameState(request.conn);
            
            pendingRequests.splice(index, 1);
            renderPendingRequests();
            updateUserList();
        }

        function rejectPlayer(index) {
            const request = pendingRequests[index];
            if (!request || request.type === 'token') return;
            
            sendToPeer(request.conn, { type: 'playerRejected' });
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function approveToken(index) {
            const request = pendingRequests[index];
            if (!request || request.type !== 'token') return;
            
            const token = {
                ...request.tokenData,
                owner: request.name,
                approved: true
            };
            
            stagingTokens.push(token);
            renderStagingTokens();
            
            sendToPeer(request.conn, {
                type: 'tokenApproved',
                token: token
            });
            
            broadcast({
                type: 'tokenUpdate',
                tokens: [...stagingTokens, ...placedTokens]
            });
            
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function rejectToken(index) {
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function showJoinToast(name) {
            // Persistent banner at top of screen â€” DM cannot miss it
            const existing = document.getElementById('joinToast');
            if (existing) existing.remove();
            const toast = document.createElement('div');
            toast.id = 'joinToast';
            toast.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#f59e0b;color:#1a1a2e;text-align:center;padding:0.75rem 1rem;font-weight:700;font-size:1rem;z-index:99999;cursor:pointer;letter-spacing:0.05em;';
            toast.innerHTML = `ðŸ”” PLAYER REQUEST: <strong>${name}</strong> wants to join â€” click here or open DM Controls`;
            toast.onclick = () => {
                toast.remove();
                const panel = document.getElementById('dmPanel');
                if (panel && !panel.classList.contains('open')) panel.classList.add('open');
                const dmContent = document.querySelector('.dm-content');
                if (dmContent) dmContent.scrollTop = 0;
            };
            document.body.prepend(toast);
        }

        function renderPendingRequests() {
            const container = document.getElementById('pendingRequests');

            if (pendingRequests.length === 0) {
                container.innerHTML = '<p style="font-size: 0.85rem; color: var(--text-dim);">No pending requests</p>';
                const btn = document.getElementById('dmControlsBtn');
                if (btn) btn.textContent = 'ðŸŽ­ DM Controls';
                const toast = document.getElementById('joinToast');
                if (toast) toast.remove();
                return;
            }

            // Badge the header button, force-open the DM panel, scroll to top
            const btn = document.getElementById('dmControlsBtn');
            if (btn) btn.textContent = `ðŸŽ­ DM Controls (${pendingRequests.length}) ðŸ””`;
            const panel = document.getElementById('dmPanel');
            if (panel && !panel.classList.contains('open')) {
                panel.classList.add('open');
            }
            // Always scroll DM panel to top so Player Requests is visible
            const dmContent = document.querySelector('.dm-content');
            if (dmContent) dmContent.scrollTop = 0;
            
            container.innerHTML = pendingRequests.map((req, idx) => {
                if (req.type === 'token') {
                    return `
                        <div class="request-item">
                            <div class="request-info">
                                <div class="request-name">${req.name}</div>
                                <div class="request-detail">Token: ${req.tokenData.icon || 'ðŸ–¼ï¸ image'}</div>
                            </div>
                            <div class="request-actions">
                                <button class="btn btn-small btn-success" onclick="approveToken(${idx})">âœ“</button>
                                <button class="btn btn-small btn-danger" onclick="rejectToken(${idx})">âœ•</button>
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="request-item">
                            <div class="request-info">
                                <div class="request-name">${req.name}</div>
                                <div class="request-detail">Wants to join</div>
                            </div>
                            <div class="request-actions">
                                <button class="btn btn-small btn-success" onclick="approvePlayer(${idx})">âœ“</button>
                                <button class="btn btn-small btn-danger" onclick="rejectPlayer(${idx})">âœ•</button>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }

        function sendGameState(conn) {
            const gridData = {};
            for (let key in gridCells) {
                gridData[key] = gridCells[key].toDataURL();
            }
            
            const fogData = {};
            for (let group in fogGroups) {
                fogData[group] = fogGroups[group].canvas.toDataURL();
            }
            
            // Serialize placed images
            const imagesData = placedImages.map(pi => ({
                src: pi.img.src,
                x: pi.x,
                y: pi.y,
                width: pi.width,
                height: pi.height,
                rotation: pi.rotation,
                gridX: pi.gridX,
                gridY: pi.gridY
            }));
            
            // Serialize stamp sub-maps
            const subMapsData = {};
            for (const sid in stampSubMaps) {
                subMapsData[sid] = stampSubMaps[sid].toDataURL();
            }

            sendToPeer(conn, {
                type: 'gameState',
                state: {
                    gridCells: gridData,
                    lockedCells,
                    fogGroups: fogData,
                    tokens: [...stagingTokens, ...placedTokens],
                    placedImages: imagesData,
                    placedStamps,
                    stampSubMaps: subMapsData,
                    zoom,
                    panX,
                    panY
                }
            });
            
            console.log('ðŸ“¤ Sent game state:', stagingTokens.length + placedTokens.length, 'tokens,', imagesData.length, 'images');
        }

        function requestGameState(conn) {
            sendToPeer(conn, { type: 'requestState' });
        }

        function loadGameState(state) {
            console.log('ðŸ“¥ Loading game state...');
            
            // Load grid
            gridCells = {};
            for (let key in state.gridCells) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = CELL_SIZE;
                    canvas.height = CELL_SIZE;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    gridCells[key] = canvas;
                    draw();
                };
                img.src = state.gridCells[key];
            }
            
            // Load fog
            for (let group in state.fogGroups) {
                if (!fogGroups[group]) {
                    fogGroups[group] = { name: group, canvas: document.createElement('canvas') };
                    fogGroups[group].canvas.width = GRID_SIZE * 3;
                    fogGroups[group].canvas.height = GRID_SIZE * 3;
                }
                const img = new Image();
                img.onload = () => {
                    const ctx = fogGroups[group].canvas.getContext('2d');
                    ctx.clearRect(0, 0, fogGroups[group].canvas.width, fogGroups[group].canvas.height);
                    ctx.drawImage(img, 0, 0);
                    draw();
                };
                img.src = state.fogGroups[group];
            }
            
            // Load tokens (IMPORTANT!)
            if (state.tokens) {
                stagingTokens = [];
                placedTokens = [];
                
                state.tokens.forEach(token => {
                    // Separate staging vs placed tokens
                    if (token.x !== undefined && token.y !== undefined) {
                        // It's a placed token
                        placedTokens.push(token);
                    } else {
                        // It's a staging token
                        stagingTokens.push(token);
                    }
                });
                
                console.log('âœ… Loaded tokens:', stagingTokens.length, 'staging,', placedTokens.length, 'placed');
                renderStagingTokens();
            }
            
            // Load placed images if present
            if (state.placedImages) {
                placedImages = [];
                state.placedImages.forEach(imgData => {
                    const img = new Image();
                    img.onload = () => {
                        placedImages.push({
                            img: img,
                            x: imgData.x,
                            y: imgData.y,
                            width: imgData.width,
                            height: imgData.height,
                            rotation: imgData.rotation,
                            gridX: imgData.gridX,
                            gridY: imgData.gridY
                        });
                        draw();
                    };
                    img.src = imgData.src;
                });
            }
            
            // Load placed stamps
            if (state.placedStamps) {
                placedStamps = state.placedStamps;
            }

            // Load stamp sub-maps
            if (state.stampSubMaps) {
                for (const sid in state.stampSubMaps) {
                    const img = new Image();
                    img.onload = () => {
                        const c = document.createElement('canvas');
                        c.width = 800; c.height = 500;
                        c.getContext('2d').drawImage(img, 0, 0);
                        stampSubMaps[sid] = c;
                        startGlowAnimation();
                        draw();
                    };
                    img.src = state.stampSubMaps[sid];
                }
            }

            lockedCells = state.lockedCells || {};
            zoom = state.zoom || 1;
            panX = state.panX || 0;
            panY = state.panY || 0;

            document.getElementById('zoomSlider').value = zoom * 100;
            document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';

            draw();
            updateMinimap();
        }

        function updateGridFromNetwork(data) {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = CELL_SIZE;
                canvas.height = CELL_SIZE;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                gridCells[`${data.cellX},${data.cellY}`] = canvas;
                draw();
                updateMinimap();
            };
            img.src = data.imageData;
        }

        function updateFogFromNetwork(data) {
            console.log('ðŸŒ«ï¸ Received fog update for group:', data.group);
            if (fogGroups[data.group]) {
                const img = new Image();
                img.onload = () => {
                    const ctx = fogGroups[data.group].canvas.getContext('2d');
                    ctx.clearRect(0, 0, fogGroups[data.group].canvas.width, fogGroups[data.group].canvas.height);
                    ctx.drawImage(img, 0, 0);
                    draw();
                    console.log('âœ… Fog updated on canvas');
                };
                img.onerror = () => {
                    console.error('âŒ Failed to load fog image');
                };
                img.src = data.fogData;
            } else {
                console.warn('âš ï¸ Fog group not found:', data.group);
            }
        }

        function toggleConnectionPanel() {
            const panel = document.getElementById('connectionPanel');
            const tab = document.getElementById('connectionTab');
            const arrow = document.getElementById('tabArrow');
            
            if (panel.classList.contains('open')) {
                panel.classList.remove('open');
                tab.classList.remove('open');
                arrow.textContent = 'â–¼';
            } else {
                panel.classList.add('open');
                tab.classList.add('open');
                arrow.textContent = 'â–²';
            }
        }

        function updateConnectionStatus(text, connected) {
            if (_elStatusText) _elStatusText.textContent = text;
            [_elStatusIndicator, _elTabIndicator].forEach(ind => {
                if (!ind) return;
                if (connected) ind.classList.add('connected');
                else ind.classList.remove('connected');
            });
        }

        function updateUserList() {
            const container = document.getElementById('userList');
            const users = [];
            if (isDM) users.push({ name: myName, role: isCoDM ? 'Co-DM' : 'DM' });
            connections.forEach(({ name, role, approved }) => {
                if (approved) {
                    const label = role === 'co-dm' ? 'Co-DM' : role === 'dm' ? 'DM' : 'Player';
                    users.push({ name, role: label });
                }
            });
            if (users.length === 0) {
                container.innerHTML = '<p style="font-size:0.85rem;color:var(--text-dim);">No users</p>';
                return;
            }
            container.innerHTML = users.map(u => `
                <div class="user-item">
                    <span>${u.name}</span>
                    <span class="user-role ${u.role === 'Co-DM' ? 'co-dm' : ''}">${u.role}</span>
                </div>
            `).join('');
        }

        function copyRoomCode() {
            if (!roomCode) {
                console.error('No room code to copy');
                return;
            }
            
            // Try modern clipboard API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(roomCode).then(() => {
                    const elem = document.getElementById('roomCode');
                    const old = elem.textContent;
                    elem.textContent = 'âœ“ Copied!';
                    elem.style.background = 'var(--accent)';
                    elem.style.color = 'white';
                    setTimeout(() => {
                        elem.textContent = old;
                        elem.style.background = 'var(--bg-dark)';
                        elem.style.color = 'var(--accent)';
                    }, 2000);
                    console.log('âœ… Room code copied:', roomCode);
                }).catch(err => {
                    console.error('Clipboard API failed:', err);
                    fallbackCopy();
                });
            } else {
                // Fallback for older browsers
                fallbackCopy();
            }
        }
        
        function fallbackCopy() {
            try {
                // Create temporary textarea
                const textarea = document.createElement('textarea');
                textarea.value = roomCode;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                const elem = document.getElementById('roomCode');
                const old = elem.textContent;
                elem.textContent = 'âœ“ Copied!';
                elem.style.background = 'var(--accent)';
                elem.style.color = 'white';
                setTimeout(() => {
                    elem.textContent = old;
                    elem.style.background = 'var(--bg-dark)';
                    elem.style.color = 'var(--accent)';
                }, 2000);
                console.log('âœ… Room code copied (fallback):', roomCode);
            } catch (err) {
                console.error('Copy failed:', err);
                alert('Could not copy. Room code: ' + roomCode);
            }
        }

        // === TOKENS ===
        function showTokenModal() {
            // Populate player dropdown
            const sel = document.getElementById('tokenOwner');
            sel.innerHTML = '<option value="DM">DM (unassigned)</option>';
            connections.forEach(({ name, role, approved }) => {
                if (approved && role !== 'dm') {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    sel.appendChild(opt);
                }
            });
            document.getElementById('tokenRequestModal').classList.add('active');
            setTokenType('emoji'); // Default to emoji
        }

        function closeTokenModal() {
            document.getElementById('tokenRequestModal').classList.remove('active');
            tokenImageData = null;
        }

        function setTokenType(type) {
            tokenType = type;
            
            document.getElementById('emojiTokenBtn').classList.remove('btn-primary');
            document.getElementById('imageTokenBtn').classList.remove('btn-primary');
            
            if (type === 'emoji') {
                document.getElementById('emojiTokenBtn').classList.add('btn-primary');
                document.getElementById('emojiTokenInputs').style.display = 'block';
                document.getElementById('imageTokenInputs').style.display = 'none';
            } else {
                document.getElementById('imageTokenBtn').classList.add('btn-primary');
                document.getElementById('emojiTokenInputs').style.display = 'none';
                document.getElementById('imageTokenInputs').style.display = 'block';
            }
        }

        function createToken() {
            const color = '#e74c3c';
            const owner = document.getElementById('tokenOwner').value || 'DM';

            if (tokenType === 'emoji') {
                const emoji = document.getElementById('tokenEmoji').value || 'âš”ï¸';

                if (isDM) {
                    const token = {
                        id: Date.now(),
                        type: 'emoji',
                        icon: emoji,
                        color: color,
                        size: 12, // Default size (fits in single grid square)
                        owner: owner,
                        approved: true
                    };

                    stagingTokens.push(token);
                    renderStagingTokens();
                    closeTokenModal();

                    broadcast({
                        type: 'tokenUpdate',
                        tokens: [...stagingTokens, ...placedTokens]
                    });
                }
            } else {
                // Image token
                const file = document.getElementById('tokenImageFile').files[0];
                if (!file) {
                    alert('Please select an image file');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    if (isDM) {
                        const token = {
                            id: Date.now(),
                            type: 'image',
                            imageData: e.target.result,
                            color: color,
                            size: 12, // Default size (fits in single grid square)
                            owner: owner,
                            approved: true
                        };

                        stagingTokens.push(token);
                        renderStagingTokens();
                        closeTokenModal();

                        broadcast({
                            type: 'tokenUpdate',
                            tokens: [...stagingTokens, ...placedTokens]
                        });
                    }
                };
                reader.readAsDataURL(file);
            }
        }

        function renderStagingTokens() {
            const container = document.getElementById('stagingTokens');
            container.innerHTML = stagingTokens.map(t => {
                if (t.type === 'image') {
                    return `
                        <div class="token-item" draggable="true" ondragstart="dragTokenStart(event, ${t.id})" style="background: ${t.color}; background-image: url('${t.imageData}'); background-size: cover; background-position: center;">
                            <div class="token-owner">${t.owner}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="token-item" draggable="true" ondragstart="dragTokenStart(event, ${t.id})" style="background: ${t.color};">
                            ${t.icon}
                            <div class="token-owner">${t.owner}</div>
                        </div>
                    `;
                }
            }).join('');
            
            if (stagingTokens.length > 0) {
                document.getElementById('stagingZone').style.display = 'flex';
            }
        }

        function dragTokenStart(e, tokenId) {
            const token = stagingTokens.find(t => t.id === tokenId);
            e.dataTransfer.setData('application/json', JSON.stringify(token));
            draggedToken = token;
        }

        function toggleGridSnap() {
            gridSnapEnabled = document.getElementById('gridSnap').checked;
        }

        function snapToGrid(value) {
            if (!gridSnapEnabled) return value;
            // Snap to center of grid squares instead of intersections
            // Grid squares are GRID_SNAP_SIZE x GRID_SNAP_SIZE
            // Centers are at 12.5, 37.5, 62.5, etc. (GRID_SNAP_SIZE / 2 + n * GRID_SNAP_SIZE)
            const gridCenter = GRID_SNAP_SIZE / 2;
            return Math.round((value - gridCenter) / GRID_SNAP_SIZE) * GRID_SNAP_SIZE + gridCenter;
        }

        // === DRAWING ===
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);

            // Grid cells
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const x = col * GRID_SIZE;
                    const y = row * GRID_SIZE;
                    const key = `${col},${row}`;
                    
                    ctx.fillStyle = '#1a1f2e';
                    ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                    
                    if (gridCells[key]) {
                        ctx.drawImage(gridCells[key], x, y, GRID_SIZE, GRID_SIZE);
                    }
                    
                    ctx.strokeStyle = '#2a2f3e';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                    
                    if (col === currentCellX && row === currentCellY && isDM) {
                        ctx.strokeStyle = lockedCells[key] ? '#fbbf24' : '#8b5cf6';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                    }
                }
            }

            // Grid snap lines
            if (gridSnapEnabled) {
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.15)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= GRID_SIZE * 3; x += GRID_SNAP_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, GRID_SIZE * 3);
                    ctx.stroke();
                }
                for (let y = 0; y <= GRID_SIZE * 3; y += GRID_SNAP_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(GRID_SIZE * 3, y);
                    ctx.stroke();
                }
            }

            // Placed images (DM layer)
            placedImages.forEach(pi => {
                ctx.save();
                ctx.translate(pi.x + pi.width / 2, pi.y + pi.height / 2);
                ctx.rotate(pi.rotation * Math.PI / 180);
                ctx.drawImage(pi.img, -pi.width / 2, -pi.height / 2, pi.width, pi.height);
                ctx.restore();
                
                // Draw selection handles if selected
                if (isDM && selectedImage === pi) {
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(pi.x, pi.y, pi.width, pi.height);
                    ctx.setLineDash([]);
                    
                    // Corner handles for resize
                    const handleSize = 8;
                    ctx.fillStyle = '#8b5cf6';
                    ctx.fillRect(pi.x - handleSize/2, pi.y - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(pi.x + pi.width - handleSize/2, pi.y - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(pi.x - handleSize/2, pi.y + pi.height - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(pi.x + pi.width - handleSize/2, pi.y + pi.height - handleSize/2, handleSize, handleSize);
                    
                    // Rotation handle
                    ctx.beginPath();
                    ctx.arc(pi.x + pi.width / 2, pi.y - 20, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fill();
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });

            // Placed tokens
            placedTokens.forEach(t => {
                const tokenSize = t.size || 12; // Default to 12px (fits in 25px grid square)
                const borderWidth = Math.max(2, tokenSize / 6); // Proportional border
                const fontSize = Math.max(12, tokenSize * 1.5); // Proportional font
                
                ctx.fillStyle = t.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, tokenSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = borderWidth;
                ctx.stroke();
                
                if (t.type === 'image' && t.imageData) {
                    // Use cached Image to avoid creating a new object every frame
                    let cached = tokenImageCache.get(t.id);
                    if (!cached || cached.srcKey !== t.imageData) {
                        const img = new Image();
                        img.src = t.imageData;
                        img.onload = () => draw(); // redraw once loaded
                        cached = { img, srcKey: t.imageData };
                        tokenImageCache.set(t.id, cached);
                    }
                    const img = cached.img;
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, tokenSize - 1, 0, Math.PI * 2);
                    ctx.clip();
                    const imgSize = (tokenSize - 1) * 2;
                    if (img.complete && img.naturalWidth) {
                        ctx.drawImage(img, t.x - (tokenSize - 1), t.y - (tokenSize - 1), imgSize, imgSize);
                    }
                    ctx.restore();
                } else {
                    // Draw emoji token
                    ctx.fillStyle = '#fff';
                    ctx.font = `${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(t.icon || 'âš”ï¸', t.x, t.y);
                }
            });

            // === LANDMARK STAMP GLOWS ===
            // Draw a golden pulsing glow around stamps that have a vertical illustration
            if (placedStamps.length > 0) {
                const now = Date.now();
                placedStamps.forEach(stamp => {
                    if (!stampSubMaps[stamp.id]) return; // No sub-map, no glow
                    const pulse = 0.5 + 0.5 * Math.sin(now / 480);
                    const innerR = 22;
                    const outerR = 34 + 6 * pulse;

                    // Soft radial glow
                    const grad = ctx.createRadialGradient(stamp.worldX, stamp.worldY, innerR * 0.4, stamp.worldX, stamp.worldY, outerR);
                    grad.addColorStop(0, `rgba(255,215,0,${0.45 + 0.2 * pulse})`);
                    grad.addColorStop(0.5, `rgba(255,180,0,${0.22 + 0.1 * pulse})`);
                    grad.addColorStop(1, 'rgba(255,140,0,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(stamp.worldX, stamp.worldY, outerR, 0, Math.PI * 2);
                    ctx.fill();

                    // Crisp ring border
                    ctx.strokeStyle = `rgba(255,215,0,${0.75 + 0.25 * pulse})`;
                    ctx.lineWidth = 2 + pulse;
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 8 * pulse;
                    ctx.beginPath();
                    ctx.arc(stamp.worldX, stamp.worldY, innerR, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // DM hint label
                    if (isDM) {
                        ctx.fillStyle = 'rgba(255,215,0,0.85)';
                        ctx.font = 'bold 9px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillText('DBL-CLICK', stamp.worldX, stamp.worldY + 26);
                    }
                });
            }

            ctx.restore();

            // Fog - FULLY OPAQUE for players, semi-transparent for DM
            if (fogGroups[activeFogGroup]) {
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoom, zoom);
                
                // DM sees through fog, players see full black
                if (isDM) {
                    ctx.globalAlpha = dmFogOpacity;
                } else {
                    ctx.globalAlpha = 1.0; // Full opacity for players
                }
                
                ctx.drawImage(fogGroups[activeFogGroup].canvas, 0, 0, GRID_SIZE * 3, GRID_SIZE * 3);
                ctx.restore();
            }

            updateMinimap();
        }

        // === MAP BUILDER ===
        function selectCell(x, y) {
            if (!isDM) return;
            currentCellX = x;
            currentCellY = y;
            
            const key = `${x},${y}`;
            if (gridCells[key]) {
                mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                mapCtx.drawImage(gridCells[key], 0, 0);
            } else {
                mapCtx.fillStyle = '#f5f5dc';
                mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            }
            
            updateGridDisplay();
            draw();
        }

        function updateGridDisplay() {
            if (_elCurrentCell) _elCurrentCell.textContent = gridNames[currentCellY][currentCellX];
        }

        function setTool(t) {
            // Track last tool before switching to eraser
            if (tool !== 'eraser' && t === 'eraser') {
                lastToolBeforeEraser = tool;
                // Show eraser options
                document.getElementById('eraserOptions').style.display = 'block';
                updateEraserModeUI();
            } else if (t !== 'eraser') {
                // Hide eraser options
                document.getElementById('eraserOptions').style.display = 'none';
            }
            
            // Show/hide stamp library toggle
            if (t === 'stamp') {
                document.getElementById('stampLibraryToggle').style.display = 'block';
            } else {
                document.getElementById('stampLibraryToggle').style.display = 'none';
            }
            
            // Deselect image when switching tools
            if (t !== 'select') {
                selectedImage = null;
                draw();
            }
            
            tool = t;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const toolBtn = document.getElementById(t + 'Btn');
            if (toolBtn) toolBtn.classList.add('active');
            
            const assetNames = {
                brush: 'Brush',
                fill: 'Fill',
                stamp: 'Stamp: ' + currentStamp,
                image: 'Place Image',
                select: 'Select & Move',
                eraser: eraserMode === 'content' ? 
                       (lastToolBeforeEraser === 'brush' ? 'Brush Strokes' : 
                        lastToolBeforeEraser === 'fill' ? 'Fill Areas' :
                        lastToolBeforeEraser === 'stamp' ? 'Stamps' : 'Content') :
                       'Everything'
            };
            currentAsset = assetNames[t] || t;
            (_elCurrentAsset||{}).textContent = currentAsset;
        }

        function selectStamp(emoji) {
            currentStamp = emoji;
            currentAsset = 'Stamp: ' + emoji;
            (_elCurrentAsset||{}).textContent = currentAsset;
            setTool('stamp'); // Ensure stamp tool is active
        }

        // Stamp library docking
        let stampLibraryDocked = false;
        let stampLibraryDragOffset = null;

        function toggleStampLibrary() {
            const panel = document.getElementById('stampLibraryContainer');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function closeStampLibrary() {
            document.getElementById('stampLibraryContainer').style.display = 'none';
        }

        function toggleStampLibraryCollapse() {
            document.getElementById('stampLibraryPanel').classList.toggle('collapsed');
            const btn = document.getElementById('stampCollapseBtn');
            btn.textContent = document.getElementById('stampLibraryPanel').classList.contains('collapsed') ? '+' : 'âˆ’';
        }

        function toggleStampLibraryDock() {
            stampLibraryDocked = !stampLibraryDocked;
            const container = document.getElementById('stampLibraryContainer');
            const btn = document.getElementById('stampDockBtn');
            
            if (stampLibraryDocked) {
                container.style.cursor = 'default';
                btn.textContent = 'ðŸ”’';
            } else {
                container.style.cursor = 'move';
                btn.textContent = 'ðŸ”“';
            }
        }

        // Stamp library dragging
        const stampLibraryContainer = document.getElementById('stampLibraryContainer');
        stampLibraryContainer.addEventListener('mousedown', (e) => {
            if (stampLibraryDocked) return;
            if (e.target.closest('.minimap-btn') || e.target.closest('.tool-btn')) return;
            
            stampLibraryDragOffset = {
                x: e.clientX - stampLibraryContainer.offsetLeft,
                y: e.clientY - stampLibraryContainer.offsetTop
            };
        });

        let _stampRafPending = false;
        document.addEventListener('mousemove', (e) => {
            if (!stampLibraryDragOffset || stampLibraryDocked) return;
            if (_stampRafPending) return;
            _stampRafPending = true;
            requestAnimationFrame(() => {
                _stampRafPending = false;
                if (!stampLibraryDragOffset) return;
                stampLibraryContainer.style.left = (e.clientX - stampLibraryDragOffset.x) + 'px';
                stampLibraryContainer.style.top = (e.clientY - stampLibraryDragOffset.y) + 'px';
                stampLibraryContainer.style.bottom = 'auto';
            });
        });

        document.addEventListener('mouseup', () => {
            if (stampLibraryDragOffset) {
                stampLibraryDragOffset = null;
            }
        });

        // ===================================================
        // LANDMARK SUB-MAP EDITOR / VIEWER
        // ===================================================

        function startGlowAnimation() {
            if (glowAnimating) return;
            glowAnimating = true;
            function frame() {
                const hasGlow = placedStamps.some(s => stampSubMaps[s.id]);
                if (!hasGlow) { glowAnimating = false; return; }
                draw();
                requestAnimationFrame(frame);
            }
            requestAnimationFrame(frame);
        }

        function openSubMapEditor(stampId) {
            if (!isDM) return;
            const stamp = placedStamps.find(s => s.id === stampId);
            if (!stamp) return;
            activeSubMapId = stampId;

            // Update title
            document.getElementById('subMapEditorTitle').textContent = stamp.emoji + '  Landmark Illustration';

            // Paint the existing sub-map (or blank) onto the editor canvas
            const editorCanvas = document.getElementById('subMapCanvas');
            const editorCtx = editorCanvas.getContext('2d');
            editorCtx.fillStyle = '#1a1f2e';
            editorCtx.fillRect(0, 0, editorCanvas.width, editorCanvas.height);
            if (stampSubMaps[stampId]) {
                editorCtx.drawImage(stampSubMaps[stampId], 0, 0);
            }

            setSubMapTool('brush');
            document.getElementById('subMapEditorModal').classList.add('active');
        }

        function closeSubMapEditor() {
            activeSubMapId = null;
            document.getElementById('subMapEditorModal').classList.remove('active');
        }

        function saveAndCloseSubMapEditor() {
            if (!activeSubMapId) return;
            const editorCanvas = document.getElementById('subMapCanvas');

            // Snapshot sub-map into a persistent canvas
            const snap = document.createElement('canvas');
            snap.width = editorCanvas.width;
            snap.height = editorCanvas.height;
            snap.getContext('2d').drawImage(editorCanvas, 0, 0);
            stampSubMaps[activeSubMapId] = snap;

            broadcast({ type: 'subMapUpdate', stampId: activeSubMapId, imageData: snap.toDataURL() });
            scheduleSave();
            startGlowAnimation();
            closeSubMapEditor();
            draw();
        }

        function clearSubMap() {
            const c = document.getElementById('subMapCanvas');
            const cx = c.getContext('2d');
            cx.fillStyle = '#1a1f2e';
            cx.fillRect(0, 0, c.width, c.height);
        }

        function setSubMapTool(t) {
            subMapTool = t;
            ['subMapBrushBtn', 'subMapFillBtn', 'subMapEraserBtn'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.remove('active');
            });
            const map = { brush: 'subMapBrushBtn', fill: 'subMapFillBtn', eraser: 'subMapEraserBtn' };
            if (map[t]) { const el = document.getElementById(map[t]); if (el) el.classList.add('active'); }
        }

        function openSubMapViewer(stampId) {
            const stamp = placedStamps.find(s => s.id === stampId);
            if (!stamp || !stampSubMaps[stampId]) return;

            document.getElementById('subMapViewerTitle').textContent = stamp.emoji + '  Approaching...';
            const viewerCanvas = document.getElementById('subMapViewerCanvas');
            const viewerCtx = viewerCanvas.getContext('2d');
            viewerCtx.clearRect(0, 0, viewerCanvas.width, viewerCanvas.height);
            viewerCtx.drawImage(stampSubMaps[stampId], 0, 0);
            document.getElementById('subMapViewerModal').classList.add('active');
        }

        function closeSubMapViewer() {
            document.getElementById('subMapViewerModal').classList.remove('active');
        }

        // â”€â”€ Sub-map canvas drawing events (set up once) â”€â”€
        (function setupSubMapCanvasEvents() {
            const smc = document.getElementById('subMapCanvas');
            if (!smc) return;
            const smctx = smc.getContext('2d');

            function smCoords(e) {
                const r = smc.getBoundingClientRect();
                return [
                    (e.clientX - r.left) * (smc.width / r.width),
                    (e.clientY - r.top) * (smc.height / r.height)
                ];
            }

            smc.addEventListener('mousedown', (e) => {
                if (!activeSubMapId) return;
                isSubMapDrawing = true;
                const [x, y] = smCoords(e);
                subMapLastX = x; subMapLastY = y;

                if (subMapTool === 'fill') {
                    smctx.fillStyle = subMapColor;
                    smctx.fillRect(0, 0, smc.width, smc.height);
                    isSubMapDrawing = false;
                } else if (subMapTool === 'brush') {
                    smctx.beginPath();
                    smctx.moveTo(x, y);
                    smctx.strokeStyle = subMapColor;
                    smctx.lineWidth = subMapSize;
                    smctx.lineCap = 'round';
                    smctx.lineJoin = 'round';
                } else if (subMapTool === 'eraser') {
                    smctx.save();
                    smctx.globalCompositeOperation = 'destination-out';
                    smctx.beginPath();
                    smctx.moveTo(x, y);
                    smctx.lineWidth = subMapSize * 2;
                    smctx.lineCap = 'round';
                    smctx.lineJoin = 'round';
                }
            });

            smc.addEventListener('mousemove', (e) => {
                if (!isSubMapDrawing || !activeSubMapId) return;
                const [x, y] = smCoords(e);
                if (subMapTool === 'brush' || subMapTool === 'eraser') {
                    smctx.lineTo(x, y);
                    smctx.stroke();
                }
                subMapLastX = x; subMapLastY = y;
            });

            smc.addEventListener('mouseup', () => {
                if (!isSubMapDrawing) return;
                isSubMapDrawing = false;
                if (subMapTool === 'eraser') smctx.restore();
            });

            smc.addEventListener('mouseleave', () => {
                if (!isSubMapDrawing) return;
                isSubMapDrawing = false;
                if (subMapTool === 'eraser') smctx.restore();
            });

            // Touch support for sub-map canvas
            function toMouse(touch) {
                return { clientX: touch.clientX, clientY: touch.clientY };
            }
            smc.addEventListener('touchstart', e => { e.preventDefault(); smc.dispatchEvent(new MouseEvent('mousedown', toMouse(e.touches[0]))); }, { passive: false });
            smc.addEventListener('touchmove',  e => { e.preventDefault(); smc.dispatchEvent(new MouseEvent('mousemove', toMouse(e.touches[0]))); }, { passive: false });
            smc.addEventListener('touchend',   e => { e.preventDefault(); smc.dispatchEvent(new MouseEvent('mouseup',   {})); }, { passive: false });
        })();

        // Player token functions
        let playerTokenType = 'emoji';

        function showPlayerTokenModal() {
            document.getElementById('playerTokenModal').classList.add('active');
            setPlayerTokenType('emoji');
        }

        function closePlayerTokenModal() {
            document.getElementById('playerTokenModal').classList.remove('active');
        }

        function setPlayerTokenType(type) {
            playerTokenType = type;
            
            document.getElementById('playerEmojiTokenBtn').classList.remove('btn-primary');
            document.getElementById('playerImageTokenBtn').classList.remove('btn-primary');
            
            if (type === 'emoji') {
                document.getElementById('playerEmojiTokenBtn').classList.add('btn-primary');
                document.getElementById('playerEmojiTokenInputs').style.display = 'block';
                document.getElementById('playerImageTokenInputs').style.display = 'none';
            } else {
                document.getElementById('playerImageTokenBtn').classList.add('btn-primary');
                document.getElementById('playerEmojiTokenInputs').style.display = 'none';
                document.getElementById('playerImageTokenInputs').style.display = 'block';
            }
        }

        function requestPlayerToken() {
            const color = '#3b82f6';
            
            if (playerTokenType === 'emoji') {
                const emoji = document.getElementById('playerTokenEmoji').value || 'âš”ï¸';
                
                connections.forEach(({ conn, role }) => {
                    if (role === 'dm') {
                        sendToPeer(conn, {
                            type: 'tokenRequest',
                            playerName: myName,
                            tokenData: {
                                id: Date.now(),
                                type: 'emoji',
                                icon: emoji,
                                color: color,
                                size: 12 // Default size
                            }
                        });
                    }
                });
                
                closePlayerTokenModal();
                alert('âœ… Token request sent to DM for approval!');
            } else {
                // Image token
                const file = document.getElementById('playerTokenImageFile').files[0];
                if (!file) {
                    alert('Please select an image file');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    connections.forEach(({ conn, role }) => {
                        if (role === 'dm') {
                            sendToPeer(conn, {
                                type: 'tokenRequest',
                                playerName: myName,
                                tokenData: {
                                    id: Date.now(),
                                    type: 'image',
                                    imageData: e.target.result,
                                    color: color,
                                    size: 12 // Default size
                                }
                            });
                        }
                    });
                    
                    closePlayerTokenModal();
                    alert('âœ… Token request sent to DM for approval!');
                };
                reader.readAsDataURL(file);
            }
        }

        function setStamp(emoji) {
            currentStamp = emoji;
            currentAsset = 'Stamp: ' + emoji;
            (_elCurrentAsset||{}).textContent = currentAsset;
        }

        function updateColor(value) {
            color = value;
        }

        function importMapImage(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    mapCtx.drawImage(img, 0, 0, mapCanvas.width, mapCanvas.height);
                    saveHistory();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function importImageToCanvas(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Place image at center of current cell
                    const cellX = currentCellX * GRID_SIZE + GRID_SIZE / 2;
                    const cellY = currentCellY * GRID_SIZE + GRID_SIZE / 2;
                    
                    // Scale image to fit within cell
                    const maxSize = GRID_SIZE * 0.8;
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > maxSize || height > maxSize) {
                        const scale = Math.min(maxSize / width, maxSize / height);
                        width *= scale;
                        height *= scale;
                    }
                    
                    const placedImg = {
                        img: img,
                        x: cellX - width / 2,
                        y: cellY - height / 2,
                        width: width,
                        height: height,
                        rotation: 0,
                        gridX: currentCellX,
                        gridY: currentCellY
                    };
                    
                    placedImages.push(placedImg);
                    selectedImage = placedImg;
                    setTool('select');
                    draw();
                    
                    // Broadcast to players
                    broadcastImages();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function broadcastImages() {
            const imageData = placedImages.map(pi => ({
                src: pi.img.src,
                x: pi.x,
                y: pi.y,
                width: pi.width,
                height: pi.height,
                rotation: pi.rotation,
                gridX: pi.gridX,
                gridY: pi.gridY
            }));
            
            broadcast({
                type: 'imagesUpdate',
                images: imageData
            });
        }

        function setEraserMode(mode) {
            eraserMode = mode;
            updateEraserModeUI();
            
            // Update asset indicator
            if (tool === 'eraser') {
                const assetNames = {
                    content: lastToolBeforeEraser === 'brush' ? 'Brush Strokes' : 
                             lastToolBeforeEraser === 'texture' ? 'Textures' : 
                             lastToolBeforeEraser === 'image' ? 'Images' : 'Content',
                    all: 'Everything'
                };
                currentAsset = assetNames[mode];
                (_elCurrentAsset||{}).textContent = currentAsset;
            }
        }

        function updateEraserModeUI() {
            // Update button states
            document.getElementById('eraseContentBtn').classList.remove('btn-primary');
            document.getElementById('eraseAllBtn').classList.remove('btn-primary');
            
            if (eraserMode === 'content') {
                document.getElementById('eraseContentBtn').classList.add('btn-primary');
                document.getElementById('eraserModeDesc').textContent = 'Erases drawn content without touching background';
            } else {
                document.getElementById('eraseAllBtn').classList.add('btn-primary');
                document.getElementById('eraserModeDesc').textContent = 'Erases everything including background color';
            }
        }

        function setSize(v) {
            size = v;
            document.getElementById('sizeValue').textContent = v + 'px';
        }

        function saveHistory() {
            const imageData = mapCtx.getImageData(0, 0, mapCanvas.width, mapCanvas.height);
            
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            history.push(imageData);
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
            
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                mapCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                mapCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
        }

        function clearMapCanvas() {
            mapCtx.fillStyle = '#f5f5dc';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            saveHistory();
        }

        function submitCell() {
            const key = `${currentCellX},${currentCellY}`;
            const cellCanvas = document.createElement('canvas');
            cellCanvas.width = CELL_SIZE;
            cellCanvas.height = CELL_SIZE;
            const cellCtx = cellCanvas.getContext('2d');
            cellCtx.drawImage(mapCanvas, 0, 0);
            gridCells[key] = cellCanvas;
            
            draw();
            
            broadcast({
                type: 'gridUpdate',
                cellX: currentCellX,
                cellY: currentCellY,
                imageData: cellCanvas.toDataURL()
            });
        }

        function deselectAllTools() {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            tool = null;
            currentAsset = 'None';
            (_elCurrentAsset||{}).textContent = currentAsset;
        }

        // Map canvas drawing
        mapCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = mapCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
            lastX = x;
            lastY = y;
            
            if (tool === 'brush') {
                mapCtx.beginPath();
                mapCtx.moveTo(x, y);
                mapCtx.strokeStyle = color;
                mapCtx.lineWidth = size;
                mapCtx.lineCap = 'round';
                mapCtx.lineJoin = 'round';
            } else if (tool === 'fill') {
                mapCtx.fillStyle = color;
                mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
                saveHistory();
                isDrawing = false;
            } else if (tool === 'stamp') {
                mapCtx.font = '48px Arial';
                mapCtx.textAlign = 'center';
                mapCtx.textBaseline = 'middle';
                mapCtx.fillText(currentStamp, x, y);
                saveHistory();
                // Track stamp in world space for the sub-map / landmark feature
                const worldX = currentCellX * GRID_SIZE + x;
                const worldY = currentCellY * GRID_SIZE + y;
                const stampId = 'stamp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                placedStamps.push({ id: stampId, emoji: currentStamp, worldX, worldY });
                broadcast({ type: 'stampUpdate', placedStamps });
                scheduleSave();
                isDrawing = false;
            } else if (tool === 'eraser') {
                mapCtx.save();
                
                if (eraserMode === 'content') {
                    // Erase only drawn content, not background
                    mapCtx.globalCompositeOperation = 'destination-out';
                    mapCtx.strokeStyle = 'rgba(0,0,0,1)';
                } else {
                    // Erase everything including background
                    mapCtx.globalCompositeOperation = 'source-over';
                    mapCtx.strokeStyle = '#f5f5dc'; // Match background color
                }
                
                mapCtx.beginPath();
                mapCtx.moveTo(x, y);
                mapCtx.lineWidth = size;
                mapCtx.lineCap = 'round';
                mapCtx.lineJoin = 'round';
            }
        });

        mapCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = mapCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
            
            if (tool === 'brush' || tool === 'eraser') {
                mapCtx.lineTo(x, y);
                mapCtx.stroke();
            }
        });

        mapCanvas.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                if (tool === 'eraser') {
                    mapCtx.restore(); // Restore composite operation
                }
                saveHistory();
            }
        });

        mapCanvas.addEventListener('mouseleave', () => {
            if (isDrawing) {
                isDrawing = false;
                if (tool === 'eraser') {
                    mapCtx.restore(); // Restore composite operation
                }
                saveHistory();
            }
        });

        document.getElementById('colorPicker').addEventListener('change', (e) => {
            color = e.target.value;
        });

        // Main canvas interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX;
            const screenY = e.clientY;
            const mx = (screenX - rect.left - panX) / zoom;
            const my = (screenY - rect.top - panY) / zoom;

            // === LANDMARK STAMP CLICK (players open sub-map viewer) ===
            if (!isDM && !fogMode) {
                for (const stamp of placedStamps) {
                    if (!stampSubMaps[stamp.id]) continue; // only glowing stamps
                    if (Math.hypot(mx - stamp.worldX, my - stamp.worldY) < 32) {
                        openSubMapViewer(stamp.id);
                        return;
                    }
                }
            }

            // Check if clicking on a placed token (for moving it)
            if (!fogMode && tool !== 'select') {
                for (let i = placedTokens.length - 1; i >= 0; i--) {
                    const token = placedTokens[i];
                    const tokenSize = token.size || 12;
                    const dist = Math.hypot(mx - token.x, my - token.y);
                    if (dist < tokenSize) {
                        // Check permissions: DM can move any token, players can only move their own
                        if (isDM || token.owner === myName) {
                            draggedPlacedToken = token;
                            tokenDragOffset = { x: mx - token.x, y: my - token.y };
                            console.log('ðŸŽ¯ Selected token:', token.owner, token.icon || 'image');
                            return;
                        } else {
                            console.log('ðŸš« Cannot move token owned by:', token.owner);
                            return;
                        }
                    }
                }
            }
            
            // Image selection and manipulation (Select tool ONLY)
            if (isDM && tool === 'select') {
                // Check if clicking on rotation handle
                if (selectedImage) {
                    const rotX = selectedImage.x + selectedImage.width / 2;
                    const rotY = selectedImage.y - 20;
                    if (Math.hypot(mx - rotX, my - rotY) < 10) {
                        imageResizeHandle = 'rotate';
                        imageDragStart = { x: mx, y: my };
                        return;
                    }
                    
                    // Check corner handles for resize
                    const handleSize = 8;
                    const handles = [
                        { type: 'nw', x: selectedImage.x, y: selectedImage.y },
                        { type: 'ne', x: selectedImage.x + selectedImage.width, y: selectedImage.y },
                        { type: 'sw', x: selectedImage.x, y: selectedImage.y + selectedImage.height },
                        { type: 'se', x: selectedImage.x + selectedImage.width, y: selectedImage.y + selectedImage.height }
                    ];
                    
                    for (let h of handles) {
                        if (Math.abs(mx - h.x) < handleSize && Math.abs(my - h.y) < handleSize) {
                            imageResizeHandle = h.type;
                            imageDragStart = { x: mx, y: my, origWidth: selectedImage.width, origHeight: selectedImage.height, origX: selectedImage.x, origY: selectedImage.y };
                            return;
                        }
                    }
                }
                
                // Check if clicking on an image
                for (let i = placedImages.length - 1; i >= 0; i--) {
                    const pi = placedImages[i];
                    if (mx >= pi.x && mx <= pi.x + pi.width && my >= pi.y && my <= pi.y + pi.height) {
                        selectedImage = pi;
                        imageDragStart = { x: mx, y: my, imgX: pi.x, imgY: pi.y };
                        draw();
                        return;
                    }
                }
                
                // Clicked empty space - deselect
                selectedImage = null;
                draw();
                return;
            }
            
            // Fog mode painting
            if (isDM && fogMode) {
                isFogDrawing = true;
                
                if (fogPaintMode === 'brush') {
                    paintFog(mx, my);
                } else if (fogPaintMode === 'rect') {
                    fogRectStart = { x: mx, y: my };
                }
                return;
            }
            
            // Normal panning (when not in fog mode and not using select tool)
            lastX = screenX;
            lastY = screenY;
            isDrawing = true;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX;
            const screenY = e.clientY;
            const mx = (screenX - rect.left - panX) / zoom;
            const my = (screenY - rect.top - panY) / zoom;
            
            // Token dragging
            if (draggedPlacedToken) {
                draggedPlacedToken.x = snapToGrid(mx - tokenDragOffset.x);
                draggedPlacedToken.y = snapToGrid(my - tokenDragOffset.y);
                draw();
                return;
            }
            
            // Image manipulation (Select tool only)
            if (isDM && tool === 'select' && selectedImage && imageDragStart) {
                if (imageResizeHandle === 'rotate') {
                    // Rotate around center
                    const centerX = selectedImage.x + selectedImage.width / 2;
                    const centerY = selectedImage.y + selectedImage.height / 2;
                    const angle = Math.atan2(my - centerY, mx - centerX) * 180 / Math.PI + 90;
                    selectedImage.rotation = angle;
                    draw();
                    return;
                } else if (imageResizeHandle) {
                    // Resize
                    const dx = mx - imageDragStart.x;
                    const dy = my - imageDragStart.y;
                    
                    if (imageResizeHandle === 'se') {
                        selectedImage.width = imageDragStart.origWidth + dx;
                        selectedImage.height = imageDragStart.origHeight + dy;
                    } else if (imageResizeHandle === 'nw') {
                        selectedImage.width = imageDragStart.origWidth - dx;
                        selectedImage.height = imageDragStart.origHeight - dy;
                        selectedImage.x = imageDragStart.origX + dx;
                        selectedImage.y = imageDragStart.origY + dy;
                    } else if (imageResizeHandle === 'ne') {
                        selectedImage.width = imageDragStart.origWidth + dx;
                        selectedImage.height = imageDragStart.origHeight - dy;
                        selectedImage.y = imageDragStart.origY + dy;
                    } else if (imageResizeHandle === 'sw') {
                        selectedImage.width = imageDragStart.origWidth - dx;
                        selectedImage.height = imageDragStart.origHeight + dy;
                        selectedImage.x = imageDragStart.origX + dx;
                    }
                    
                    // Minimum size
                    if (selectedImage.width < 50) selectedImage.width = 50;
                    if (selectedImage.height < 50) selectedImage.height = 50;
                    
                    draw();
                    return;
                } else {
                    // Move
                    selectedImage.x = imageDragStart.imgX + (mx - imageDragStart.x);
                    selectedImage.y = imageDragStart.imgY + (my - imageDragStart.y);
                    draw();
                    return;
                }
            }
            
            // Fog painting
            if (isDM && isFogDrawing) {
                if (fogPaintMode === 'brush') {
                    paintFog(mx, my);
                } else if (fogPaintMode === 'rect' && fogRectStart) {
                    // Just update for preview, actual painting on mouseup
                    draw();
                    
                    // Draw preview rectangle
                    ctx.save();
                    const reveal = document.getElementById('revealMode').checked;
                    ctx.strokeStyle = reveal ? '#10b981' : '#ef4444';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 5 / zoom]);
                    ctx.translate(panX, panY);
                    ctx.scale(zoom, zoom);
                    ctx.strokeRect(fogRectStart.x, fogRectStart.y, mx - fogRectStart.x, my - fogRectStart.y);
                    ctx.restore();
                }
                return;
            }
            
            // Normal panning (only when not in fog mode and not dragging anything)
            if (!isDrawing || fogMode || (isDM && tool === 'select') || draggedPlacedToken) return;
            panX += screenX - lastX;
            panY += screenY - lastY;
            lastX = screenX;
            lastY = screenY;
            draw();
        });

        canvas.addEventListener('mouseup', (e) => {
            // Token movement complete - broadcast to all
            if (draggedPlacedToken) {
                console.log('âœ… Token moved:', draggedPlacedToken.owner);
                broadcast({
                    type: 'tokenUpdate',
                    tokens: [...stagingTokens, ...placedTokens]
                });
                draggedPlacedToken = null;
                tokenDragOffset = { x: 0, y: 0 };
            }
            
            // Image manipulation complete
            if (imageDragStart) {
                imageDragStart = null;
                imageResizeHandle = null;
                broadcastImages();
            }
            
            if (isFogDrawing && fogPaintMode === 'rect' && fogRectStart) {
                const rect = canvas.getBoundingClientRect();
                const mx = (e.clientX - rect.left - panX) / zoom;
                const my = (e.clientY - rect.top - panY) / zoom;
                
                paintFogRect(fogRectStart.x, fogRectStart.y, mx, my);
                fogRectStart = null;
            }
            
            isFogDrawing = false;
            isDrawing = false;
        });

        // === DM DOUBLE-CLICK â†’ open sub-map editor for nearest stamp ===
        canvas.addEventListener('dblclick', (e) => {
            if (!isDM) return;
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left - panX) / zoom;
            const my = (e.clientY - rect.top - panY) / zoom;

            // Find nearest placed stamp within 32px world-space radius
            let closest = null, closestDist = 32;
            for (const stamp of placedStamps) {
                const d = Math.hypot(mx - stamp.worldX, my - stamp.worldY);
                if (d < closestDist) { closest = stamp; closestDist = d; }
            }
            if (closest) openSubMapEditor(closest.id);
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!draggedToken) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = snapToGrid((e.clientX - rect.left - panX) / zoom);
            const y = snapToGrid((e.clientY - rect.top - panY) / zoom);
            
            const placedToken = {
                ...draggedToken,
                x,
                y
            };
            
            placedTokens.push(placedToken);
            stagingTokens = stagingTokens.filter(t => t.id !== draggedToken.id);
            
            renderStagingTokens();
            draw();
            
            broadcast({
                type: 'tokenUpdate',
                tokens: [...stagingTokens, ...placedTokens]
            });
            
            draggedToken = null;
        });

        // === SCROLL-WHEEL ZOOM (zooms toward mouse cursor) ===
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // World coordinates of the mouse before zoom
            const worldX = (mouseX - panX) / zoom;
            const worldY = (mouseY - panY) / zoom;

            const factor = e.deltaY < 0 ? 1.1 : 0.909;
            const newZoom = Math.min(3.0, Math.max(0.25, zoom * factor));

            // Adjust pan so the world point stays under the cursor
            panX = mouseX - worldX * newZoom;
            panY = mouseY - worldY * newZoom;
            zoom = newZoom;

            const sliderVal = Math.round(zoom * 100);
            document.getElementById('zoomSlider').value = sliderVal;
            document.getElementById('zoomValue').textContent = sliderVal + '%';
            draw();
        }, { passive: false });

        // === FOG ===
        function showFogGroupModal() {
            document.getElementById('fogGroupModal').classList.add('active');
        }

        function closeFogGroupModal() {
            document.getElementById('fogGroupModal').classList.remove('active');
        }

        function createFogGroup() {
            const name = document.getElementById('fogGroupName').value.trim();
            if (!name) return;
            
            const id = 'group_' + Date.now();
            const fogCanvas = document.createElement('canvas');
            fogCanvas.width = GRID_SIZE * 3;
            fogCanvas.height = GRID_SIZE * 3;
            const fogCtx = fogCanvas.getContext('2d');
            fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Full opacity black fog
            fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
            
            fogGroups[id] = { name, canvas: fogCanvas };
            renderFogGroups();
            closeFogGroupModal();
            
            document.getElementById('fogGroupName').value = '';
        }

        function renderFogGroups() {
            const container = document.getElementById('fogGroups');
            container.innerHTML = Object.keys(fogGroups).map(id => `
                <div class="fog-group-item ${activeFogGroup === id ? 'active' : ''}">
                    <span class="fog-group-name">${fogGroups[id].name}</span>
                    <button class="btn btn-small ${activeFogGroup === id ? 'btn-primary' : ''}" onclick="setActiveFogGroup('${id}')">
                        ${activeFogGroup === id ? 'Active' : 'Select'}
                    </button>
                </div>
            `).join('');
        }

        function setActiveFogGroup(groupId) {
            activeFogGroup = groupId;
            renderFogGroups();
            draw();
        }

        function setFogPaintMode(mode) {
            fogPaintMode = mode;
            document.getElementById('fogBrushBtn').classList.remove('btn-primary');
            document.getElementById('fogRectBtn').classList.remove('btn-primary');
            
            if (mode === 'brush') {
                document.getElementById('fogBrushBtn').classList.add('btn-primary');
            } else {
                document.getElementById('fogRectBtn').classList.add('btn-primary');
            }
        }

        function toggleFogMode() {
            if (!isDM) return;
            
            fogMode = !fogMode;
            const btn = document.getElementById('fogModeToggle');
            const controls = document.getElementById('fogControls');
            
            if (fogMode) {
                // FOG MODE ON - Orange button
                btn.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
                btn.style.borderColor = '#f97316';
                btn.textContent = 'ðŸŒ«ï¸ Fog Paint Mode: ON';
                controls.style.opacity = '1';
                controls.style.pointerEvents = 'all';
            } else {
                // FOG MODE OFF - Purple button
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.classList.add('btn-primary');
                btn.textContent = 'ðŸŒ«ï¸ Fog Paint Mode: OFF';
                controls.style.opacity = '0.5';
                controls.style.pointerEvents = 'none';
            }
        }

        function updateFogSize(value) {
            fogBrushSize = parseInt(value);
            document.getElementById('fogSizeValue').textContent = value + 'px';
        }

        function resetFog() {
            if (!isDM) return;
            if (!confirm('Reset all fog for the active group?')) return;
            
            if (fogGroups[activeFogGroup]) {
                const ctx = fogGroups[activeFogGroup].canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,1)';
                ctx.fillRect(0, 0, fogGroups[activeFogGroup].canvas.width, fogGroups[activeFogGroup].canvas.height);
                draw();
                
                broadcast({
                    type: 'fogUpdate',
                    group: activeFogGroup,
                    fogData: fogGroups[activeFogGroup].canvas.toDataURL()
                });
            }
        }

        function paintFog(x, y) {
            if (!isDM || !fogGroups[activeFogGroup]) return;
            
            const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
            const reveal = document.getElementById('revealMode').checked;
            
            fogCtx.save();
            
            if (reveal) {
                // Erase fog (reveal map)
                fogCtx.globalCompositeOperation = 'destination-out';
                fogCtx.fillStyle = 'rgba(0,0,0,1)';
            } else {
                // Add fog (hide map)
                fogCtx.globalCompositeOperation = 'source-over';
                fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Changed to full opacity
            }
            
            fogCtx.beginPath();
            fogCtx.arc(x, y, fogBrushSize, 0, Math.PI * 2);
            fogCtx.fill();
            fogCtx.restore();
            
            draw();
            
            // Broadcast fog update in real-time (every brush stroke)
            broadcastFog();
        }

        function paintFogRect(x1, y1, x2, y2) {
            if (!isDM || !fogGroups[activeFogGroup]) return;
            
            const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
            const reveal = document.getElementById('revealMode').checked;
            
            fogCtx.save();
            
            if (reveal) {
                fogCtx.globalCompositeOperation = 'destination-out';
                fogCtx.fillStyle = 'rgba(0,0,0,1)';
            } else {
                fogCtx.globalCompositeOperation = 'source-over';
                fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Changed to full opacity
            }
            
            const width = x2 - x1;
            const height = y2 - y1;
            fogCtx.fillRect(x1, y1, width, height);
            fogCtx.restore();
            
            draw();
            
            // Broadcast fog update
            broadcastFog();
        }

        function broadcastFog() {
            if (!isDM) return;
            
            // Clear any pending broadcast
            if (fogBroadcastTimeout) {
                clearTimeout(fogBroadcastTimeout);
            }
            
            // Throttle broadcasts to every 100ms for smooth real-time updates
            fogBroadcastTimeout = setTimeout(() => {
                const fogData = fogGroups[activeFogGroup].canvas.toDataURL();
                console.log('ðŸ“¡ Broadcasting fog update, size:', fogData.length, 'bytes');
                
                broadcast({
                    type: 'fogUpdate',
                    group: activeFogGroup,
                    fogData: fogData
                });
                
                fogBroadcastTimeout = null;
            }, 100);
        }

        // Initialize fog mode buttons
        setFogPaintMode('brush');

        // === CAMPAIGN EXPORT/IMPORT ===
        function exportCampaign() {
            if (!isDM) return;
            
            // Serialize grid cells
            const gridData = {};
            for (let key in gridCells) {
                gridData[key] = gridCells[key].toDataURL();
            }
            
            // Serialize fog groups
            const fogData = {};
            for (let group in fogGroups) {
                fogData[group] = {
                    name: fogGroups[group].name,
                    canvas: fogGroups[group].canvas.toDataURL()
                };
            }
            
            // Serialize placed images
            const imagesData = placedImages.map(pi => ({
                src: pi.img.src,
                x: pi.x,
                y: pi.y,
                width: pi.width,
                height: pi.height,
                rotation: pi.rotation,
                gridX: pi.gridX,
                gridY: pi.gridY
            }));
            
            // Get player data
            const playerData = [];
            connections.forEach(({ name, role, approved }, peerId) => {
                if (approved) {
                    playerData.push({ name, role, peerId });
                }
            });
            
            const campaignData = {
                version: '4.0',
                name: campaignName,
                sessionId: roomCode,
                exported: new Date().toISOString(),
                gridCells: gridData,
                lockedCells: lockedCells,
                fogGroups: fogData,
                activeFogGroup: activeFogGroup,
                stagingTokens: stagingTokens,
                placedTokens: placedTokens,
                placedImages: imagesData,
                playerData: playerData,
                zoom: zoom,
                panX: panX,
                panY: panY,
                currentCellX: currentCellX,
                currentCellY: currentCellY,
                gridSnapEnabled: gridSnapEnabled
            };
            
            // Create downloadable file
            const dataStr = JSON.stringify(campaignData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `${campaignData.name.replace(/[^a-z0-9]/gi, '_')}_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            document.getElementById('exportSuccess').classList.add('show');
            setTimeout(() => {
                document.getElementById('exportSuccess').classList.remove('show');
            }, 3000);
            
            console.log('âœ… Campaign exported:', campaignData.name);
            console.log('Includes:', playerData.length, 'players,', stagingTokens.length + placedTokens.length, 'tokens');
        }
        
        function importCampaign(event) {
            if (!isDM) return;
            
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (!data.version || !data.gridCells) {
                        throw new Error('Invalid campaign file format');
                    }
                    
                    // Load grid cells
                    gridCells = {};
                    let cellsLoaded = 0;
                    const totalCells = Object.keys(data.gridCells).length;
                    
                    for (let key in data.gridCells) {
                        const img = new Image();
                        img.onload = () => {
                            const cellCanvas = document.createElement('canvas');
                            cellCanvas.width = CELL_SIZE;
                            cellCanvas.height = CELL_SIZE;
                            const cellCtx = cellCanvas.getContext('2d');
                            cellCtx.drawImage(img, 0, 0);
                            gridCells[key] = cellCanvas;
                            
                            cellsLoaded++;
                            if (cellsLoaded === totalCells) {
                                draw();
                                updateMinimap();
                            }
                        };
                        img.src = data.gridCells[key];
                    }
                    
                    // Load fog groups
                    fogGroups = {};
                    for (let group in data.fogGroups) {
                        const fogCanvas = document.createElement('canvas');
                        fogCanvas.width = GRID_SIZE * 3;
                        fogCanvas.height = GRID_SIZE * 3;
                        const fogCtx = fogCanvas.getContext('2d');
                        
                        const img = new Image();
                        img.onload = () => {
                            fogCtx.drawImage(img, 0, 0);
                            draw();
                            // Broadcast fog to all players
                            broadcastFog();
                        };
                        img.src = data.fogGroups[group].canvas;
                        
                        fogGroups[group] = {
                            name: data.fogGroups[group].name,
                            canvas: fogCanvas
                        };
                    }
                    
                    // Load placed images
                    if (data.placedImages) {
                        placedImages = [];
                        data.placedImages.forEach(imgData => {
                            const img = new Image();
                            img.onload = () => {
                                placedImages.push({
                                    img: img,
                                    x: imgData.x,
                                    y: imgData.y,
                                    width: imgData.width,
                                    height: imgData.height,
                                    rotation: imgData.rotation,
                                    gridX: imgData.gridX,
                                    gridY: imgData.gridY
                                });
                                draw();
                                broadcastImages();
                            };
                            img.src = imgData.src;
                        });
                    }
                    
                    // Restore campaign name
                    if (data.name) {
                        campaignName = data.name;
                        localStorage.setItem('fracturedSkyCampaignName', campaignName);
                        updateCampaignNameDisplay();
                    }

                    // Load other data
                    lockedCells = data.lockedCells || {};
                    activeFogGroup = data.activeFogGroup || 'everyone';
                    stagingTokens = data.stagingTokens || [];
                    placedTokens = data.placedTokens || [];
                    zoom = data.zoom || 1;
                    panX = data.panX || 0;
                    panY = data.panY || 0;
                    currentCellX = data.currentCellX || 1;
                    currentCellY = data.currentCellY || 1;
                    gridSnapEnabled = data.gridSnapEnabled !== undefined ? data.gridSnapEnabled : true;
                    
                    // Update UI
                    document.getElementById('zoomSlider').value = zoom * 100;
                    document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
                    
                    updateGridDisplay();
                    renderFogGroups();
                    renderStagingTokens();
                    draw();
                    updateMinimap();
                    
                    // Broadcast complete state to all connected players
                    connections.forEach(({conn, approved}) => {
                        if (approved) sendGameState(conn);
                    });
                    
                    document.getElementById('importSuccess').classList.add('show');
                    setTimeout(() => {
                        document.getElementById('importSuccess').classList.remove('show');
                    }, 3000);
                    
                    const playerCount = data.playerData ? data.playerData.length : 0;
                    const tokenCount = stagingTokens.length + placedTokens.length;
                    alert('âœ… Campaign imported: ' + (data.name || 'Untitled') + '\n' + 
                          playerCount + ' players, ' + tokenCount + ' tokens loaded');
                    console.log('âœ… Campaign imported:', data.name);
                    console.log('Loaded:', playerCount, 'players,', tokenCount, 'tokens');
                    
                } catch (err) {
                    console.error('Import error:', err);
                    document.getElementById('importError').textContent = 'Import failed: ' + err.message;
                    document.getElementById('importError').classList.add('show');
                    setTimeout(() => {
                        document.getElementById('importError').classList.remove('show');
                    }, 5000);
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        function saveCloudLink() {
            if (!isDM) return;
            
            const link = document.getElementById('cloudLink').value.trim();
            if (!link) {
                alert('Please enter a cloud link first');
                return;
            }
            
            // Save to session storage
            const key = 'fracturedSky_cloudLink_' + roomCode;
            localStorage.setItem(key, link);
            
            document.getElementById('linkSuccess').classList.add('show');
            setTimeout(() => {
                document.getElementById('linkSuccess').classList.remove('show');
            }, 3000);
            
            console.log('âœ… Cloud link saved for session:', roomCode);
        }
        
        function openCloudLink() {
            const link = document.getElementById('cloudLink').value.trim();
            if (!link) {
                // Try to load saved link
                const key = 'fracturedSky_cloudLink_' + roomCode;
                const saved = localStorage.getItem(key);
                if (saved) {
                    window.open(saved, '_blank');
                } else {
                    alert('No cloud link saved. Paste a link first.');
                }
            } else {
                window.open(link, '_blank');
            }
        }
        
        // Load saved cloud link on DM connect
        function loadSavedCloudLink() {
            if (isDM && roomCode) {
                const key = 'fracturedSky_cloudLink_' + roomCode;
                const saved = localStorage.getItem(key);
                if (saved) {
                    document.getElementById('cloudLink').value = saved;
                }
            }
        }

        function savePlayerState() {
            if (!myName || !roomCode) return;
            
            const playerStateKey = 'fracturedSky_player_' + roomCode + '_' + myName;
            const state = {
                name: myName,
                roomCode: roomCode,
                lastSeen: Date.now(),
                isDM: isDM
            };
            
            localStorage.setItem(playerStateKey, JSON.stringify(state));
        }

        // Save player state periodically
        setInterval(savePlayerState, 60000); // Every minute

        // === PLAYER PANEL DOCKING ===
        let playerPanelDocked = false;
        let playerPanelDragOffset = null;

        function togglePlayerPanelCollapse() {
            document.getElementById('playerPanelDock').classList.toggle('collapsed');
            const btn = document.getElementById('playerCollapseBtn');
            btn.textContent = document.getElementById('playerPanelDock').classList.contains('collapsed') ? '+' : 'âˆ’';
        }

        function togglePlayerPanelDock() {
            playerPanelDocked = !playerPanelDocked;
            const container = document.getElementById('playerPanelContainer');
            const btn = document.getElementById('playerDockBtn');
            
            if (playerPanelDocked) {
                container.style.cursor = 'default';
                btn.textContent = 'ðŸ”’';
            } else {
                container.style.cursor = 'move';
                btn.textContent = 'ðŸ”“';
            }
        }

        // Player panel dragging
        const playerPanelContainer = document.getElementById('playerPanelContainer');
        playerPanelContainer.addEventListener('mousedown', (e) => {
            if (playerPanelDocked) return;
            if (e.target.closest('.minimap-btn') || e.target.closest('.btn')) return;
            
            playerPanelDragOffset = {
                x: e.clientX - playerPanelContainer.offsetLeft,
                y: e.clientY - playerPanelContainer.offsetTop
            };
        });

        let _playerPanelRafPending = false;
        document.addEventListener('mousemove', (e) => {
            if (!playerPanelDragOffset || playerPanelDocked) return;
            if (_playerPanelRafPending) return;
            _playerPanelRafPending = true;
            requestAnimationFrame(() => {
                _playerPanelRafPending = false;
                if (!playerPanelDragOffset) return;
                playerPanelContainer.style.left = (e.clientX - playerPanelDragOffset.x) + 'px';
                playerPanelContainer.style.top = (e.clientY - playerPanelDragOffset.y) + 'px';
                playerPanelContainer.style.right = 'auto';
                playerPanelContainer.style.bottom = 'auto';
            });
        });

        document.addEventListener('mouseup', () => {
            if (playerPanelDragOffset) {
                playerPanelDragOffset = null;
            }
        });

        // === PLAYER TOKEN SIZE ===
        function updatePlayerTokenSize(value) {
            const size = parseInt(value);
            document.getElementById('playerTokenSizeValue').textContent = size;
            
            // Update all tokens owned by this player
            let updated = false;
            placedTokens.forEach(token => {
                if (token.owner === myName) {
                    token.size = size;
                    updated = true;
                }
            });
            
            if (updated) {
                draw();
                // Broadcast token update
                broadcast({
                    type: 'tokenUpdate',
                    tokens: [...stagingTokens, ...placedTokens]
                });
            }
        }

        function adjustPlayerTokenSize(delta) {
            const slider = document.getElementById('playerTokenSize');
            const newValue = Math.max(8, Math.min(30, parseInt(slider.value) + delta));
            slider.value = newValue;
            updatePlayerTokenSize(newValue);
        }

        // === MINIMAP ===
        function updateMinimap() {
            // Build a compact state string; only rebuild the DOM when something changed
            let stateKey = `${currentCellX},${currentCellY}`;
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const key = `${col},${row}`;
                    stateKey += (gridCells[key] ? '1' : '0') + (lockedCells[key] ? 'L' : '.');
                }
            }
            if (stateKey === _minimapLastState) return;
            _minimapLastState = stateKey;

            const grid = _elMinimapGrid || document.getElementById('minimapGrid');
            const cells = [];
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const key = `${col},${row}`;
                    const classes = ['minimap-cell'];
                    if (gridCells[key]) classes.push('has-content');
                    if (lockedCells[key]) classes.push('locked');
                    if (col === currentCellX && row === currentCellY) classes.push('current');
                    cells.push(`<div class="${classes.join(' ')}" onclick="minimapNavigate(${col}, ${row})"></div>`);
                }
            }
            grid.innerHTML = cells.join('');
        }

        function minimapNavigate(col, row) {
            const centerX = (col + 0.5) * GRID_SIZE;
            const centerY = (row + 0.5) * GRID_SIZE;
            panX = canvas.width / 2 - centerX * zoom;
            panY = canvas.height / 2 - centerY * zoom;
            draw();
        }

        function recenterView() {
            panX = (canvas.width - GRID_SIZE * 3 * zoom) / 2;
            panY = (canvas.height - GRID_SIZE * 3 * zoom) / 2;
            draw();
        }

        function resetZoom() {
            zoom = 1;
            document.getElementById('zoomSlider').value = 100;
            document.getElementById('zoomValue').textContent = '100%';
            recenterView();
        }

        function setZoom(v) {
            zoom = v / 100;
            document.getElementById('zoomValue').textContent = Math.round(v) + '%';
            draw();
        }

        function toggleMinimapCollapse() {
            document.getElementById('minimap').classList.toggle('collapsed');
        }

        function toggleMinimapDock() {
            minimapDocked = !minimapDocked;
            const container = document.getElementById('minimapContainer');
            const btn = document.getElementById('dockBtn');
            
            if (minimapDocked) {
                container.classList.add('docked');
                btn.textContent = 'ðŸ”’';
            } else {
                container.classList.remove('docked');
                btn.textContent = 'ðŸ”“';
            }
        }

        // Minimap dragging
        const minimapContainer = document.getElementById('minimapContainer');
        minimapContainer.addEventListener('mousedown', (e) => {
            if (minimapDocked) return;
            if (e.target.closest('.minimap-btn') || e.target.closest('.minimap-cell')) return;
            
            minimapDragOffset = {
                x: e.clientX - minimapContainer.offsetLeft,
                y: e.clientY - minimapContainer.offsetTop
            };
        });

        let _minimapRafPending = false;
        document.addEventListener('mousemove', (e) => {
            if (!minimapDragOffset || minimapDocked) return;
            if (_minimapRafPending) return;
            _minimapRafPending = true;
            requestAnimationFrame(() => {
                _minimapRafPending = false;
                if (!minimapDragOffset) return;
                minimapContainer.style.left = (e.clientX - minimapDragOffset.x) + 'px';
                minimapContainer.style.top = (e.clientY - minimapDragOffset.y) + 'px';
                minimapContainer.style.bottom = 'auto';
            });
        });

        document.addEventListener('mouseup', () => {
            minimapDragOffset = null;
        });

        // === UI ===
        function toggleDMPanel() {
            document.getElementById('dmPanel').classList.toggle('open');
        }

        // Global error handler
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('ðŸš¨ JavaScript Error:', msg);
            console.error('Line:', lineNo, 'Column:', columnNo);
            console.error('Error object:', error);
            return false;
        };

        // =============================================
        // === MUSIC PLAYER ===
        // =============================================
        const MUSIC_TRACKS = [
            { id: 'combat',      label: 'Combat',      emoji: 'âš”ï¸',  file: 'music/combat.mp3' },
            { id: 'boss',        label: 'Boss Battle', emoji: 'ðŸ’€',  file: 'music/boss.mp3' },
            { id: 'exploration', label: 'Exploration', emoji: 'ðŸ—ºï¸', file: 'music/exploration.mp3' },
            { id: 'dungeon',     label: 'Dungeon',     emoji: 'ðŸ•¯ï¸', file: 'music/dungeon.mp3' },
            { id: 'tavern',      label: 'Tavern',      emoji: 'ðŸº',  file: 'music/tavern.mp3' },
            { id: 'town',        label: 'Town',        emoji: 'ðŸ˜ï¸', file: 'music/town.mp3' },
            { id: 'rest',        label: 'Rest',        emoji: 'ðŸŒ™',  file: 'music/rest.mp3' },
            { id: 'mystery',     label: 'Mystery',     emoji: 'ðŸ”®',  file: 'music/mystery.mp3' },
        ];
        let currentTrack = null;
        let musicPanelDragOffset = null;

        function initMusicPanel() {
            const grid = document.getElementById('musicGrid');
            grid.innerHTML = MUSIC_TRACKS.map(t => `
                <button class="music-btn" id="mBtn_${t.id}" onclick="playMusic('${t.id}')">
                    <span class="music-emoji">${t.emoji}</span>${t.label}
                </button>
            `).join('');
        }

        function toggleMusicPanel() {
            const panel = document.getElementById('musicPanel');
            panel.classList.toggle('visible');
            if (panel.classList.contains('visible') && !document.getElementById('musicGrid').innerHTML) {
                initMusicPanel();
            }
        }

        function playMusic(trackId) {
            const track = MUSIC_TRACKS.find(t => t.id === trackId);
            if (!track) return;
            const audio = document.getElementById('musicAudio');
            // Toggle off if same track playing
            if (currentTrack === trackId && !audio.paused) { stopMusic(); return; }
            // Update UI buttons
            document.querySelectorAll('.music-btn').forEach(b => b.classList.remove('playing'));
            const btn = document.getElementById('mBtn_' + trackId);
            if (btn) btn.classList.add('playing');
            // Play audio
            audio.src = track.file;
            audio.volume = document.getElementById('musicVolume').value / 100;
            audio.play().catch(() => {
                document.getElementById('musicNowPlaying').innerHTML =
                    `<span style="color:var(--danger)">âš  No MP3 file yet for "${track.label}" â€” add music/${track.id}.mp3</span>`;
            });
            currentTrack = trackId;
            document.getElementById('musicNowPlaying').innerHTML =
                `Now Playing: <span class="track-name">${track.emoji} ${track.label}</span>`;
            // Optionally broadcast music cue to players
            if (document.getElementById('musicBroadcast').checked) {
                broadcast({ type: 'musicCue', trackId, trackLabel: track.label, emoji: track.emoji });
            }
        }

        function stopMusic() {
            const audio = document.getElementById('musicAudio');
            audio.pause();
            audio.src = '';
            currentTrack = null;
            document.querySelectorAll('.music-btn').forEach(b => b.classList.remove('playing'));
            document.getElementById('musicNowPlaying').textContent = 'Nothing playing';
            if (document.getElementById('musicBroadcast').checked) {
                broadcast({ type: 'musicCue', trackId: null });
            }
        }

        function setMusicVolume(val) {
            const audio = document.getElementById('musicAudio');
            audio.volume = val / 100;
        }


        // Music panel dragging
        const musicPanel = document.getElementById('musicPanel');
        musicPanel.addEventListener('mousedown', (e) => {
            if (e.target.closest('.music-btn') || e.target.closest('.minimap-btn') ||
                e.target.closest('input') || e.target.closest('button')) return;
            musicPanelDragOffset = { x: e.clientX - musicPanel.offsetLeft, y: e.clientY - musicPanel.offsetTop };
        });
        let _musicRafPending = false;
        document.addEventListener('mousemove', (e) => {
            if (!musicPanelDragOffset) return;
            if (_musicRafPending) return;
            _musicRafPending = true;
            requestAnimationFrame(() => {
                _musicRafPending = false;
                if (!musicPanelDragOffset) return;
                musicPanel.style.right = 'auto';
                musicPanel.style.bottom = 'auto';
                musicPanel.style.left = (e.clientX - musicPanelDragOffset.x) + 'px';
                musicPanel.style.top = (e.clientY - musicPanelDragOffset.y) + 'px';
            });
        });
        document.addEventListener('mouseup', () => { musicPanelDragOffset = null; });

        // =============================================
        // === CHARACTER SHEET ===
        // =============================================
        const SKILLS_DEF = [
            { name: 'Acrobatics',     attr: 'DEX' }, { name: 'Animal Handling', attr: 'WIS' },
            { name: 'Arcana',         attr: 'INT' }, { name: 'Athletics',       attr: 'STR' },
            { name: 'Deception',      attr: 'CHA' }, { name: 'History',         attr: 'INT' },
            { name: 'Insight',        attr: 'WIS' }, { name: 'Intimidation',    attr: 'CHA' },
            { name: 'Investigation',  attr: 'INT' }, { name: 'Medicine',        attr: 'WIS' },
            { name: 'Nature',         attr: 'INT' }, { name: 'Perception',      attr: 'WIS' },
            { name: 'Performance',    attr: 'CHA' }, { name: 'Persuasion',      attr: 'CHA' },
            { name: 'Religion',       attr: 'INT' }, { name: 'Sleight of Hand', attr: 'DEX' },
            { name: 'Stealth',        attr: 'DEX' }, { name: 'Survival',        attr: 'WIS' },
        ];
        const SAVES_DEF = ['STR','DEX','CON','INT','WIS','CHA'];
        let characters = [];     // array of character objects
        let activeCharIdx = -1;  // index into characters[]

        function showCharSheet() {
            loadCharactersFromStorage();
            renderCharList();
            buildSkillList();
            buildSavingThrows();
            document.getElementById('charOverlay').classList.add('active');
            updateAllAbilityMods();
            updateProfBonus();
            renderCharTray();
        }

        function closeCharSheet() {
            document.getElementById('charOverlay').classList.remove('active');
        }

        function loadCharactersFromStorage() {
            try {
                const saved = localStorage.getItem('fracturedSky_characters');
                characters = saved ? JSON.parse(saved) : [];
            } catch(e) { characters = []; }
        }

        function saveCharactersToStorage() {
            localStorage.setItem('fracturedSky_characters', JSON.stringify(characters));
        }

        function renderCharList() {
            const el = document.getElementById('charListEl');
            if (characters.length === 0) {
                el.innerHTML = '<p style="font-size:0.85rem;color:var(--text-dim);">No characters yet. Click "+ New" to create one.</p>';
                document.getElementById('charEditor').style.display = 'none';
                document.getElementById('deleteCharBtn').style.display = 'none';
                renderCharTray();
                return;
            }
            el.innerHTML = characters.map((c, i) => {
                const hpPct = c.hpMax > 0 ? Math.max(0, Math.min(100, Math.round((c.hp / c.hpMax) * 100))) : 0;
                return `<div class="char-list-item ${i === activeCharIdx ? 'active' : ''}" onclick="loadCharacter(${i})">
                    <div style="display:flex;align-items:center;gap:0.5rem;">
                        <span style="font-size:1.4rem;">${c.emoji || 'âš”ï¸'}</span>
                        <div>
                            <div style="font-weight:600;font-family:'Cinzel',serif;">${c.name || 'Unnamed'}</div>
                            <div style="font-size:0.75rem;color:var(--text-dim);">${c.class || '?'} ${c.level || 1} â€¢ ${c.race || '?'}</div>
                        </div>
                    </div>
                    <div style="text-align:right;font-size:0.8rem;">
                        <div style="color:var(--danger);">â¤ï¸ ${c.hp || 0}/${c.hpMax || 0}</div>
                        <div style="color:var(--text-dim);">ðŸ›¡ï¸ AC ${c.ac || 10}</div>
                        <div style="background:var(--bg-dark);border-radius:2px;height:4px;margin-top:3px;"><div style="background:var(--danger);height:4px;border-radius:2px;width:${hpPct}%"></div></div>
                    </div>
                </div>`;
            }).join('');
            renderCharTray();
        }

        function newCharacter() {
            const char = {
                name:'', player: myName || '', class:'Fighter', level:1, race:'', background:'', alignment:'True Neutral',
                xp:0, multiclass:'', emoji:'âš”ï¸',
                str:10, dex:10, con:10, int:10, wis:10, cha:10,
                hp:10, hpMax:10, tempHp:0, ac:10, speed:30, hitDice:'1d10', hitDiceUsed:0,
                inspiration:false, exhaustion:0, conditions:[],
                concentration:'',
                skillProfs:{}, saveProfs:{},
                personality:'', ideal:'', bond:'', flaw:'',
                age:'', height:'', weight:'', eyes:'', skin:'', hair:'', marks:'',
                languages:'Common', otherProfs:'',
                // Combat
                attacks:[],
                resistances:'', immunities:'', vulnerabilities:'',
                // Spells
                cantrips:'', spells:'', spellSlots:{1:{max:0,used:0},2:{max:0,used:0},3:{max:0,used:0},4:{max:0,used:0},5:{max:0,used:0},6:{max:0,used:0},7:{max:0,used:0},8:{max:0,used:0},9:{max:0,used:0}},
                // Equipment
                pp:0, gp:0, ep:0, sp:0, cp:0,
                inventory:'', currentWeight:0,
                attune1:'', attune2:'', attune3:'',
                treasure:'',
                // Notes
                features:'', notes:'', allies:'', extra:'',
                backstory:'',
                deathSuccesses:[false,false,false], deathFailures:[false,false,false],
                featureChoices:{}
            };
            characters.push(char);
            activeCharIdx = characters.length - 1;
            saveCharactersToStorage();
            renderCharList();
            buildConditionsGrid(char);
            buildSpellSlotsUI(char);
            populateCharEditor(char);
            document.getElementById('charEditor').style.display = 'block';
            document.getElementById('deleteCharBtn').style.display = 'inline-block';
        }

        function loadCharacter(idx) {
            activeCharIdx = idx;
            const char = characters[idx];
            buildConditionsGrid(char);
            buildSpellSlotsUI(char);
            populateCharEditor(char);
            renderAttacksList(char.attacks || []);
            document.getElementById('charEditor').style.display = 'block';
            document.getElementById('deleteCharBtn').style.display = 'inline-block';
            renderCharList();
        }

        function deleteCharacter() {
            if (activeCharIdx < 0) return;
            if (!confirm('Delete this character? This cannot be undone.')) return;
            characters.splice(activeCharIdx, 1);
            activeCharIdx = -1;
            saveCharactersToStorage();
            renderCharList();
            renderCharTray();
            document.getElementById('charEditor').style.display = 'none';
            document.getElementById('deleteCharBtn').style.display = 'none';
        }

        function _setVal(id, val) { const el = document.getElementById(id); if (el) el.value = val; }
        function _setChk(id, val) { const el = document.getElementById(id); if (el) el.checked = !!val; }

        function populateCharEditor(c) {
            _setVal('cName', c.name || '');
            _setVal('cPlayer', c.player || '');
            _setVal('cClass', c.class || 'Fighter');
            _setVal('cLevel', c.level || 1);
            _setVal('cRace', c.race || '');
            _setVal('cBackground', c.background || '');
            _setVal('cAlignment', c.alignment || 'True Neutral');
            _setVal('cXP', c.xp || 0);
            _setVal('cMulticlass', c.multiclass || '');
            _setVal('cEmoji', c.emoji || 'âš”ï¸');
            _setChk('cInspiration', c.inspiration);
            _setVal('aSTR', c.str || 10);
            _setVal('aDEX', c.dex || 10);
            _setVal('aCON', c.con || 10);
            _setVal('aINT', c.int || 10);
            _setVal('aWIS', c.wis || 10);
            _setVal('aCHA', c.cha || 10);
            _setVal('cHP', c.hp || 10);
            _setVal('cHPMax', c.hpMax || 10);
            _setVal('cTempHP', c.tempHp || 0);
            _setVal('cAC', c.ac || 10);
            _setVal('cSpeed', c.speed || 30);
            _setVal('cHitDice', c.hitDice || '1d10');
            _setVal('cHitDiceUsed', c.hitDiceUsed || 0);
            _setVal('cConcentration', c.concentration || '');
            _setVal('cPersonality', c.personality || '');
            _setVal('cIdeal', c.ideal || '');
            _setVal('cBond', c.bond || '');
            _setVal('cFlaw', c.flaw || '');
            _setVal('cAge', c.age || '');
            _setVal('cHeight', c.height || '');
            _setVal('cWeight', c.weight || '');
            _setVal('cEyes', c.eyes || '');
            _setVal('cSkin', c.skin || '');
            _setVal('cHair', c.hair || '');
            _setVal('cMarks', c.marks || '');
            _setVal('cLanguages', c.languages || '');
            _setVal('cOtherProfs', c.otherProfs || '');
            _setVal('cResistances', c.resistances || '');
            _setVal('cImmunities', c.immunities || '');
            _setVal('cVulnerabilities', c.vulnerabilities || '');
            _setVal('cCantrips', c.cantrips || '');
            _setVal('cSpells', c.spells || '');
            _setVal('cPP', c.pp || 0);
            _setVal('cGP', c.gp || 0);
            _setVal('cEP', c.ep || 0);
            _setVal('cSP', c.sp || 0);
            _setVal('cCP', c.cp || 0);
            _setVal('cCurrentWeight', c.currentWeight || 0);
            _setVal('cAttune1', c.attune1 || '');
            _setVal('cAttune2', c.attune2 || '');
            _setVal('cAttune3', c.attune3 || '');
            _setVal('cTreasure', c.treasure || '');
            _setVal('cInventory', c.inventory || '');
            _setVal('cFeatures', c.features || '');
            _setVal('cNotes', c.notes || '');
            _setVal('cAllies', c.allies || '');
            _setVal('cExtra', c.extra || '');
            _setVal('cBackstory', c.backstory || '');
            // Skill profs
            document.querySelectorAll('.skill-prof-check').forEach(cb => {
                cb.checked = !!(c.skillProfs && c.skillProfs[cb.dataset.skill]);
            });
            // Save profs
            document.querySelectorAll('.save-prof-check').forEach(cb => {
                cb.checked = !!(c.saveProfs && c.saveProfs[cb.dataset.save]);
            });
            // Death saves
            ['deathSuccesses','deathFailures'].forEach(key => {
                const type = key === 'deathSuccesses' ? 'success' : 'failure';
                document.querySelectorAll(`.death-save-pip.${type}`).forEach((pip, i) => {
                    pip.classList.toggle('filled', !!(c[key] && c[key][i]));
                });
            });
            // Exhaustion
            const exLevel = c.exhaustion || 0;
            document.querySelectorAll('.exhaustion-pip').forEach(pip => {
                pip.classList.toggle('active', parseInt(pip.dataset.level) <= exLevel);
            });
            updateExhaustionLabel(exLevel);
            // Conditions
            document.querySelectorAll('.condition-tag').forEach(tag => {
                tag.classList.toggle('active', !!(c.conditions && c.conditions.includes(tag.dataset.cond)));
            });
            // Attacks
            renderAttacksList(c.attacks || []);
            // Spell slots
            buildSpellSlotsUI(c);
            // Carrying capacity
            updateCarryingCap();
            updateAllAbilityMods();
            updateProfBonus();
            updateSpellcastingAbility();
        }

        function _getVal(id, def='') { const el = document.getElementById(id); return el ? el.value : def; }
        function _getInt(id, def=0)  { return parseInt(_getVal(id, def)) || def; }
        function _getChk(id) { const el = document.getElementById(id); return el ? el.checked : false; }

        function saveCharacter() {
            if (activeCharIdx < 0) { alert('No character selected. Click "+ New" first.'); return; }
            const c = characters[activeCharIdx];
            c.name = _getVal('cName');
            c.player = _getVal('cPlayer');
            c.class = _getVal('cClass');
            c.level = _getInt('cLevel', 1);
            c.race = _getVal('cRace');
            c.background = _getVal('cBackground');
            c.alignment = _getVal('cAlignment');
            c.xp = _getInt('cXP', 0);
            c.multiclass = _getVal('cMulticlass');
            c.emoji = _getVal('cEmoji') || 'âš”ï¸';
            c.inspiration = _getChk('cInspiration');
            c.str = _getInt('aSTR', 10);
            c.dex = _getInt('aDEX', 10);
            c.con = _getInt('aCON', 10);
            c.int = _getInt('aINT', 10);
            c.wis = _getInt('aWIS', 10);
            c.cha = _getInt('aCHA', 10);
            c.hp = _getInt('cHP', 0);
            c.hpMax = _getInt('cHPMax', 10);
            c.tempHp = _getInt('cTempHP', 0);
            c.ac = _getInt('cAC', 10);
            c.speed = _getInt('cSpeed', 30);
            c.hitDice = _getVal('cHitDice');
            c.hitDiceUsed = _getInt('cHitDiceUsed', 0);
            c.concentration = _getVal('cConcentration');
            c.personality = _getVal('cPersonality');
            c.ideal = _getVal('cIdeal');
            c.bond = _getVal('cBond');
            c.flaw = _getVal('cFlaw');
            c.age = _getVal('cAge');
            c.height = _getVal('cHeight');
            c.weight = _getVal('cWeight');
            c.eyes = _getVal('cEyes');
            c.skin = _getVal('cSkin');
            c.hair = _getVal('cHair');
            c.marks = _getVal('cMarks');
            c.languages = _getVal('cLanguages');
            c.otherProfs = _getVal('cOtherProfs');
            c.resistances = _getVal('cResistances');
            c.immunities = _getVal('cImmunities');
            c.vulnerabilities = _getVal('cVulnerabilities');
            c.cantrips = _getVal('cCantrips');
            c.spells = _getVal('cSpells');
            c.pp = _getInt('cPP', 0);
            c.gp = _getInt('cGP', 0);
            c.ep = _getInt('cEP', 0);
            c.sp = _getInt('cSP', 0);
            c.cp = _getInt('cCP', 0);
            c.currentWeight = _getInt('cCurrentWeight', 0);
            c.attune1 = _getVal('cAttune1');
            c.attune2 = _getVal('cAttune2');
            c.attune3 = _getVal('cAttune3');
            c.treasure = _getVal('cTreasure');
            c.inventory = _getVal('cInventory');
            c.features = _getVal('cFeatures');
            c.notes = _getVal('cNotes');
            c.allies = _getVal('cAllies');
            c.extra = _getVal('cExtra');
            c.backstory = _getVal('cBackstory');
            // Exhaustion
            const activePips = document.querySelectorAll('.exhaustion-pip.active');
            c.exhaustion = activePips.length;
            // Conditions
            c.conditions = [];
            document.querySelectorAll('.condition-tag.active').forEach(tag => c.conditions.push(tag.dataset.cond));
            // Attacks
            c.attacks = readAttacksList();
            // Spell slots
            c.spellSlots = readSpellSlots();
            // Skill profs
            c.skillProfs = {};
            document.querySelectorAll('.skill-prof-check').forEach(cb => {
                if (cb.checked) c.skillProfs[cb.dataset.skill] = true;
            });
            // Save profs
            c.saveProfs = {};
            document.querySelectorAll('.save-prof-check').forEach(cb => {
                if (cb.checked) c.saveProfs[cb.dataset.save] = true;
            });
            // Death saves
            c.deathSuccesses = [false, false, false];
            c.deathFailures = [false, false, false];
            document.querySelectorAll('.death-save-pip.success').forEach((pip, i) => {
                c.deathSuccesses[i] = pip.classList.contains('filled');
            });
            document.querySelectorAll('.death-save-pip.failure').forEach((pip, i) => {
                c.deathFailures[i] = pip.classList.contains('filled');
            });
            saveCharactersToStorage();
            renderCharList();
            renderCharTray();
            // Flash save button
            const btn = document.querySelector('[onclick="saveCharacter()"]');
            if (btn) {
                const orig = btn.textContent;
                btn.textContent = 'âœ“ Saved!';
                btn.style.background = 'var(--success)';
                btn.style.color = '#0e0b08';
                setTimeout(() => { btn.textContent = orig; btn.style.background = ''; btn.style.color = ''; }, 1500);
            }
        }

        function getAbilityMod(score) { return Math.floor((parseInt(score) - 10) / 2); }

        function updateAbilityMod(attr) {
            const score = document.getElementById('a' + attr).value;
            const mod = getAbilityMod(score);
            document.getElementById('m' + attr).textContent = (mod >= 0 ? '+' : '') + mod;
            // Update initiative from DEX
            if (attr === 'DEX') document.getElementById('cInit').value = (mod >= 0 ? '+' : '') + mod;
            // Update passive perception/investigation from WIS/INT
            if (attr === 'WIS' || attr === 'INT') updatePassivePerception();
            if (attr === 'STR') updateCarryingCap();
            updateSkillMods();
            updateSaveMods();
            updateSpellcastingAbility();
        }

        function updateAllAbilityMods() {
            ['STR','DEX','CON','INT','WIS','CHA'].forEach(a => updateAbilityMod(a));
        }

        function updateProfBonus() {
            const level = parseInt(document.getElementById('cLevel').value) || 1;
            const prof = Math.ceil(level / 4) + 1;
            document.getElementById('cProfBonus').value = '+' + prof;
            updateSkillMods();
            updateSaveMods();
            updatePassivePerception();
            updateSpellcastingAbility();
        }

        function getProfBonus() {
            const level = parseInt(document.getElementById('cLevel').value) || 1;
            return Math.ceil(level / 4) + 1;
        }

        function getAttrMod(attr) {
            const score = document.getElementById('a' + attr);
            return score ? getAbilityMod(score.value) : 0;
        }

        function updateSkillMods() {
            const prof = getProfBonus();
            document.querySelectorAll('.skill-mod-val').forEach(el => {
                const skill = el.dataset.skill;
                const attr = el.dataset.attr;
                const profCheck = document.querySelector(`.skill-prof-check[data-skill="${skill}"]`);
                const isProficient = profCheck && profCheck.checked;
                const mod = getAttrMod(attr) + (isProficient ? prof : 0);
                el.textContent = (mod >= 0 ? '+' : '') + mod;
            });
        }

        function updateSaveMods() {
            const prof = getProfBonus();
            document.querySelectorAll('.save-mod-val').forEach(el => {
                const attr = el.dataset.attr;
                const profCheck = document.querySelector(`.save-prof-check[data-save="${attr}"]`);
                const isProficient = profCheck && profCheck.checked;
                const mod = getAttrMod(attr) + (isProficient ? prof : 0);
                el.textContent = (mod >= 0 ? '+' : '') + mod;
            });
        }

        function updatePassivePerception() {
            const prof = getProfBonus();
            const wisMod = getAttrMod('WIS');
            const percCheck = document.querySelector('.skill-prof-check[data-skill="Perception"]');
            const isProficient = percCheck && percCheck.checked;
            const pp = 10 + wisMod + (isProficient ? prof : 0);
            const el = document.getElementById('cPassivePerception');
            if (el) el.value = pp;
            // Also update passive investigation
            const invCheck = document.querySelector('.skill-prof-check[data-skill="Investigation"]');
            const isInvProf = invCheck && invCheck.checked;
            const intMod = getAttrMod('INT');
            const pi = 10 + intMod + (isInvProf ? prof : 0);
            const el2 = document.getElementById('cPassiveInvestigation');
            if (el2) el2.value = pi;
        }

        function updateCarryingCap() {
            const strScore = parseInt((document.getElementById('aSTR') || {}).value) || 10;
            const cap = strScore * 15;
            const el = document.getElementById('cCarryingCap');
            if (el) el.value = cap + ' lbs';
        }

        // Spellcasting ability by class
        const SPELL_ABILITY = {
            Artificer:'INT', Bard:'CHA', Cleric:'WIS', Druid:'WIS',
            Paladin:'CHA', Ranger:'WIS', Sorcerer:'CHA', Warlock:'CHA', Wizard:'INT'
        };
        function updateSpellcastingAbility() {
            const cls = (document.getElementById('cClass') || {}).value || 'Fighter';
            const ability = SPELL_ABILITY[cls] || '';
            _setVal('cSpellAbility', ability);
            _setVal('cSpellClass', cls);
            const prof = getProfBonus();
            if (ability) {
                const mod = getAttrMod(ability);
                _setVal('cSpellSaveDC', 8 + prof + mod);
                _setVal('cSpellAttackBonus', (prof + mod >= 0 ? '+' : '') + (prof + mod));
            } else {
                _setVal('cSpellSaveDC', 'â€”');
                _setVal('cSpellAttackBonus', 'â€”');
            }
        }

        // === EXHAUSTION ===
        const EXHAUSTION_LABELS = ['No exhaustion','Disadvantage on ability checks','Speed halved','Disadvantage on attacks & saves','HP maximum halved','Speed = 0','Death'];
        function toggleExhaustion(level) {
            const c = (activeCharIdx >= 0) ? characters[activeCharIdx] : null;
            if (!c) return;
            const cur = c.exhaustion || 0;
            c.exhaustion = (cur === level) ? level - 1 : level;
            document.querySelectorAll('.exhaustion-pip').forEach(pip => {
                pip.classList.toggle('active', parseInt(pip.dataset.level) <= c.exhaustion);
            });
            updateExhaustionLabel(c.exhaustion);
        }
        function updateExhaustionLabel(level) {
            const el = document.getElementById('exhaustionLabel');
            if (el) el.textContent = EXHAUSTION_LABELS[level] || 'No exhaustion';
        }

        // === CONDITIONS ===
        const CONDITIONS_LIST = ['Blinded','Charmed','Deafened','Exhaustion','Frightened','Grappled','Incapacitated','Invisible','Paralyzed','Petrified','Poisoned','Prone','Restrained','Stunned','Unconscious'];
        function buildConditionsGrid(c) {
            const grid = document.getElementById('conditionsGrid');
            if (!grid) return;
            grid.innerHTML = CONDITIONS_LIST.map(cond => `
                <div class="condition-tag ${(c.conditions||[]).includes(cond) ? 'active' : ''}" data-cond="${cond}" onclick="toggleCondition(this)">${cond}</div>
            `).join('');
        }
        function toggleCondition(tag) {
            tag.classList.toggle('active');
        }

        // === ATTACKS ===
        let _attacksData = [];
        function renderAttacksList(attacks) {
            _attacksData = attacks ? [...attacks] : [];
            const el = document.getElementById('attacksList');
            if (!el) return;
            if (_attacksData.length === 0) {
                el.innerHTML = '<p style="font-size:0.8rem;color:var(--text-dim);">No attacks yet. Click "+ Add Attack / Weapon" below.</p>';
                return;
            }
            el.innerHTML = `<div style="display:grid;grid-template-columns:2fr 1fr 2fr 1fr auto;gap:0.3rem;margin-bottom:0.3rem;padding:0 0.4rem;">
                <span style="font-size:0.65rem;color:var(--text-dim);text-transform:uppercase;">Name</span>
                <span style="font-size:0.65rem;color:var(--text-dim);text-transform:uppercase;">Atk Bonus</span>
                <span style="font-size:0.65rem;color:var(--text-dim);text-transform:uppercase;">Damage / Type</span>
                <span style="font-size:0.65rem;color:var(--text-dim);text-transform:uppercase;">Range</span>
                <span></span>
            </div>` + _attacksData.map((a, i) => `
                <div class="attack-row">
                    <input value="${a.name||''}" oninput="_attacksData[${i}].name=this.value" placeholder="Longsword">
                    <input value="${a.bonus||''}" oninput="_attacksData[${i}].bonus=this.value" placeholder="+5">
                    <input value="${a.damage||''}" oninput="_attacksData[${i}].damage=this.value" placeholder="1d8+3 slashing">
                    <input value="${a.range||''}" oninput="_attacksData[${i}].range=this.value" placeholder="5 ft">
                    <button class="atk-del" onclick="removeAttack(${i})" title="Remove">âœ•</button>
                </div>
            `).join('');
        }
        function addAttack() {
            _attacksData.push({name:'', bonus:'', damage:'', range:''});
            renderAttacksList(_attacksData);
        }
        function removeAttack(i) {
            _attacksData.splice(i, 1);
            renderAttacksList(_attacksData);
        }
        function readAttacksList() { return [..._attacksData]; }

        // === SPELL SLOTS ===
        function buildSpellSlotsUI(c) {
            const el = document.getElementById('spellSlotsGrid');
            if (!el) return;
            const slots = c.spellSlots || {};
            const ordinals = ['1st','2nd','3rd','4th','5th','6th','7th','8th','9th'];
            el.innerHTML = [1,2,3,4,5,6,7,8,9].map(lvl => {
                const s = slots[lvl] || {max:0, used:0};
                const max = s.max || 0;
                const used = s.used || 0;
                const pips = Array.from({length: Math.max(max, 0)}, (_, i) =>
                    `<div class="ss-pip ${i < (max - used) ? 'available' : 'used'}" onclick="toggleSpellSlot(${lvl}, ${i})" title="Slot ${i+1}"></div>`
                ).join('');
                return `<div class="spell-slot-row">
                    <span class="spell-slot-label">${ordinals[lvl-1]}</span>
                    <div class="spell-slot-pips" id="ssPips${lvl}">${pips || '<span style="font-size:0.7rem;color:var(--text-dim);">No slots</span>'}</div>
                    <div class="spell-slot-max">
                        Max: <input type="number" min="0" max="9" value="${max}" onchange="updateSpellSlotMax(${lvl}, this.value)" style="width:36px;">
                        <button onclick="recoverAllSlots(${lvl})" title="Recover all" style="background:none;border:none;cursor:pointer;color:var(--accent);font-size:0.85rem;padding:0 2px;" title="Long rest recover">â†»</button>
                    </div>
                </div>`;
            }).join('');
        }
        function toggleSpellSlot(lvl, pipIdx) {
            const c = (activeCharIdx >= 0) ? characters[activeCharIdx] : null;
            if (!c) return;
            if (!c.spellSlots) c.spellSlots = {};
            if (!c.spellSlots[lvl]) c.spellSlots[lvl] = {max:0, used:0};
            const s = c.spellSlots[lvl];
            const available = s.max - s.used;
            if (pipIdx < available) {
                s.used = s.max - pipIdx; // use slots up to this pip
            } else {
                s.used = Math.max(0, s.used - 1); // recover one slot
            }
            buildSpellSlotsUI(c);
        }
        function updateSpellSlotMax(lvl, val) {
            const c = (activeCharIdx >= 0) ? characters[activeCharIdx] : null;
            if (!c) return;
            if (!c.spellSlots) c.spellSlots = {};
            if (!c.spellSlots[lvl]) c.spellSlots[lvl] = {max:0, used:0};
            c.spellSlots[lvl].max = Math.max(0, parseInt(val) || 0);
            c.spellSlots[lvl].used = Math.min(c.spellSlots[lvl].used, c.spellSlots[lvl].max);
            buildSpellSlotsUI(c);
        }
        function recoverAllSlots(lvl) {
            const c = (activeCharIdx >= 0) ? characters[activeCharIdx] : null;
            if (!c || !c.spellSlots || !c.spellSlots[lvl]) return;
            c.spellSlots[lvl].used = 0;
            buildSpellSlotsUI(c);
        }
        function readSpellSlots() {
            const c = (activeCharIdx >= 0) ? characters[activeCharIdx] : null;
            return c ? (c.spellSlots || {}) : {};
        }

        function buildSkillList() {
            const el = document.getElementById('skillListEl');
            el.innerHTML = SKILLS_DEF.map(s => `
                <div class="skill-item">
                    <input type="checkbox" class="skill-prof-check" data-skill="${s.name}" onchange="updateSkillMods();updatePassivePerception()">
                    <span class="skill-mod skill-mod-val" data-skill="${s.name}" data-attr="${s.attr}">+0</span>
                    <span class="skill-name">${s.name}</span>
                    <span class="skill-attr">(${s.attr})</span>
                </div>
            `).join('');
        }

        function buildSavingThrows() {
            const el = document.getElementById('savingThrowList');
            el.innerHTML = SAVES_DEF.map(attr => `
                <div class="skill-item">
                    <input type="checkbox" class="save-prof-check" data-save="${attr}" onchange="updateSaveMods()">
                    <span class="skill-mod save-mod-val" data-attr="${attr}">+0</span>
                    <span class="skill-name">${attr}</span>
                </div>
            `).join('');
        }

        function switchCharTab(tab) {
            document.querySelectorAll('.char-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.char-tab-content').forEach(t => t.classList.remove('active'));
            document.querySelector(`.char-tab[onclick="switchCharTab('${tab}')"]`).classList.add('active');
            document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');
            if (tab === 'features') renderFeaturesTab();
        }

        function changeHP(delta) {
            const input = document.getElementById('cHP');
            const max = parseInt(document.getElementById('cHPMax').value) || 10;
            input.value = Math.max(0, Math.min(max, parseInt(input.value || 0) + delta));
        }

        function toggleDeathSave(pip) {
            pip.classList.toggle('filled');
        }

        // =============================================
        // CHARACTER TRAY
        // =============================================
        let _quickViewCharIdx = -1;

        function renderCharTray() {
            loadCharactersFromStorage();
            const tray = document.getElementById('charTray');
            if (!tray) return;
            if (characters.length === 0) { tray.innerHTML = ''; return; }
            tray.innerHTML = '<span class="char-tray-label">Party</span>' + characters.map((c, i) => {
                const hpPct = c.hpMax > 0 ? Math.max(0, Math.min(100, Math.round((c.hp / c.hpMax) * 100))) : 0;
                const emoji = c.emoji || 'âš”ï¸';
                return `<div class="char-tray-btn" onclick="openQuickView(${i})" title="${c.name || 'Unnamed'} â€” ${c.class || '?'} ${c.level || 1}">
                    <div style="font-size:1.3rem;line-height:1;">${emoji}</div>
                    <div class="tray-name">${c.name || 'Unnamed'}</div>
                    <div class="tray-class">${c.class || '?'} ${c.level || 1}</div>
                    <div class="tray-hp">${c.hp || 0}/${c.hpMax || 0}</div>
                    <div class="char-tray-hp-bar"><div class="char-tray-hp-fill" style="width:${hpPct}%"></div></div>
                </div>`;
            }).join('');
            // Keep advantage panel in sync with current character list
            const advBody = document.getElementById('diceAdvantageBody');
            if (advBody && advBody.classList.contains('open')) renderAdvantagePanel();
        }

        function openQuickView(idx) {
            const c = characters[idx];
            if (!c) return;
            _quickViewCharIdx = idx;
            const qv = document.getElementById('charQuickView');
            document.getElementById('qvName').textContent = (c.emoji || 'âš”ï¸') + ' ' + (c.name || 'Unnamed');
            document.getElementById('qvSub').textContent = `${c.class || '?'} ${c.level || 1} â€¢ ${c.race || '?'} â€¢ ${c.alignment || ''}`;
            const hp = c.hp || 0, hpMax = c.hpMax || 1;
            document.getElementById('qvHPText').textContent = `${hp}/${hpMax}`;
            document.getElementById('qvHPBar').style.width = Math.max(0, Math.min(100, Math.round(hp/hpMax*100))) + '%';
            document.getElementById('qvAC').textContent = c.ac || 10;
            const dexMod = Math.floor(((c.dex || 10) - 10) / 2);
            document.getElementById('qvInit').textContent = (dexMod >= 0 ? '+' : '') + dexMod;
            document.getElementById('qvSpeed').textContent = (c.speed || 30) + 'ft';
            const prof = Math.ceil((c.level || 1) / 4) + 1;
            document.getElementById('qvProf').textContent = '+' + prof;
            document.getElementById('qvSTR').textContent = c.str || 10;
            document.getElementById('qvDEX').textContent = c.dex || 10;
            document.getElementById('qvCON').textContent = c.con || 10;
            document.getElementById('qvINT').textContent = c.int || 10;
            document.getElementById('qvWIS').textContent = c.wis || 10;
            document.getElementById('qvCHA').textContent = c.cha || 10;
            qv.classList.add('show');
        }

        function closeQuickView() {
            document.getElementById('charQuickView').classList.remove('show');
            _quickViewCharIdx = -1;
        }

        function openFullSheetFromTray() {
            const idx = _quickViewCharIdx;
            closeQuickView();
            showCharSheet();
            if (idx >= 0) setTimeout(() => loadCharacter(idx), 50);
        }

        // Click outside quick view to close
        document.addEventListener('click', (e) => {
            const qv = document.getElementById('charQuickView');
            const tray = document.getElementById('charTray');
            if (qv && qv.classList.contains('show')) {
                if (!qv.contains(e.target) && !tray.contains(e.target)) closeQuickView();
            }
        });

        // Auto-load tray from storage on boot
        window.addEventListener('DOMContentLoaded', () => {
            loadCharactersFromStorage();
            renderCharTray();
        });

        // =============================================
        // DICE ROLL FIREBASE PERSISTENCE
        // =============================================

        function saveDiceRollToFirebase(result, rollerName, rollId) {
            const roomId = firebaseRoomRef || playerFirebaseRoomId;
            if (!roomId || !fbDb) return;
            firebaseSignIn().then(() => {
                fbDb.collection('vtt_rooms').doc(roomId + '__dice_log')
                    .set({
                        rolls: firebase.firestore.FieldValue.arrayUnion(
                            { result, rollerName, rollId, timestamp: Date.now() }
                        )
                    }, { merge: true })
                    .catch(e => console.error('ðŸŽ² Dice log save error:', e));
            });
        }

        function loadAndListenDiceRolls(roomId) {
            if (diceRollsUnsubscribe) { diceRollsUnsubscribe(); diceRollsUnsubscribe = null; }
            if (!roomId || !fbDb) return;
            firebaseSignIn().then(() => {
                const docRef = fbDb.collection('vtt_rooms').doc(roomId + '__dice_log');

                // Load last 5 historical rolls so the DM/players can see recent history on join
                docRef.get().then(snap => {
                    if (!snap.exists) return;
                    const rolls = (snap.data().rolls || [])
                        .sort((a, b) => b.timestamp - a.timestamp)
                        .slice(0, 5);
                    rolls.reverse().forEach(r => showDiceResult(r.result, r.rollerName, false, r.rollId, 0, null, true));
                }).catch(() => {});

                // Real-time listener â€” only surfaces rolls that arrive after we joined
                diceListenSince = Date.now();
                diceRollsUnsubscribe = docRef.onSnapshot(snap => {
                    if (!snap.exists) return;
                    (snap.data().rolls || []).forEach(r => {
                        if (r.timestamp >= diceListenSince) {
                            showDiceResult(r.result, r.rollerName, false, r.rollId);
                        }
                    });
                }, () => {});
            });
        }

        // =============================================
        // DICE ADVANTAGE PANEL
        // =============================================
        let selectedAdvantageBonus = 0;
        let selectedAdvantageLabel = null;
        let advantageCharIdx = 0;

        function showDiceAdvantagePanel() {
            const panel = document.getElementById('diceAdvantagePanel');
            if (panel) panel.classList.add('panel-visible');
            renderAdvantagePanel();
        }

        function toggleDiceAdvantageBody() {
            const body = document.getElementById('diceAdvantageBody');
            const header = document.getElementById('diceAdvantageHeader');
            const arrow = document.getElementById('diceAdvArrow');
            if (!body) return;
            const isOpen = body.classList.toggle('open');
            header.classList.toggle('open', isOpen);
            arrow.textContent = isOpen ? 'â–¼' : 'â–²';
            if (isOpen) renderAdvantagePanel();
        }

        function renderAdvantagePanel() {
            loadCharactersFromStorage();
            if (characters.length === 0) {
                document.getElementById('advantageCharsRow').innerHTML = '<span class="advantage-chars-label">No characters â€” create one in the character sheet.</span>';
                document.getElementById('advantageSkillsRow').innerHTML = '<button class="advantage-clear-btn" onclick="clearDiceAdvantage()">âœ• Clear</button>';
                return;
            }
            if (advantageCharIdx >= characters.length) advantageCharIdx = 0;

            const charRow = document.getElementById('advantageCharsRow');
            charRow.innerHTML = '<span class="advantage-chars-label">Character:</span>' +
                characters.map((c, i) =>
                    `<button class="advantage-char-btn ${i === advantageCharIdx ? 'active' : ''}" onclick="selectAdvantageChar(${i})">${c.emoji || 'âš”ï¸'} ${c.name || ('Char ' + (i+1))}</button>`
                ).join('');

            renderAdvantageSkills();
        }

        function selectAdvantageChar(idx) {
            advantageCharIdx = idx;
            renderAdvantagePanel();
        }

        function renderAdvantageSkills() {
            const c = characters[advantageCharIdx];
            if (!c) return;
            const attrs = [
                { key: 'STR', val: c.str || 10 },
                { key: 'DEX', val: c.dex || 10 },
                { key: 'CON', val: c.con || 10 },
                { key: 'INT', val: c.int || 10 },
                { key: 'WIS', val: c.wis || 10 },
                { key: 'CHA', val: c.cha || 10 }
            ];
            const charName = c.name || ('Char ' + (advantageCharIdx + 1));
            const skillsRow = document.getElementById('advantageSkillsRow');
            skillsRow.innerHTML = attrs.map(({ key, val }) => {
                const mod = Math.floor((parseInt(val) - 10) / 2);
                const modStr = (mod >= 0 ? '+' : '') + mod;
                const label = key + ' ' + modStr;
                const isSelected = selectedAdvantageLabel === label && selectedAdvantageBonus === mod;
                return `<button class="advantage-skill-btn ${isSelected ? 'selected' : ''}"
                            onclick="selectDiceAdvantage('${key}', ${mod}, '${label}')">
                            <span class="adv-attr">${key}</span>
                            <span class="adv-mod">${modStr}</span>
                        </button>`;
            }).join('') + '<button class="advantage-clear-btn" onclick="clearDiceAdvantage()">âœ• Clear</button>';
        }

        function selectDiceAdvantage(attr, bonus, label) {
            selectedAdvantageBonus = bonus;
            selectedAdvantageLabel = label;
            const el = document.getElementById('advantageSelectedLabel');
            if (el) el.textContent = label;
            renderAdvantageSkills();
        }

        function clearDiceAdvantage() {
            selectedAdvantageBonus = 0;
            selectedAdvantageLabel = null;
            const el = document.getElementById('advantageSelectedLabel');
            if (el) el.textContent = '';
            renderAdvantageSkills();
        }

        // =============================================
        // DICE ROLLER
        // =============================================
        let diceToastTimer = null;

        function rollD20() {
            const result = Math.floor(Math.random() * 20) + 1;
            const rollId = Date.now() + '_' + Math.random().toString(36).slice(2, 8);
            const btn = document.getElementById('diceRollerBtn');
            btn.classList.add('rolling');
            setTimeout(() => btn.classList.remove('rolling'), 500);
            const bonus = selectedAdvantageBonus || 0;
            const advLabel = selectedAdvantageLabel || null;
            showDiceResult(result, myName || 'Anonymous', true, rollId, bonus, advLabel);
            const msg = { type: 'diceRoll', result, rollerName: myName || 'Anonymous', rollId, bonus, advLabel };
            if (!isDM) {
                connections.forEach(({ conn, role }) => { if (role === 'dm') sendToPeer(conn, msg); });
            } else {
                broadcast(msg);
            }
            saveDiceRollToFirebase(result, myName || 'Anonymous', rollId);
        }

        function showDiceResult(result, rollerName, isOwn, rollId, bonus, advLabel, silent) {
            if (rollId !== undefined) {
                if (shownRollIds.has(rollId)) return;
                shownRollIds.add(rollId);
            }
            const b = bonus || 0;
            const total = result + b;
            if (!silent) {
                const toast = document.getElementById('diceToast');
                const numEl  = document.getElementById('toastNum');
                const nameEl = document.getElementById('toastRoller');
                numEl.className = 'toast-num' + (result === 20 ? ' nat20' : result === 1 ? ' nat1' : '');
                if (b !== 0 && advLabel) {
                    const sign = b >= 0 ? '+' : '';
                    numEl.textContent = result + ' ' + sign + b + ' = ' + total;
                    nameEl.textContent = (isOwn ? 'You roll' : rollerName + ' rolls') + ' d20 (' + advLabel + ')';
                } else {
                    numEl.textContent = result;
                    nameEl.textContent = (isOwn ? 'You roll' : rollerName + ' rolls') + ' d20';
                }
                toast.classList.add('show');
                clearTimeout(diceToastTimer);
                diceToastTimer = setTimeout(() => toast.classList.remove('show'), 2800);
            }
            const log = document.getElementById('diceRollLog');
            const entry = document.createElement('div');
            entry.className = 'dice-log-entry';
            const cls = result === 20 ? ' nat20' : result === 1 ? ' nat1' : '';
            if (b !== 0) {
                const sign = b >= 0 ? '+' : '';
                entry.innerHTML = `<span style="color:var(--text-dim);font-size:0.75rem;max-width:110px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${rollerName}</span><span class="dice-log-num${cls}">${result}${sign}${b}=${total}</span>`;
            } else {
                entry.innerHTML = `<span style="color:var(--text-dim);font-size:0.75rem;max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${rollerName}</span><span class="dice-log-num${cls}">${result}</span>`;
            }
            log.prepend(entry);
            while (log.children.length > 5) log.lastChild.remove();
        }

        // =============================================
        // CLASS FEATURES
        // =============================================
        // Each feature: { level, name, blurb, type (optional 'choice'), choices[] (optional) }
        const CLASS_FEATURES = {
            Barbarian: {
                color:'#ef4444', emoji:'ðŸª“',
                desc:'A fierce warrior who taps into primal rage. No heavy armor needed â€” your raw toughness and fury are your defense. High damage, high survivability.',
                features:[
                    {level:1, name:'Rage', blurb:'Bonus action to enter a rage (2 uses/long rest, more at higher levels). While raging: +2 damage on STR attacks, resistance to bludgeoning/piercing/slashing damage. Lasts 1 minute or until you stop attacking.'},
                    {level:1, name:'Unarmored Defense', blurb:'While wearing NO armor, your AC = 10 + DEX modifier + CON modifier. You\'re naturally tough enough without armor.'},
                    {level:2, name:'Reckless Attack', blurb:'On your first attack each turn, you can attack with advantage â€” but enemies also have advantage attacking you until your next turn. High risk, high reward.'},
                    {level:2, name:'Danger Sense', blurb:'Advantage on Dexterity saving throws against things you can see (traps, spells, explosions). Your instincts are razor sharp.'},
                    {level:3, name:'Primal Path', type:'choice', blurb:'Choose your Barbarian subclass. Each path changes how your Rage works and what you specialize in.', choices:['Berserker (frenzy â€” bonus attacks while raging, but exhausted after)','Totem Warrior (spirit animal powers: Bear=tanky, Eagle=mobile, Wolf=pack leader)','Zealot (divine rage, harder to kill, come back from death)','Ancestral Guardian (protect allies, haunt enemies with ancestral spirits)','Storm Herald (elemental aura around you while raging)','Beast (grow claws, armor, or a tail while raging)']},
                    {level:4, name:'Ability Score Improvement', blurb:'+2 to one ability score, OR +1 to two different scores, OR choose a Feat (special powerful ability). Happens at levels 4, 8, 12, 16, 19.'},
                    {level:5, name:'Extra Attack', blurb:'Attack TWICE instead of once whenever you take the Attack action on your turn.'},
                    {level:5, name:'Fast Movement', blurb:'+10 ft to your movement speed while not wearing heavy armor.'},
                    {level:7, name:'Feral Instinct', blurb:'Advantage on all Initiative rolls (you go first more often). If you\'re surprised but not incapacitated, you can enter Rage and act normally on your first turn.'},
                    {level:9, name:'Brutal Critical', blurb:'When you score a critical hit, roll ONE extra weapon damage die. (Becomes 2 extra at level 13, 3 extra at level 17.)'},
                    {level:11, name:'Relentless Rage', blurb:'If you drop to 0 HP while raging, make a DC 10 CON save (DC rises by 5 each time) â€” on success you stay at 1 HP instead of going down.'},
                    {level:15, name:'Persistent Rage', blurb:'Your Rage no longer ends early from lack of attacking or damage â€” it only stops if you fall unconscious or choose to end it.'},
                    {level:18, name:'Indomitable Might', blurb:'When you make a Strength check, the minimum result equals your Strength score. You can never roll badly on STR.'},
                    {level:20, name:'Primal Champion', blurb:'Your Strength and Constitution each permanently increase by 4, and their maximums increase by 4 as well.'},
                ]
            },
            Bard: {
                color:'#ec4899', emoji:'ðŸŽµ',
                desc:'A magical performer who inspires allies and bends reality with music, words, and wit. Incredibly versatile â€” good at almost everything, and knows a spell for every situation.',
                features:[
                    {level:1, name:'Spellcasting', blurb:'You cast spells using Charisma (CHA). You know a fixed number of spells from the Bard list and can change one when you level up. Regain all slots on a long rest.'},
                    {level:1, name:'Bardic Inspiration', blurb:'Bonus action: give an ally a special die (d6 â†’ d12 as you level up) that they can add to ONE attack roll, ability check, or saving throw within the next 10 minutes. Uses = CHA modifier, refreshes on long rest (short rest at level 5).'},
                    {level:2, name:'Jack of All Trades', blurb:'Add HALF your proficiency bonus to any ability check you\'re not already proficient in. You\'re surprisingly competent at everything.'},
                    {level:2, name:'Song of Rest', blurb:'While allies rest and hear you perform, they regain extra HP when spending Hit Dice during a short rest (d6 â†’ d12 as you level).'},
                    {level:3, name:'Bard College', type:'choice', blurb:'Choose your Bard subclass. This defines your specialty and grants extra features at levels 3, 6, and 14.', choices:['Lore (more spells from any list, cutting words to debuff enemies)','Valor (medium armor, shields, extra attack, inspire allies defensively)','Glamour (fey magic, mass charm, inspiring presence)','Swords (extra attacks, blade flourishes with Bardic Inspiration)','Whispers (dark manipulation, steal voices, become a social assassin)','Eloquence (always minimum 10 on Persuasion/Deception, impossible-to-resist Bardic Inspiration)','Creation (create objects from thin air using Song of Creation)']},
                    {level:3, name:'Expertise', blurb:'Double your proficiency bonus in TWO skills you choose. You\'re exceptional at those things. Pick two more at level 10.'},
                    {level:5, name:'Font of Inspiration', blurb:'You now regain Bardic Inspiration on a SHORT rest, not just a long rest.'},
                    {level:6, name:'Countercharm', blurb:'Use your action to start a performance. While you maintain it, allies within 30 ft have advantage on saves against being charmed or frightened.'},
                    {level:10, name:'Magical Secrets', blurb:'Learn 2 spells from ANY class\'s spell list (Wizard, Cleric, Druid â€” anything). Repeat this at levels 14 and 18. This is one of the most powerful abilities in the game.'},
                    {level:20, name:'Superior Inspiration', blurb:'When you roll Initiative with 0 Bardic Inspiration uses remaining, you immediately regain 1 use.'},
                ]
            },
            Cleric: {
                color:'#f59e0b', emoji:'âœï¸',
                desc:'A divine spellcaster who channels the power of their deity. The best healer in the game, with powerful support and offensive spells. Your domain defines your specialty.',
                features:[
                    {level:1, name:'Spellcasting', blurb:'Cast spells using Wisdom (WIS). Each day you choose which spells to prepare from the full Cleric list (INT modifier + Cleric level spells). Regain all slots on a long rest.'},
                    {level:1, name:'Divine Domain', type:'choice', blurb:'Choose your subclass at level 1 (earlier than most classes!). This determines your bonus spells, Channel Divinity options, and specialty.', choices:['Life (best healer â€” your heals heal for way more)','Light (radiant blasts, blindness, protective aura)','War (extra attacks, weapon buffs, combat spells)','Trickery (deception, illusions, duplicate self)','Knowledge (learn any skill, read minds)','Nature (animal friend, plant/animal spells, poison immunity)','Tempest (lightning/thunder damage, weather control)','Grave (prevent death, curse undead, healing the near-dead)','Arcana (wizard spells, banish elementals/fey)','Order (command allies to attack, mind control)','Peace (bonding allies together, massive healing bonus)','Twilight (protect sleeping allies, darkvision aura)']},
                    {level:2, name:'Channel Divinity', blurb:'A powerful ability that recharges on a short rest. ALL Clerics get Turn Undead (force undead to flee). Your domain gives you a second, unique option.'},
                    {level:5, name:'Destroy Undead', blurb:'Undead of CR 1/2 or lower that fail Turn Undead are destroyed instantly instead of just fleeing. Gets more powerful at higher levels.'},
                    {level:10, name:'Divine Intervention', blurb:'Call upon your deity directly for miraculous help. Roll percentile dice â€” if you roll equal to or lower than your Cleric level, the DM decides what happens (can be almost anything). Once per long rest; at level 20 it always works.'},
                ]
            },
            Druid: {
                color:'#16a34a', emoji:'ðŸŒ¿',
                desc:'A nature spellcaster who can transform into animals. Flexible, powerful, and tied to the natural world. Wild Shape alone makes you one of the most versatile classes.',
                features:[
                    {level:1, name:'Spellcasting', blurb:'Cast spells using Wisdom (WIS). Prepare from the full Druid list each day. Regain slots on long rest. Druids never use metal armor or shields.'},
                    {level:1, name:'Druidic', blurb:'You know the secret Druidic language â€” a mix of sounds and signs. You can leave hidden messages only other Druids can read.'},
                    {level:2, name:'Wild Shape', blurb:'Use your action (2 uses/short rest) to magically transform into a beast you\'ve seen. You keep your mental stats and class features but use the beast\'s physical stats. Duration = half Druid level in hours.'},
                    {level:2, name:'Druid Circle', type:'choice', blurb:'Choose your Druid subclass, which changes what you specialize in and what forms you can take.', choices:['Moon (transform into powerful beasts like bears and elementals â€” the combat Druid)','Land (extra spells from your chosen terrain type, regain spell slots from Wild Shape)','Dreams (fey magic, teleportation, healing)','Shepherd (summon and buff animals and spirits)','Spores (fungal magic, animate the dead, spore aura)','Stars (star map powers, buff healing and spells, transform into star form)','Wildfire (fire damage, teleportation, fire elemental companion)']},
                    {level:18, name:'Timeless Body', blurb:'You age only 1 year for every 10 that pass, and magical aging effects don\'t affect you.'},
                    {level:18, name:'Beast Spells', blurb:'You can cast Druid spells while in Wild Shape form, as long as the spell doesn\'t require free hands.'},
                    {level:20, name:'Archdruid', blurb:'Unlimited Wild Shape uses. Also ignore verbal, somatic, and material components for spells (as long as the material has no gold cost).'},
                ]
            },
            Fighter: {
                color:'#6366f1', emoji:'âš”ï¸',
                desc:'A master of weapons and armor. The most reliable and consistent martial class â€” more attacks, more resources, and more Ability Score Improvements than anyone else.',
                features:[
                    {level:1, name:'Fighting Style', type:'choice', blurb:'Choose a combat specialty that passively improves your fighting.', choices:['Archery (+2 to ranged attack rolls)','Defense (+1 AC while wearing armor)','Dueling (+2 damage when using one weapon and no other weapons)','Great Weapon Fighting (reroll 1s and 2s on damage dice for two-handed weapons)','Protection (use reaction to impose disadvantage on an attack against a nearby ally)','Two-Weapon Fighting (add ability modifier to off-hand attack damage)']},
                    {level:1, name:'Second Wind', blurb:'Bonus action: heal yourself for 1d10 + Fighter level HP. Recharges on a short or long rest. Free emergency healing mid-fight.'},
                    {level:2, name:'Action Surge', blurb:'Once per short or long rest (twice at level 17): take one additional action on your turn. Extra attack action = devastating burst damage.'},
                    {level:3, name:'Martial Archetype', type:'choice', blurb:'Choose your Fighter subclass. This is where Fighters gain unique specializations.', choices:['Champion (critical hits on 19â€“20, then 18â€“20 â€” simple and deadly)','Battle Master (tactical maneuvers with superiority dice: trip, disarm, feint, etc.)','Eldritch Knight (learn Wizard spells, bound weapon teleports to your hand)','Arcane Archer (magical arrows with special effects: seek, bane, shadow, etc.)','Cavalier (mounted combat master, protect allies)','Samurai (fighting spirit for advantage, surge of vigor, social skills)','Rune Knight (giant-rune powers carved into your gear, grow to Large size)','Psi Warrior (telekinetic blasts, shield, movement â€” psychic powers)']},
                    {level:4, name:'Ability Score Improvement', blurb:'+2 to one ability, or +1 to two, or a Feat. Fighters get this at levels 4, 6, 8, 12, 14, 16, 19 â€” more than any other class.'},
                    {level:5, name:'Extra Attack', blurb:'Attack TWICE per Attack action. (3Ã— at level 11, 4Ã— at level 20.)'},
                    {level:9, name:'Indomitable', blurb:'Reroll a failed saving throw, keeping the new result. Once/long rest at level 9, twice at level 13, three times at level 17.'},
                ]
            },
            Monk: {
                color:'#0ea5e9', emoji:'ðŸ‘Š',
                desc:'An unarmed martial artist who channels mystical Ki energy. Incredibly fast, hard to hit, and devastates enemies with rapid strikes. Needs no weapons or armor.',
                features:[
                    {level:1, name:'Unarmored Defense', blurb:'While wearing NO armor and no shield, your AC = 10 + DEX modifier + WIS modifier. Stay unarmored to benefit.'},
                    {level:1, name:'Martial Arts', blurb:'Use DEX instead of STR for unarmed strikes and monk weapons. Unarmed strikes deal 1d4 (scaling up to 1d10 at level 17). After attacking, make one free unarmed strike as a bonus action.'},
                    {level:2, name:'Ki', blurb:'Ki points (= Monk level) refresh on a SHORT rest. Spend them to: Flurry of Blows (2 bonus unarmed strikes for 1 Ki), Patient Defense (Dodge as bonus action for 1 Ki), Step of the Wind (Dash or Disengage as bonus action for 1 Ki).'},
                    {level:2, name:'Unarmored Movement', blurb:'+10 ft speed while not in armor (grows to +30 ft at level 18). At level 9, run up walls. At level 18, run across water and vertical surfaces.'},
                    {level:3, name:'Monastic Tradition', type:'choice', blurb:'Choose your Monk subclass â€” each fundamentally changes how you use Ki.', choices:['Open Hand (push/knock down/prevent reactions after hitting, perfect tranquility)','Shadow (teleport between shadows, cast darkness, silence, pass without trace)','Four Elements (elemental Ki spells â€” fire, water, earth, air)','Long Death (fear aura, temp HP from kills, hard to kill)','Sun Soul (ranged ki blasts, radiant nova)','Drunken Master (unpredictable movement, attacks deflect blows)','Kensei (ranged or finesse weapon becomes a monk weapon)','Mercy (healing and disease removal with Ki, mask of pain)','Astral Self (project an astral form that attacks for you)']},
                    {level:3, name:'Deflect Missiles', blurb:'Reaction: reduce ranged weapon attack damage by 1d10 + DEX + Monk level. If reduced to 0, spend 1 Ki to throw it back as a ranged attack.'},
                    {level:4, name:'Slow Fall', blurb:'Reaction: reduce falling damage by 5 Ã— Monk level. Very handy with Monk\'s high mobility.'},
                    {level:5, name:'Extra Attack', blurb:'Attack TWICE per Attack action.'},
                    {level:5, name:'Stunning Strike', blurb:'After hitting with a melee attack, spend 1 Ki. Target makes a CON save or is stunned until end of your next turn â€” they lose their action and reaction, and all attacks against them have advantage.'},
                    {level:6, name:'Ki-Empowered Strikes', blurb:'Your unarmed strikes count as magical, overcoming resistance and immunity to nonmagical damage.'},
                    {level:7, name:'Evasion', blurb:'On a DEX save vs. a spell or effect (like Fireball): succeed = 0 damage, fail = half damage (instead of full).'},
                    {level:10, name:'Purity of Body', blurb:'Immune to disease and poison.'},
                    {level:14, name:'Diamond Soul', blurb:'Proficient in ALL saving throws. Also spend 1 Ki to reroll any failed save.'},
                    {level:18, name:'Empty Body', blurb:'Spend 4 Ki: become invisible for 1 minute and gain resistance to ALL damage except force. Or spend 8 Ki to cast Astral Projection (no material cost needed).'},
                    {level:20, name:'Perfect Self', blurb:'When you roll Initiative with 0 Ki remaining, you regain 4 Ki points immediately.'},
                ]
            },
            Paladin: {
                color:'#fbbf24', emoji:'ðŸ›¡ï¸',
                desc:'A holy warrior who mixes martial power with divine magic. Incredibly durable with strong healing, powerful smites, and a party-wide saving throw aura that makes everyone better.',
                features:[
                    {level:1, name:'Divine Sense', blurb:'Action: detect the presence of celestials, fiends, and undead within 60 ft until end of your next turn. Uses = 1 + CHA modifier per long rest.'},
                    {level:1, name:'Lay on Hands', blurb:'A healing pool of HP = 5 Ã— Paladin level (refreshes on long rest). Touch a creature to restore any amount from the pool. Or spend 5 points to cure one disease or poison.'},
                    {level:2, name:'Fighting Style', type:'choice', blurb:'Choose a combat specialty.', choices:['Defense (+1 AC while wearing armor)','Dueling (+2 damage one-handed)','Great Weapon Fighting (reroll 1s and 2s on two-handed weapon damage)','Protection (impose disadvantage on attacks against nearby allies)','Blessed Warrior (learn two Cleric cantrips, use CHA for them)','Blind Fighting (blindsight 10 ft)']},
                    {level:2, name:'Spellcasting', blurb:'Cast spells using Charisma (CHA). Prepare from the Paladin list each day. Regain slots on long rest.'},
                    {level:2, name:'Divine Smite', blurb:'When you hit with a melee attack, spend any spell slot to deal extra RADIANT damage: 2d8 for a 1st-level slot (+1d8 per slot level above 1st, max 5d8). +1d8 extra against undead and fiends. DECISION: save slots for smiting vs. spells.'},
                    {level:3, name:'Sacred Oath', type:'choice', blurb:'Choose your Paladin subclass. Your oath grants extra spells (always prepared), a unique Channel Divinity, and powerful later features.', choices:['Devotion (classic paladin â€” Sacred Weapon, Holy Nimbus, immune to charm)','Ancients (protect nature and joy â€” Aura of Warding resists spell damage)','Vengeance (ruthless hunter â€” Vow of Enmity advantage, relentless pursuit)','Conquest (dominance and fear â€” aura paralyzes frightened enemies)','Glory (inspire greatness, protective rush, legendary champion)','Redemption (nonviolent first, Protective of others, rebuking attackers)','Watchers (protect from extraplanar threats, enhanced senses)','Oathbreaker (dark path â€” undead commands, aura of hate for evil damage)']},
                    {level:5, name:'Extra Attack', blurb:'Attack TWICE per Attack action.'},
                    {level:6, name:'Aura of Protection', blurb:'You and ALL friendly creatures within 10 ft add your CHA modifier to every saving throw. This is one of the most powerful passive abilities in the entire game. (Range expands to 30 ft at level 18.)'},
                    {level:10, name:'Aura of Courage', blurb:'You and friendly creatures within 10 ft can\'t be frightened while you\'re conscious.'},
                    {level:11, name:'Improved Divine Smite', blurb:'Every melee weapon hit deals an extra 1d8 radiant damage, even without spending a spell slot.'},
                    {level:14, name:'Cleansing Touch', blurb:'Action: end one spell affecting you or a willing creature you touch. Uses = CHA modifier per long rest.'},
                ]
            },
            Ranger: {
                color:'#22c55e', emoji:'ðŸ¹',
                desc:'A wilderness hunter skilled in tracking, archery, and survival. Excellent at controlling enemies, finding prey, and navigating dangerous terrain. Grows more powerful out in the wild.',
                features:[
                    {level:1, name:'Favored Enemy', type:'choice', blurb:'Choose a type of creature you\'ve studied. Advantage on Survival checks to track them and History/Nature to recall info. Some versions let you learn their language.', choices:['Aberrations','Beasts','Celestials','Constructs','Dragons','Elementals','Fey','Fiends','Giants','Monstrosities','Oozes','Plants','Undead','Two humanoid races (e.g. goblins and orcs)']},
                    {level:1, name:'Natural Explorer', type:'choice', blurb:'Choose a favored terrain. In that terrain: your group can\'t become lost, you forage twice as much food, you move at full pace while stealthing and tracking, and difficult terrain doesn\'t slow your group.', choices:['Arctic','Coast','Desert','Forest','Grassland','Mountain','Swamp','Underdark']},
                    {level:2, name:'Fighting Style', type:'choice', blurb:'Choose a combat specialty.', choices:['Archery (+2 to ranged attack rolls)','Defense (+1 AC in armor)','Dueling (+2 damage one-handed)','Two-Weapon Fighting (add modifier to off-hand damage)','Druidic Warrior (learn 2 Druid cantrips, use WIS)','Blind Fighting (blindsight 10 ft)']},
                    {level:2, name:'Spellcasting', blurb:'Cast spells using Wisdom (WIS). You know a fixed number from the Ranger list (change one per level up). Regain slots on long rest.'},
                    {level:3, name:'Ranger Archetype', type:'choice', blurb:'Choose your Ranger subclass.', choices:['Hunter (defensive/offensive techniques: colossus slayer, horde breaker, etc.)','Beast Master (bond with an animal companion that fights for you)','Gloom Stalker (ambush predator, first-round bonus attack, fear in darkness)','Horizon Walker (planar magic, teleportation, ethereal damage)','Monster Slayer (detect and counter magical creatures, spellcasters)','Fey Wanderer (charisma-boosted, charming, misty wandering)','Swarmkeeper (control a swarm to move enemies, deal extra damage)']},
                    {level:5, name:'Extra Attack', blurb:'Attack TWICE per Attack action.'},
                    {level:8, name:'Land\'s Stride', blurb:'Moving through nonmagical difficult terrain costs no extra movement. Advantage on saves against plants that impede movement.'},
                    {level:10, name:'Hide in Plain Sight', blurb:'Spend 1 minute to camouflage yourself against natural surroundings. Gain +10 to Stealth while you remain still.'},
                    {level:14, name:'Vanish', blurb:'Use the Hide action as a bonus action. Also can\'t be tracked by nonmagical means (unless you choose to leave a trail).'},
                    {level:20, name:'Foe Slayer', blurb:'Once per turn when you hit your Favored Enemy, add your WIS modifier to the attack roll OR the damage roll.'},
                ]
            },
            Rogue: {
                color:'#71717a', emoji:'ðŸ—¡ï¸',
                desc:'A sneaky expert who deals massive burst damage with Sneak Attack. Extraordinary skill outside combat, with Expertise making you the best in the party at chosen tasks.',
                features:[
                    {level:1, name:'Expertise', blurb:'Double your proficiency bonus in TWO chosen skills. You\'re truly exceptional at those. Choose two more at level 6.'},
                    {level:1, name:'Sneak Attack', blurb:'Once per turn, deal extra damage when you have ADVANTAGE on the attack OR when an ally is within 5 ft of your target. Starts at 1d6, grows to 10d6 at level 19.'},
                    {level:1, name:'Thieves\' Cant', blurb:'A secret mix of jargon, signs, and codes shared among criminals and rogues. You can hide messages in normal conversation only other Thieves\' Cant speakers can understand.'},
                    {level:2, name:'Cunning Action', blurb:'Bonus action each turn to Dash, Disengage, or Hide. This lets you attack and move safely every single round.'},
                    {level:3, name:'Roguish Archetype', type:'choice', blurb:'Choose your Rogue subclass.', choices:['Thief (faster item use, climb speed, fake magic items at level 13)','Assassin (triple damage against surprised enemies, perfect impostor)','Arcane Trickster (mix Wizard spells with Sneak Attack â€” Mage Hand steals)','Inquisitive (spot lies, insight attacks, unerring eye)','Mastermind (use Help as bonus action from 30 ft, mimic voices, spy network)','Scout (always first in Initiative, disengage from one enemy as reaction)','Soulknife (psionic blades, telepathy, read minds)','Swashbuckler (dual threat â€” deal Sneak Attack while fighting alone, add CHA to Initiative)','Phantom (whispers of the dead, steal soul fragments for power)']},
                    {level:5, name:'Uncanny Dodge', blurb:'Reaction: when an attacker you CAN SEE hits you, halve the incoming damage.'},
                    {level:7, name:'Evasion', blurb:'On DEX saves vs. spells like Fireball: success = 0 damage, failure = half damage.'},
                    {level:11, name:'Reliable Talent', blurb:'When you make an ability check using a skill you\'re proficient in, treat any d20 roll of 9 or lower as a 10. You can\'t fail at your specialties.'},
                    {level:14, name:'Blindsense', blurb:'If you can hear, you automatically know the location of any hidden or invisible creature within 10 ft of you.'},
                    {level:15, name:'Slippery Mind', blurb:'Gain proficiency in Wisdom saving throws.'},
                    {level:18, name:'Elusive', blurb:'No attack roll has advantage against you while you\'re not incapacitated. You\'re nearly impossible to catch off-guard.'},
                    {level:20, name:'Stroke of Luck', blurb:'Turn a missed attack into a hit, OR turn a failed ability check into a 20. Once per short or long rest.'},
                ]
            },
            Sorcerer: {
                color:'#f97316', emoji:'ðŸ”¥',
                desc:'An innate spellcaster born with raw magical power. Fewer spells than a Wizard, but Metamagic lets you bend and twist those spells in ways nobody else can.',
                features:[
                    {level:1, name:'Spellcasting', blurb:'Cast spells using Charisma (CHA). You know a fixed number of spells (can\'t prepare different ones each day, but can swap one per level). Regain slots on long rest.'},
                    {level:1, name:'Sorcerous Origin', type:'choice', blurb:'Choose the source of your innate magic power. This is your subclass, taken at level 1.', choices:['Draconic Bloodline (dragon ancestor: natural armor AC 13+DEX, damage bonus, wings at 14)','Wild Magic (random surges of wild magic â€” chaos that\'s surprisingly fun)','Storm Sorcery (wind walk, lightning speed, weather control)','Shadow Magic (darkness, shadow hound, resistance to death)','Aberrant Mind (telepathy, psychic/psionic spells from birth)','Clockwork Soul (order magic, cancel advantage/disadvantage, summon mechanus gear)']},
                    {level:2, name:'Font of Magic', blurb:'Sorcery Points (= Sorcerer level, refresh on long rest). Spend 2 to make a spell slot. Or convert a slot to Sorcery Points. These also fuel Metamagic.'},
                    {level:3, name:'Metamagic', type:'choice', blurb:'Choose 2 ways to twist your spells (more at levels 10 and 17). Spend Sorcery Points to activate.', choices:['Careful (protect allies from your own area spells)','Distant (double a spell\'s range)','Empowered (reroll some damage dice, keep higher)','Extended (double a spell\'s duration)','Heightened (give target disadvantage on first save against spell)','Quickened (cast a spell as a bonus action instead of action)','Subtle (cast with no verbal or somatic components â€” hard to counter or notice)','Twinned (target two creatures with a single-target spell)','Seeking (if you miss or spell fails, spend 2 to reroll once)','Transmuted (change a spell\'s damage type)']},
                    {level:4, name:'Ability Score Improvement', blurb:'+2 to one ability, +1 to two, or a Feat. At levels 4, 8, 12, 16, 19.'},
                    {level:20, name:'Sorcerous Restoration', blurb:'Regain 4 expended Sorcery Points when you finish a short rest.'},
                ]
            },
            Warlock: {
                color:'#7c3aed', emoji:'ðŸ‘ï¸',
                desc:'A spellcaster who made a pact with a powerful supernatural being. Very few spell slots but they ALWAYS recharge on a SHORT rest. Powerful at-will abilities mean you\'re never truly out of tricks.',
                features:[
                    {level:1, name:'Otherworldly Patron', type:'choice', blurb:'Choose who (or what) you made your pact with. Your patron defines your theme, bonus spells, and unique features at levels 1, 6, 10, and 14.', choices:['Fiend (fire and necrotic power, temp HP from kills, eventually immunity to fire)','Great Old One (eldritch horror â€” telepathy, read minds, remote communication)','Archfey (fey charm â€” charm and fear, beguiling defenses)','Hexblade (make a pact with a weapon â€” use CHA for attacks, summon ghost warrior)','Fathomless (deep-sea patron â€” tentacle, underwater breathing, water teleport)','Genie (choose genie type: Dao/Djinni/Efreeti/Marid for earth/air/fire/water)','Undying (life clinging magic â€” age slowly, resist death, become undead-lite)','Celestial (divine Warlock â€” healing, sacred flame, divine fire blasts)']},
                    {level:1, name:'Pact Magic', blurb:'Your spell slots are very limited (1 at level 1, up to 4 slots at level 11). BUT they always recharge after a SHORT rest. All your slots are the same level, which increases to 5th level at level 9.'},
                    {level:2, name:'Eldritch Invocations', blurb:'Choose 2 special Warlock abilities (more as you level). Examples: Agonizing Blast (+CHA to Eldritch Blast damage), Devil\'s Sight (see in magical darkness 120 ft), Mask of Many Faces (Disguise Self at will), Repelling Blast (push enemies 10 ft).'},
                    {level:3, name:'Pact Boon', type:'choice', blurb:'A special gift from your patron.', choices:['Pact of the Chain (superior familiar: imp, pseudodragon, quasit, or sprite)','Pact of the Blade (summon a magic weapon to your hand; it\'s always attuned to you)','Pact of the Tome (Book of Shadows with 3 cantrips from any class, plus ritual magic)','Pact of the Talisman (an amulet that helps you or allies with failed rolls)']},
                    {level:11, name:'Mystic Arcanum', blurb:'Once per long rest, cast one spell of 6th level without using a slot. Gain a new level (7th, 8th, 9th) at levels 13, 15, and 17.'},
                    {level:20, name:'Eldritch Master', blurb:'Spend 1 minute communing with your patron to regain all Pact Magic slots. Once per long rest.'},
                ]
            },
            Wizard: {
                color:'#3b82f6', emoji:'ðŸ“š',
                desc:'The ultimate spellcaster who learns magic through study. The largest and most flexible spell list in the game. Copy spells into your spellbook from scrolls and other books â€” you can always learn more.',
                features:[
                    {level:1, name:'Spellcasting', blurb:'Cast spells using Intelligence (INT). Your spellbook starts with 6 spells. Each day prepare INT modifier + Wizard level spells from your book â€” any spells in it are fair game. Regain slots on long rest. Copy new spells from scrolls and enemy spellbooks.'},
                    {level:1, name:'Arcane Recovery', blurb:'Once per day after a short rest, recover spell slots whose combined level is up to HALF your Wizard level (rounded up). Can\'t recover 6th level or higher slots this way.'},
                    {level:2, name:'Arcane Tradition', type:'choice', blurb:'Choose your school of magical specialization. You get a feature now, at level 6, and at levels 10 and 14.', choices:['Evocation (devastate with maximized damage spells, protect allies from your blasts)','Abjuration (powerful magical wards, absorb spells, resistance to spell damage)','Illusion (make your illusions real, perfect copies, malleable images)','Conjuration (teleport short distances, summon creatures and objects)','Divination (Portent: roll 2 dice each day and substitute any roll with them)','Enchantment (bend minds, share charm effects, hold enemies while charming others)','Necromancy (raise more and stronger undead, gain HP from killing)','Transmutation (transform substances, minor alchemy, grow very old or very young)','Bladesinging (mix martial and magic â€” AC bonus, Concentration protection, extra attack)','War Magic (arcane deflection, tactical wit bonus to Initiative, spells as reactions)','Order of Scribes (your spellbook is a magical creature, change spell damage types)']},
                    {level:18, name:'Spell Mastery', blurb:'Choose one 1st-level and one 2nd-level spell from your spellbook. Cast each at their lowest level WITHOUT using a spell slot, as many times as you want.'},
                    {level:20, name:'Signature Spells', blurb:'Choose two 3rd-level spells. They\'re always prepared and can be cast at 3rd level once per short rest for FREE.'},
                ]
            },
        };

        function renderFeaturesTab() {
            const c = (activeCharIdx >= 0 && characters[activeCharIdx]) ? characters[activeCharIdx] : null;
            const panel = document.getElementById('featuresPanel');
            if (!c) { panel.innerHTML = '<p style="font-size:0.85rem;color:var(--text-dim);">No character selected. Create or select a character first.</p>'; return; }
            const cls = c.class || 'Fighter';
            const level = parseInt(c.level) || 1;
            const data = CLASS_FEATURES[cls];
            if (!data) { panel.innerHTML = `<p style="font-size:0.85rem;color:var(--text-dim);">No feature data for ${cls} yet.</p>`; return; }
            if (!c.featureChoices) c.featureChoices = {};

            const visible = data.features.filter(f => f.level <= level);
            let html = `<div class="class-intro">
                <div class="class-intro-name">${data.emoji} ${cls}</div>
                <div class="class-intro-desc">${data.desc}</div>
            </div>`;
            if (visible.length === 0) {
                html += '<p style="font-size:0.85rem;color:var(--text-dim);">No features yet â€” increase your level in the Basics tab.</p>';
            }
            visible.forEach(f => {
                const choiceKey = `${cls}_${f.name}`;
                const savedChoice = c.featureChoices[choiceKey] || '';
                let choiceHTML = '';
                if (f.type === 'choice' && f.choices) {
                    const opts = f.choices.map(ch => `<option value="${ch}" ${savedChoice === ch ? 'selected' : ''}>${ch}</option>`).join('');
                    choiceHTML = `<div class="feature-choice">
                        <label>Your choice:</label>
                        <select onchange="saveFeatureChoice('${choiceKey}', this.value)">
                            <option value="">â€” Choose â€”</option>${opts}
                        </select>
                    </div>`;
                }
                html += `<div class="feature-card">
                    <div class="feature-card-header">
                        <span class="feature-lvl-badge">Lv ${f.level}</span>
                        <span class="feature-name">${f.name}</span>
                    </div>
                    <div class="feature-blurb">${f.blurb}</div>
                    ${choiceHTML}
                </div>`;
            });
            const locked = data.features.filter(f => f.level > level);
            if (locked.length > 0) {
                html += `<div style="margin-top:1rem;padding:0.6rem 0.75rem;background:var(--bg-dark);border-radius:8px;border:1px dashed var(--border);">
                    <p style="font-size:0.78rem;color:var(--text-dim);margin-bottom:0.3rem;">ðŸ”’ Coming at higher levels:</p>
                    <p style="font-size:0.78rem;color:var(--text-dim);">${locked.map(f=>`<b>Lv ${f.level}</b> ${f.name}`).join(' Â· ')}</p>
                </div>`;
            }
            panel.innerHTML = html;
        }

        function saveFeatureChoice(key, value) {
            const c = (activeCharIdx >= 0 && characters[activeCharIdx]) ? characters[activeCharIdx] : null;
            if (!c) return;
            if (!c.featureChoices) c.featureChoices = {};
            c.featureChoices[key] = value;
            saveCharactersToStorage();
        }

        // =============================================
        // BOOT
        // =============================================
        try {
            init();
        } catch (err) {
            console.error('âŒ Init failed:', err);
            alert('Error loading VTT: ' + err.message);
        }
    </script>

    <!-- ===== SUB-MAP EDITOR MODAL (DM only) ===== -->
    <div class="submap-modal" id="subMapEditorModal">
        <div class="submap-modal-content">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
                <h2 id="subMapEditorTitle" style="color:var(--gold); margin:0; font-family:'Cinzel',serif; font-size:1.3rem;">ðŸ”ï¸ Landmark Illustration</h2>
                <div style="display:flex; gap:0.5rem;">
                    <button class="btn btn-primary btn-small" onclick="saveAndCloseSubMapEditor()">ðŸ’¾ Save View</button>
                    <button class="btn btn-small" onclick="closeSubMapEditor()">âœ• Close</button>
                </div>
            </div>
            <div class="submap-toolbar">
                <div class="tool-btn" id="subMapBrushBtn" onclick="setSubMapTool('brush')" title="Brush">ðŸ–Œï¸ Brush</div>
                <div class="tool-btn" id="subMapFillBtn" onclick="setSubMapTool('fill')" title="Fill">ðŸª£ Fill</div>
                <div class="tool-btn" id="subMapEraserBtn" onclick="setSubMapTool('eraser')" title="Eraser">â¬œ Erase</div>
                <div style="width:1px; background:var(--border); margin:0 0.25rem; self-align:stretch;"></div>
                <label style="color:var(--text-dim); font-size:0.8rem;">Color:</label>
                <input type="color" id="subMapColorPicker" value="#4a7c59" oninput="subMapColor=this.value" style="width:36px; height:34px; padding:2px; background:transparent; border:1px solid var(--border); border-radius:4px; cursor:pointer;">
                <label style="color:var(--text-dim); font-size:0.8rem;">Size:</label>
                <input type="range" id="subMapSizeSlider" min="1" max="50" value="8" oninput="subMapSize=parseInt(this.value); document.getElementById('subMapSizeDisplay').textContent=this.value+'px';" style="width:80px; accent-color:var(--accent);">
                <span id="subMapSizeDisplay" style="color:var(--text-dim); font-size:0.8rem; min-width:28px;">8px</span>
                <div style="width:1px; background:var(--border); margin:0 0.25rem;"></div>
                <button class="btn btn-small btn-danger" onclick="clearSubMap()">ðŸ—‘ï¸ Clear</button>
            </div>
            <canvas id="subMapCanvas" width="800" height="500"></canvas>
            <p style="color:var(--text-dim); font-size:0.78rem; margin-top:0.5rem; text-align:center;">
                Draw the vertical illustration players see when approaching this landmark.<br>
                Once saved, the stamp will <span class="stamp-glow-hint">âœ¨ glow</span> â€” players can click it to view this scene.
            </p>
        </div>
    </div>

    <!-- ===== SUB-MAP VIEWER MODAL (Players & DM preview) ===== -->
    <div class="submap-modal" id="subMapViewerModal">
        <div class="submap-modal-content">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
                <h2 id="subMapViewerTitle" style="color:var(--gold); margin:0; font-family:'Cinzel',serif; font-size:1.3rem;">ðŸ”ï¸ Approaching...</h2>
                <button class="btn btn-small" onclick="closeSubMapViewer()">âœ• Close</button>
            </div>
            <canvas id="subMapViewerCanvas" width="800" height="500"></canvas>
        </div>
    </div>

    <!-- FOOTER -->
    <div style="position:fixed;bottom:0;left:0;right:0;text-align:center;padding:0.3rem 0;background:rgba(0,0,0,0.7);color:#a855f7;font-size:0.72rem;font-weight:700;letter-spacing:0.14em;z-index:9999;pointer-events:none;">CREATED BY ROBERT FOR WIZZY</div>
</body>
</html>
