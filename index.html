<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The Fractured Sky VTT v4.0 - FINAL BUILD</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0e1a;
            --bg-card: #151928;
            --bg-hover: #1f2537;
            --accent: #8b5cf6;
            --accent-secondary: #ec4899;
            --gold: #fbbf24;
            --text: #e5e7eb;
            --text-dim: #9ca3af;
            --border: rgba(139, 92, 246, 0.2);
            --success: #10b981;
            --danger: #ef4444;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }

        /* HEADER */
        .header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            position: relative;
            z-index: 100;
        }

        .title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .campaign-badge {
            padding: 0.5rem 1rem;
            background: var(--bg-hover);
            border-radius: 8px;
            border: 1px solid var(--border);
            color: var(--gold);
            font-weight: 600;
            font-size: 0.9rem;
        }

        /* BUTTONS */
        .btn {
            padding: 0.6rem 1.2rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            font-family: 'Inter', sans-serif;
        }

        .btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            transform: translateY(-1px);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            border: none;
            color: white;
        }

        .btn-small {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        .btn-success {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }

        /* WELCOME SCREEN */
        .welcome-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f3a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        .welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .welcome-content {
            text-align: center;
            padding: 3rem;
        }

        .welcome-title {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            color: var(--text-dim);
            margin-bottom: 3rem;
        }

        .welcome-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .welcome-btn {
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: 12px;
            cursor: pointer;
            border: none;
            font-weight: 600;
            transition: all 0.3s;
            font-family: 'Inter', sans-serif;
        }

        .welcome-btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            color: white;
        }

        .welcome-btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.5);
        }

        .welcome-btn-secondary {
            background: var(--bg-card);
            color: var(--text);
            border: 2px solid var(--border);
        }

        .welcome-btn-secondary:hover {
            border-color: var(--accent);
            background: var(--bg-hover);
        }

        /* MODALS */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.3s;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .modal-content {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .modal-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-dim);
            font-weight: 500;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.95rem;
            font-family: 'Inter', sans-serif;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .error, .success, .info {
            padding: 0.75rem;
            border-radius: 6px;
            margin: 1rem 0;
            display: none;
        }

        .error { background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); color: var(--danger); }
        .success { background: rgba(16, 185, 129, 0.1); border: 1px solid var(--success); color: var(--success); }
        .info { background: rgba(139, 92, 246, 0.1); border: 1px solid var(--accent); color: var(--accent); }

        .error.show, .success.show, .info.show { display: block; }

        /* CONNECTION TAB */
        .connection-tab-container {
            position: fixed;
            top: 70px;
            left: 20px;
            z-index: 501;
            display: none;
        }

        .connection-tab {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-top: none;
            padding: 0.5rem 1.5rem;
            border-radius: 0 0 8px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .connection-tab:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .connection-tab.open {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .connection-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--danger);
        }

        .connection-indicator.connected {
            background: var(--success);
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* CONNECTION PANEL */
        .connection-panel {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border-bottom: 2px solid var(--border);
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s;
            z-index: 500;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }

        .connection-panel.open {
            max-height: 400px;
            padding: 1.5rem;
        }

        .connection-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .connection-section {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
        }

        .connection-section h3 {
            color: var(--gold);
            margin-bottom: 0.75rem;
            font-size: 1rem;
        }

        .room-code {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-family: monospace;
            font-size: 0.85rem;
            word-break: break-all;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            color: var(--accent);
        }

        .room-code:hover {
            border-color: var(--accent);
            transform: scale(1.02);
        }

        .user-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .user-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: var(--bg-dark);
            border-radius: 6px;
        }

        .user-role {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: var(--accent);
            color: white;
        }

        /* MAIN LAYOUT */
        .container {
            display: flex;
            height: calc(100vh - 70px);
        }

        .main-area {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .tabletop {
            flex: 1;
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }

        .tabletop-header {
            padding: 1rem 1.5rem;
            background: var(--bg-hover);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-name {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            background: linear-gradient(135deg, var(--gold), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .slider {
            width: 120px;
            height: 4px;
            background: var(--bg-dark);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        /* CANVAS */
        .canvas-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a1f2e 0%, var(--bg-dark) 100%);
            overflow: hidden;
        }

        #mainCanvas {
            display: block;
            cursor: grab;
        }

        #mainCanvas:active {
            cursor: grabbing;
        }

        /* TOKEN STAGING ZONE */
        .staging-zone {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 2px solid var(--gold);
            border-radius: 12px;
            padding: 1rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            max-width: 80%;
            overflow-x: auto;
            z-index: 50;
        }

        .staging-label {
            font-size: 0.85rem;
            color: var(--gold);
            font-weight: 600;
            white-space: nowrap;
        }

        .staging-tokens {
            display: flex;
            gap: 0.5rem;
        }

        .token-item {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--border);
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            flex-shrink: 0;
            transition: all 0.2s;
            position: relative;
        }

        .token-item:hover {
            transform: scale(1.1);
            border-color: var(--accent);
            z-index: 10;
        }

        .token-owner {
            position: absolute;
            bottom: -20px;
            font-size: 0.65rem;
            color: var(--text-dim);
            white-space: nowrap;
        }

        /* MINIMAP NAVIGATOR */
        .minimap-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 600;
            cursor: move;
        }

        .minimap-container.docked {
            cursor: default;
        }

        .minimap {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 0.75rem;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            width: 180px;
            transition: all 0.3s;
        }

        .minimap.collapsed {
            width: auto;
            padding: 0.5rem 1rem;
        }

        .minimap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .minimap.collapsed .minimap-header {
            margin-bottom: 0;
        }

        .minimap-title {
            font-size: 0.75rem;
            color: var(--gold);
            font-weight: 600;
        }

        .minimap-controls {
            display: flex;
            gap: 0.25rem;
        }

        .minimap-btn {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            width: 20px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: all 0.2s;
        }

        .minimap-btn:hover {
            background: var(--accent);
            color: white;
        }

        .minimap-content {
            display: block;
        }

        .minimap.collapsed .minimap-content {
            display: none;
        }

        .minimap-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 2px;
            margin-bottom: 0.5rem;
        }

        .minimap-cell {
            aspect-ratio: 1;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s;
            position: relative;
        }

        .minimap-cell:hover {
            border-color: var(--accent);
            transform: scale(1.1);
            z-index: 1;
        }

        .minimap-cell.has-content {
            background: var(--accent);
            opacity: 0.6;
        }

        .minimap-cell.locked::after {
            content: 'üîí';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
        }

        .minimap-cell.current {
            border: 2px solid var(--gold);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        .minimap-actions {
            display: flex;
            gap: 0.25rem;
        }

        .minimap-action-btn {
            flex: 1;
            padding: 0.4rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.2s;
            color: var(--text);
            text-align: center;
        }

        .minimap-action-btn:hover {
            background: var(--accent);
            color: white;
        }

        /* DM PANEL */
        .dm-panel {
            width: 420px;
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s;
            box-shadow: -4px 0 24px rgba(0,0,0,0.4);
        }

        .dm-panel.open {
            transform: translateX(0);
        }

        .dm-header {
            position: sticky;
            top: 0;
            background: var(--bg-hover);
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .dm-header h2 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
        }

        .dm-content {
            padding: 1rem;
        }

        .section {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s;
        }

        .section.active {
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
            background: rgba(139, 92, 246, 0.05);
        }

        .section h3 {
            margin-bottom: 0.75rem;
            color: var(--gold);
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin: 0.75rem 0;
        }

        .tool-btn {
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .tool-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0.75rem 0;
        }

        .control-row label {
            min-width: 60px;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        input[type="color"] {
            width: 50px;
            height: 36px;
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            background: var(--bg-dark);
        }

        .grid-selector {
            background: var(--bg-dark);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border: 2px solid var(--border);
        }

        .grid-info {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .grid-info .current {
            color: var(--accent);
            font-weight: 600;
            font-size: 1.1rem;
        }

        .grid-nav {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.5rem;
        }

        #mapCanvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: white;
            cursor: crosshair;
            margin: 0.5rem 0;
        }

        .history-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .asset-indicator {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--text-dim);
            text-align: center;
            margin-top: 0.5rem;
        }

        .asset-indicator .current-asset {
            color: var(--accent);
            font-weight: 600;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .fog-groups {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin: 0.75rem 0;
        }

        .fog-group-item {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 0.75rem;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fog-group-item.active {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }

        .fog-group-name {
            font-weight: 600;
            color: var(--text);
        }

        .fog-group-controls {
            display: flex;
            gap: 0.5rem;
        }

        .pending-requests {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .request-item {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .request-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .request-name {
            font-weight: 600;
            color: var(--text);
        }

        .request-detail {
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .request-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }

        /* UTILITY */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- WELCOME SCREEN -->
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-content">
            <div class="welcome-title">‚öîÔ∏è THE FRACTURED SKY</div>
            <div class="welcome-subtitle">Ultimate Virtual Tabletop v4.0 FINAL</div>
            <div class="welcome-buttons">
                <button class="welcome-btn welcome-btn-primary" onclick="showDMLogin()">üé≠ Create Room (DM)</button>
                <button class="welcome-btn welcome-btn-secondary" onclick="showPlayerLogin()">üë§ Join Room (Player)</button>
            </div>
            <p style="position: absolute; bottom: 20px; width: 100%; text-align: center; font-size: 0.75rem; color: var(--text-dim);">
                v4.0 Final Build ‚Ä¢ Click a button above
            </p>
        </div>
    </div>

    <!-- DM LOGIN MODAL -->
    <div class="modal" id="dmModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üßô</div>
                <div class="modal-title">Dungeon Master</div>
            </div>
            <form onsubmit="dmLogin(event)">
                <div class="form-group">
                    <label>USERNAME</label>
                    <input type="text" id="dmUser" placeholder="Wizard" required>
                </div>
                <div class="form-group">
                    <label>PASSWORD</label>
                    <input type="password" id="dmPass" placeholder="FracturedSky2025!" required>
                </div>
                <div class="form-group">
                    <label>SESSION ID (Optional - leave blank for new session)</label>
                    <input type="text" id="sessionId" placeholder="Paste previous session ID to rejoin">
                    <p style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.25rem;">üí° Save your session ID to rejoin this campaign later!</p>
                </div>
                <div class="error" id="dmError">Invalid credentials</div>
                <div class="info" id="dmInfo" style="display: none;">Rejoining previous session...</div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">LOGIN & CREATE ROOM</button>
                <button type="button" class="btn" onclick="closeDMModal()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <!-- PLAYER LOGIN MODAL -->
    <div class="modal" id="playerModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üë§</div>
                <div class="modal-title">Join as Player</div>
            </div>
            <form onsubmit="playerLogin(event)">
                <div class="form-group">
                    <label>YOUR NAME</label>
                    <input type="text" id="playerName" placeholder="Enter character name" required>
                </div>
                <div class="form-group">
                    <label>ROOM CODE</label>
                    <input type="text" id="roomCodeInput" placeholder="Paste full room code" required>
                </div>
                <div class="error" id="playerError">Connection failed</div>
                <div class="success" id="playerSuccess">Request sent! Waiting for DM approval...</div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">REQUEST TO JOIN</button>
                <button type="button" class="btn" onclick="closePlayerModal()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
            </form>
        </div>
    </div>

    <!-- TOKEN REQUEST MODAL (DM) -->
    <div class="modal" id="tokenRequestModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üé≤</div>
                <div class="modal-title">Create Token</div>
            </div>
            <div class="form-group">
                <label>TOKEN TYPE</label>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <button class="btn btn-primary" onclick="setTokenType('emoji')" id="emojiTokenBtn" style="flex: 1;">Emoji</button>
                    <button class="btn" onclick="setTokenType('image')" id="imageTokenBtn" style="flex: 1;">Image</button>
                </div>
            </div>
            <div id="emojiTokenInputs">
                <div class="form-group">
                    <label>TOKEN EMOJI</label>
                    <input type="text" id="tokenEmoji" placeholder="‚öîÔ∏è" maxlength="2">
                </div>
            </div>
            <div id="imageTokenInputs" style="display: none;">
                <div class="form-group">
                    <label>TOKEN IMAGE</label>
                    <input type="file" id="tokenImageFile" accept="image/*" style="width: 100%; padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text);">
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-dim);">Upload PNG, JPG, or GIF (will be resized to 60x60)</div>
                </div>
            </div>
            <div class="form-group">
                <label>TOKEN COLOR</label>
                <input type="color" id="tokenColor" value="#e74c3c">
            </div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="createToken()" style="flex: 1;">Create</button>
                <button class="btn" onclick="closeTokenModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- FOG GROUP MODAL -->
    <div class="modal" id="fogGroupModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üë•</div>
                <div class="modal-title">Create Fog Group</div>
            </div>
            <div class="form-group">
                <label>GROUP NAME</label>
                <input type="text" id="fogGroupName" placeholder="e.g., Party A, Solo Explorer" required>
            </div>
            <div class="info">Players in this group will share fog visibility</div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="createFogGroup()" style="flex: 1;">Create Group</button>
                <button class="btn" onclick="closeFogGroupModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- HEADER -->
    <div class="header">
        <div class="title">‚öîÔ∏è THE FRACTURED SKY</div>
        <div class="campaign-badge" id="campaignBadge" style="display: none;">Campaign Name</div>
        <div class="header-actions">
            <span id="firebaseStatus" style="font-size: 0.75rem; color: var(--text-dim); display: none;"></span>
            <button class="btn" id="dmControlsBtn" onclick="toggleDMPanel()" style="display: none;">üé≠ DM Controls</button>
        </div>
    </div>

    <!-- CONNECTION TAB -->
    <div class="connection-tab-container" id="connectionTabContainer">
        <div class="connection-tab" onclick="toggleConnectionPanel()" id="connectionTab">
            <div class="connection-indicator" id="tabIndicator"></div>
            <span id="tabText">Connection</span>
            <span id="tabArrow">‚ñº</span>
        </div>
    </div>

    <!-- CONNECTION PANEL -->
    <div class="connection-panel" id="connectionPanel">
        <div class="connection-content">
            <div class="connection-section" id="roomCodeSection" style="display: none;">
                <h3>üé≠ Room Code</h3>
                <p style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Share this code with players:</p>
                <div class="room-code" id="roomCode" onclick="copyRoomCode()" style="user-select: text; cursor: pointer;" title="Click to copy">----</div>
                <p style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem; text-align: center;">
                    üí° Click to copy ‚Ä¢ Or select text manually (Ctrl+C)
                </p>
            </div>
            <div class="connection-section">
                <h3>üì° Status</h3>
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                    <div class="connection-indicator" id="statusIndicator"></div>
                    <span id="statusText">Disconnected</span>
                </div>
            </div>
            <div class="connection-section" id="firebaseSection" style="display: none;">
                <h3>‚òÅÔ∏è Cloud Sync</h3>
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px; margin-bottom: 0.5rem;">
                    <span id="firebaseStatusPanel" style="font-size: 0.85rem; color: var(--text-dim);">Not connected</span>
                </div>
                <button class="btn btn-primary" onclick="saveToFirebase()" style="width: 100%; margin-bottom: 0.25rem;">üíæ Save Now</button>
                <p style="font-size: 0.7rem; color: var(--text-dim); text-align: center;">Auto-saves 3s after changes</p>
            </div>
            <div class="connection-section">
                <h3>üë• Connected Users</h3>
                <div class="user-list" id="userList">
                    <p style="font-size: 0.85rem; color: var(--text-dim);">No users</p>
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN CONTAINER -->
    <div class="container">
        <div class="main-area">
            <div class="tabletop">
                <div class="tabletop-header">
                    <div class="session-name">Session</div>
                    <div class="zoom-controls">
                        <span style="font-size: 0.9rem; color: var(--text-dim);">Zoom:</span>
                        <input type="range" class="slider" id="zoomSlider" min="25" max="200" value="100" oninput="setZoom(this.value)">
                        <span id="zoomValue" style="min-width: 50px; font-size: 0.9rem;">100%</span>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                    
                    <!-- TOKEN STAGING ZONE -->
                    <div class="staging-zone" id="stagingZone" style="display: none;">
                        <div class="staging-label">üé≤ TOKENS</div>
                        <div class="staging-tokens" id="stagingTokens"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DM PANEL -->
        <div class="dm-panel" id="dmPanel">
            <div class="dm-header">
                <h2>üé≠ DM Controls</h2>
                <button class="btn btn-small" onclick="toggleDMPanel()">‚úï</button>
            </div>
            <div class="dm-content">
                <!-- CAMPAIGN MANAGER -->
                <div class="section" id="campaignSection">
                    <h3>üíæ Campaign Manager</h3>
                    
                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Export/Import Campaign:</div>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="exportCampaign()" style="flex: 1;">üì• Export .JSON</button>
                            <button class="btn" onclick="document.getElementById('importFile').click()" style="flex: 1;">üì§ Import .JSON</button>
                        </div>
                        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importCampaign(event)">
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Cloud Campaign Link (Google Drive, Dropbox, etc.):</div>
                        <input type="text" id="cloudLink" placeholder="Paste shareable link here" style="width: 100%; padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 0.85rem; margin-bottom: 0.5rem;">
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="saveCloudLink()" style="flex: 1;">üíæ Save Link</button>
                            <button class="btn" onclick="openCloudLink()" style="flex: 1;">üîó Open Link</button>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                            üí° Upload exported .json to Google Drive ‚Üí Get shareable link ‚Üí Paste here ‚Üí Save<br>
                            Other DMs can use this link to access the campaign!
                        </div>
                    </div>

                    <div class="success" id="exportSuccess">Campaign exported!</div>
                    <div class="success" id="importSuccess">Campaign imported!</div>
                    <div class="success" id="linkSuccess">Cloud link saved!</div>
                    <div class="error" id="importError">Import failed. Check file format.</div>
                </div>

                <!-- PLAYER REQUESTS -->
                <div class="section" id="requestsSection">
                    <h3>üì¨ Player Requests</h3>
                    <div class="pending-requests" id="pendingRequests">
                        <p style="font-size: 0.85rem; color: var(--text-dim);">No pending requests</p>
                    </div>
                </div>

                <!-- MAP BUILDER -->
                <div class="section active" id="mapSection">
                    <h3>üó∫Ô∏è Map Builder</h3>
                    
                    <div class="grid-selector">
                        <div class="grid-info">
                            Cell: <span class="current" id="currentCell">Center</span>
                        </div>
                        <div class="grid-nav">
                            <button class="btn btn-small" onclick="selectCell(0,0)">‚Üñ</button>
                            <button class="btn btn-small" onclick="selectCell(1,0)">‚Üë</button>
                            <button class="btn btn-small" onclick="selectCell(2,0)">‚Üó</button>
                            <button class="btn btn-small" onclick="selectCell(0,1)">‚Üê</button>
                            <button class="btn btn-small" onclick="selectCell(1,1)">‚óè</button>
                            <button class="btn btn-small" onclick="selectCell(2,1)">‚Üí</button>
                            <button class="btn btn-small" onclick="selectCell(0,2)">‚Üô</button>
                            <button class="btn btn-small" onclick="selectCell(1,2)">‚Üì</button>
                            <button class="btn btn-small" onclick="selectCell(2,2)">‚Üò</button>
                        </div>
                    </div>

                    <div class="history-controls">
                        <button class="btn btn-small" onclick="undo()" id="undoBtn" disabled>‚Ü∂ Undo</button>
                        <button class="btn btn-small" onclick="redo()" id="redoBtn" disabled>‚Ü∑ Redo</button>
                    </div>

                    <div class="tool-grid">
                        <div class="tool-btn active" onclick="setTool('brush')" id="brushBtn">üñåÔ∏è<br>Brush</div>
                        <div class="tool-btn" onclick="setTool('fill')" id="fillBtn">ü™£<br>Fill</div>
                        <div class="tool-btn" onclick="setTool('eraser')" id="eraserBtn">üßπ<br>Erase</div>
                        <div class="tool-btn" onclick="setTool('stamp')" id="stampBtn">üè∞<br>Stamp</div>
                        <div class="tool-btn" onclick="setTool('image')" id="imageBtn">üñºÔ∏è<br>Image</div>
                        <div class="tool-btn" onclick="setTool('select')" id="selectBtn">üëÜ<br>Select</div>
                    </div>

                    <div class="asset-indicator">
                        Active: <span class="current-asset" id="currentAsset">Brush</span>
                    </div>

                    <!-- STAMP LIBRARY -->
                    <div id="stampLibraryToggle" style="display: none; margin: 0.75rem 0;">
                        <button class="btn" onclick="toggleStampLibrary()" style="width: 100%;">üìö Open Stamp Library</button>
                    </div>

                    <!-- ERASER MODE TOGGLE -->
                    <div id="eraserOptions" style="display: none; margin: 0.75rem 0; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px;">
                        <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Eraser Mode:</div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-small btn-primary" onclick="setEraserMode('content')" id="eraseContentBtn" style="flex: 1;">Content Only</button>
                            <button class="btn btn-small" onclick="setEraserMode('all')" id="eraseAllBtn" style="flex: 1;">Everything</button>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem;" id="eraserModeDesc">
                            Erases drawn content without touching background
                        </div>
                    </div>

                    <div class="control-row">
                        <label>Color:</label>
                        <input type="color" id="colorPicker" value="#4a7c59" onchange="updateColor(this.value)">
                    </div>
                    <div class="control-row">
                        <label>Size:</label>
                        <input type="range" class="slider" id="sizeSlider" min="1" max="30" value="8" oninput="setSize(this.value)" style="flex: 1;">
                        <span id="sizeValue">8px</span>
                    </div>

                    <canvas id="mapCanvas" width="400" height="400"></canvas>

                    <div class="btn-group">
                        <input type="file" id="mapImport" accept="image/*" style="display: none;" onchange="importMapImage(event)">
                        <input type="file" id="imageImport" accept="image/*" style="display: none;" onchange="importImageToCanvas(event)">
                        <button class="btn" onclick="document.getElementById('imageImport').click()">üñºÔ∏è Place Image</button>
                        <button class="btn btn-primary" onclick="submitCell()">‚úì Submit</button>
                        <button class="btn" onclick="clearMapCanvas()">Clear</button>
                    </div>
                    
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-dim); padding: 0.5rem; background: var(--bg-dark); border-radius: 6px;">
                        üí° <strong>Place Image:</strong> Upload images to main canvas - they can be moved, resized & rotated! Use Select tool (üëÜ) to manipulate them.
                    </div>
                </div>

                <!-- FOG OF WAR -->
                <div class="section" id="fogSection">
                    <h3>üå´Ô∏è Fog of War</h3>
                    
                    <button class="btn btn-primary" onclick="toggleFogMode()" id="fogModeToggle" style="width: 100%; margin-bottom: 1rem; transition: all 0.3s;">
                        üå´Ô∏è Fog Paint Mode: OFF
                    </button>
                    
                    <div id="fogControls" style="opacity: 0.5; pointer-events: none; transition: all 0.3s;">
                        <div class="fog-groups" id="fogGroups">
                            <div class="fog-group-item active">
                                <span class="fog-group-name">Everyone</span>
                                <button class="btn btn-small btn-primary" onclick="setActiveFogGroup('everyone')">Active</button>
                            </div>
                        </div>

                        <button class="btn" onclick="showFogGroupModal()" style="width: 100%; margin-bottom: 0.75rem;">+ New Group</button>

                        <div style="margin-bottom: 0.75rem;">
                            <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">Fog Paint Mode:</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <button class="btn btn-small btn-primary" onclick="setFogPaintMode('brush')" id="fogBrushBtn">üñåÔ∏è Brush</button>
                                <button class="btn btn-small" onclick="setFogPaintMode('rect')" id="fogRectBtn">‚ñ≠ Rectangle</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Brush Size:</label>
                            <input type="range" class="slider" id="fogSize" min="20" max="150" value="60" oninput="updateFogSize(this.value)" style="flex: 1;">
                            <span id="fogSizeValue">60px</span>
                        </div>

                        <div class="control-row">
                            <label>
                                <input type="checkbox" id="revealMode" checked> Reveal Fog
                            </label>
                        </div>

                        <div class="btn-group">
                            <button class="btn" onclick="resetFog()">Reset All Fog</button>
                        </div>
                        
                        <div style="margin-top: 0.75rem; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; font-size: 0.75rem; color: var(--text-dim);">
                            üí° Hold Ctrl + Click on the map to paint fog
                        </div>
                    </div>
                </div>

                <!-- TOKENS -->
                <div class="section" id="tokenSection">
                    <h3>üé≤ Tokens</h3>
                    
                    <div class="control-row">
                        <label>
                            <input type="checkbox" id="gridSnap" onchange="toggleGridSnap()" checked> Grid Snap (25px)
                        </label>
                    </div>

                    <button class="btn btn-primary" onclick="showTokenModal()" style="width: 100%;">+ Create Token</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MINIMAP NAVIGATOR -->
    <div class="minimap-container" id="minimapContainer">
        <div class="minimap" id="minimap">
            <div class="minimap-header">
                <div class="minimap-title">üó∫Ô∏è Navigator</div>
                <div class="minimap-controls">
                    <div class="minimap-btn" onclick="toggleMinimapCollapse()" title="Collapse">‚àí</div>
                    <div class="minimap-btn" onclick="toggleMinimapDock()" title="Lock/Unlock" id="dockBtn">üîì</div>
                </div>
            </div>
            <div class="minimap-content">
                <div class="minimap-grid" id="minimapGrid"></div>
                <div class="minimap-actions">
                    <div class="minimap-action-btn" onclick="recenterView()">‚äô Center</div>
                    <div class="minimap-action-btn" onclick="resetZoom()">üîç Reset</div>
                </div>
            </div>
        </div>
    </div>

    <!-- STAMP LIBRARY PANEL -->
    <div class="minimap-container" id="stampLibraryContainer" style="display: none; left: 220px; cursor: move;">
        <div class="minimap" id="stampLibraryPanel" style="width: 280px;">
            <div class="minimap-header">
                <div class="minimap-title">üìö Stamp Library</div>
                <div class="minimap-controls">
                    <div class="minimap-btn" onclick="toggleStampLibraryCollapse()" title="Collapse" id="stampCollapseBtn">‚àí</div>
                    <div class="minimap-btn" onclick="toggleStampLibraryDock()" title="Lock/Unlock" id="stampDockBtn">üîì</div>
                    <div class="minimap-btn" onclick="closeStampLibrary()" title="Close">‚úï</div>
                </div>
            </div>
            <div class="minimap-content" id="stampLibraryContent">
                <!-- Nature & Terrain -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">üå≤ Nature & Terrain</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('üå≤')" style="padding: 0.5rem; font-size: 1.5rem;">üå≤</div>
                        <div class="tool-btn" onclick="selectStamp('üå≥')" style="padding: 0.5rem; font-size: 1.5rem;">üå≥</div>
                        <div class="tool-btn" onclick="selectStamp('üå¥')" style="padding: 0.5rem; font-size: 1.5rem;">üå¥</div>
                        <div class="tool-btn" onclick="selectStamp('üåø')" style="padding: 0.5rem; font-size: 1.5rem;">üåø</div>
                        <div class="tool-btn" onclick="selectStamp('üçÉ')" style="padding: 0.5rem; font-size: 1.5rem;">üçÉ</div>
                        <div class="tool-btn" onclick="selectStamp('‚õ∞Ô∏è')" style="padding: 0.5rem; font-size: 1.5rem;">‚õ∞Ô∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üèîÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üèîÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üóª')" style="padding: 0.5rem; font-size: 1.5rem;">üóª</div>
                        <div class="tool-btn" onclick="selectStamp('üèûÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üèûÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üåä')" style="padding: 0.5rem; font-size: 1.5rem;">üåä</div>
                    </div>
                </div>
                
                <!-- Buildings & Structures -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">üè∞ Buildings</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('üè∞')" style="padding: 0.5rem; font-size: 1.5rem;">üè∞</div>
                        <div class="tool-btn" onclick="selectStamp('üèõÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üèõÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üïå')" style="padding: 0.5rem; font-size: 1.5rem;">üïå</div>
                        <div class="tool-btn" onclick="selectStamp('‚õ™')" style="padding: 0.5rem; font-size: 1.5rem;">‚õ™</div>
                        <div class="tool-btn" onclick="selectStamp('üèöÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üèöÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üè†')" style="padding: 0.5rem; font-size: 1.5rem;">üè†</div>
                        <div class="tool-btn" onclick="selectStamp('üè°')" style="padding: 0.5rem; font-size: 1.5rem;">üè°</div>
                        <div class="tool-btn" onclick="selectStamp('üèòÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üèòÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('‚õ∫')" style="padding: 0.5rem; font-size: 1.5rem;">‚õ∫</div>
                        <div class="tool-btn" onclick="selectStamp('üóø')" style="padding: 0.5rem; font-size: 1.5rem;">üóø</div>
                    </div>
                </div>
                
                <!-- Items & Objects -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">‚öîÔ∏è Items</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('‚öîÔ∏è')" style="padding: 0.5rem; font-size: 1.5rem;">‚öîÔ∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üó°Ô∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üó°Ô∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üõ°Ô∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üõ°Ô∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üèπ')" style="padding: 0.5rem; font-size: 1.5rem;">üèπ</div>
                        <div class="tool-btn" onclick="selectStamp('ü™ì')" style="padding: 0.5rem; font-size: 1.5rem;">ü™ì</div>
                        <div class="tool-btn" onclick="selectStamp('üî•')" style="padding: 0.5rem; font-size: 1.5rem;">üî•</div>
                        <div class="tool-btn" onclick="selectStamp('üíé')" style="padding: 0.5rem; font-size: 1.5rem;">üíé</div>
                        <div class="tool-btn" onclick="selectStamp('üëë')" style="padding: 0.5rem; font-size: 1.5rem;">üëë</div>
                        <div class="tool-btn" onclick="selectStamp('üìú')" style="padding: 0.5rem; font-size: 1.5rem;">üìú</div>
                        <div class="tool-btn" onclick="selectStamp('ü™ô')" style="padding: 0.5rem; font-size: 1.5rem;">ü™ô</div>
                    </div>
                </div>
                
                <!-- Creatures & Monsters -->
                <div>
                    <div style="font-size: 0.75rem; color: var(--gold); margin-bottom: 0.5rem; font-weight: 600;">üêâ Creatures</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                        <div class="tool-btn" onclick="selectStamp('üêâ')" style="padding: 0.5rem; font-size: 1.5rem;">üêâ</div>
                        <div class="tool-btn" onclick="selectStamp('üßô')" style="padding: 0.5rem; font-size: 1.5rem;">üßô</div>
                        <div class="tool-btn" onclick="selectStamp('üßõ')" style="padding: 0.5rem; font-size: 1.5rem;">üßõ</div>
                        <div class="tool-btn" onclick="selectStamp('üßü')" style="padding: 0.5rem; font-size: 1.5rem;">üßü</div>
                        <div class="tool-btn" onclick="selectStamp('üëª')" style="padding: 0.5rem; font-size: 1.5rem;">üëª</div>
                        <div class="tool-btn" onclick="selectStamp('ü¶á')" style="padding: 0.5rem; font-size: 1.5rem;">ü¶á</div>
                        <div class="tool-btn" onclick="selectStamp('üï∑Ô∏è')" style="padding: 0.5rem; font-size: 1.5rem;">üï∑Ô∏è</div>
                        <div class="tool-btn" onclick="selectStamp('üê∫')" style="padding: 0.5rem; font-size: 1.5rem;">üê∫</div>
                        <div class="tool-btn" onclick="selectStamp('ü¶Ö')" style="padding: 0.5rem; font-size: 1.5rem;">ü¶Ö</div>
                        <div class="tool-btn" onclick="selectStamp('üêç')" style="padding: 0.5rem; font-size: 1.5rem;">üêç</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- PLAYER PANEL (Dockable) -->
    <div class="minimap-container" id="playerPanelContainer" style="display: none; right: 20px; bottom: 20px; left: auto; cursor: move;">
        <div class="minimap" id="playerPanelDock" style="width: 240px;">
            <div class="minimap-header">
                <div class="minimap-title">üë§ Player Actions</div>
                <div class="minimap-controls">
                    <div class="minimap-btn" onclick="togglePlayerPanelCollapse()" title="Collapse" id="playerCollapseBtn">‚àí</div>
                    <div class="minimap-btn" onclick="togglePlayerPanelDock()" title="Lock/Unlock" id="playerDockBtn">üîì</div>
                </div>
            </div>
            <div class="minimap-content" id="playerPanelContent">
                <button class="btn btn-primary" onclick="showPlayerTokenModal()" style="width: 100%; margin-bottom: 0.75rem;">+ Create My Token</button>
                
                <div style="padding-top: 0.75rem; border-top: 1px solid var(--border);">
                    <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.5rem;">My Token Size:</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <button class="btn btn-small" onclick="adjustPlayerTokenSize(-2)" style="flex: 0;">‚àí</button>
                        <input type="range" class="slider" id="playerTokenSize" min="8" max="30" value="12" oninput="updatePlayerTokenSize(this.value)" style="flex: 1;">
                        <button class="btn btn-small" onclick="adjustPlayerTokenSize(2)" style="flex: 0;">+</button>
                    </div>
                    <div style="text-align: center; font-size: 0.75rem; color: var(--text-dim); margin-top: 0.25rem;">
                        Size: <span id="playerTokenSizeValue">12</span>px
                    </div>
                    <div style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.5rem; text-align: center;">
                        üí° 12px fits perfectly in one grid square
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- PLAYER TOKEN MODAL -->
    <div class="modal" id="playerTokenModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-icon">üé≤</div>
                <div class="modal-title">Request Token</div>
            </div>
            <div class="form-group">
                <label>TOKEN TYPE</label>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <button class="btn btn-primary" onclick="setPlayerTokenType('emoji')" id="playerEmojiTokenBtn" style="flex: 1;">Emoji</button>
                    <button class="btn" onclick="setPlayerTokenType('image')" id="playerImageTokenBtn" style="flex: 1;">Image</button>
                </div>
            </div>
            <div id="playerEmojiTokenInputs">
                <div class="form-group">
                    <label>TOKEN EMOJI</label>
                    <input type="text" id="playerTokenEmoji" placeholder="‚öîÔ∏è" maxlength="2">
                </div>
            </div>
            <div id="playerImageTokenInputs" style="display: none;">
                <div class="form-group">
                    <label>TOKEN IMAGE</label>
                    <input type="file" id="playerTokenImageFile" accept="image/*" style="width: 100%; padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text);">
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-dim);">Upload PNG, JPG, or GIF</div>
                </div>
            </div>
            <div class="form-group">
                <label>TOKEN COLOR</label>
                <input type="color" id="playerTokenColor" value="#3b82f6">
            </div>
            <div class="info">Your token will be sent to the DM for approval</div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="requestPlayerToken()" style="flex: 1;">Request Token</button>
                <button class="btn" onclick="closePlayerTokenModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        console.clear();
        console.log('%cüéÆ THE FRACTURED SKY VTT v4.0 FINAL', 'font-size: 24px; font-weight: bold; color: #8b5cf6; background: #1a1f2e; padding: 10px;');
        console.log('%c‚úÖ JavaScript Loading...', 'font-size: 16px; color: #10b981;');
        console.log('%cBuild: 1770523324', 'font-size: 14px; color: #fbbf24;');
        console.log('%cTime:', 'font-weight: bold;', new Date().toLocaleTimeString());
        console.log('%c--- If you see this, JavaScript is working! ---', 'color: #10b981; font-weight: bold;');

        // === CORE STATE ===
        let peer = null;
        let isDM = false;
        let myId = null;
        let myName = null;
        let roomCode = null;
        let connections = new Map();
        let savedPeerId = null; // For DM session persistence

        // === FIREBASE ===
        const firebaseConfig = {
            apiKey: "AIzaSyDDl5BjZUW-RmT6MG_z9MTsfdedK75fSrc",
            authDomain: "ddddd-f276d.firebaseapp.com",
            projectId: "ddddd-f276d",
            storageBucket: "ddddd-f276d.firebasestorage.app",
            messagingSenderId: "260370337802",
            appId: "1:260370337802:web:e7310129ef9533de4b8ff3",
            measurementId: "G-4X38GGZZ3S"
        };
        firebase.initializeApp(firebaseConfig);
        // Firestore ‚Äî rules already cover vtt_rooms/{roomId} for any auth'd user
        const fbDb = firebase.firestore();
        let firebaseUser = null;
        let firebaseSaveTimeout = null;
        let firebaseRoomRef = null; // set to roomCode string once DM opens room

        async function firebaseSignIn() {
            try {
                const result = await firebase.auth().signInAnonymously();
                firebaseUser = result.user;
                console.log('üî• Firebase signed in:', firebaseUser.uid);
            } catch (err) {
                console.error('üî• Firebase auth error:', err);
                updateFirebaseStatus('‚ö†Ô∏è Auth failed', '#ef4444');
            }
        }

        // Firestore has a 1MB document limit, so we split state across
        // sibling documents ‚Äî all matched by the {roomId} wildcard in your rules.
        // Main doc:  vtt_rooms/{roomId}           ‚Üí tokens, zoom, pan, lockedCells
        // Cell docs: vtt_rooms/{roomId}__cell_X_Y ‚Üí one canvas dataURL per grid cell
        // Fog docs:  vtt_rooms/{roomId}__fog_NAME ‚Üí one canvas dataURL per fog group
        // Image doc: vtt_rooms/{roomId}__images   ‚Üí placed image list

        function scheduleSave() {
            if (!isDM || !firebaseRoomRef || !firebaseUser) return;
            clearTimeout(firebaseSaveTimeout);
            updateFirebaseStatus('‚òÅÔ∏è Unsaved...', '#fbbf24');
            firebaseSaveTimeout = setTimeout(saveToFirebase, 3000);
        }

        async function saveToFirebase() {
            if (!isDM || !firebaseRoomRef || !firebaseUser) return;
            try {
                updateFirebaseStatus('‚òÅÔ∏è Saving...', '#fbbf24');
                const col = fbDb.collection('vtt_rooms');
                const batch = fbDb.batch();

                // Main document ‚Äî lightweight state
                batch.set(col.doc(firebaseRoomRef), {
                    tokens: [...stagingTokens, ...placedTokens],
                    lockedCells,
                    zoom, panX, panY,
                    fogGroupNames: Object.keys(fogGroups),
                    savedAt: Date.now()
                });

                // One document per grid cell
                for (const key in gridCells) {
                    const safeKey = key.replace(',', '_');
                    batch.set(col.doc(firebaseRoomRef + '__cell_' + safeKey), {
                        data: gridCells[key].toDataURL()
                    });
                }

                // One document per fog group
                for (const group in fogGroups) {
                    const safeGroup = group.replace(/[^a-zA-Z0-9_-]/g, '_');
                    batch.set(col.doc(firebaseRoomRef + '__fog_' + safeGroup), {
                        name: group,
                        data: fogGroups[group].canvas.toDataURL()
                    });
                }

                // Placed images
                const imagesData = placedImages.map(pi => ({
                    src: pi.img.src,
                    x: pi.x, y: pi.y,
                    width: pi.width, height: pi.height,
                    rotation: pi.rotation,
                    gridX: pi.gridX, gridY: pi.gridY
                }));
                batch.set(col.doc(firebaseRoomRef + '__images'), { images: imagesData });

                await batch.commit();
                updateFirebaseStatus('‚òÅÔ∏è Saved', '#10b981');
                console.log('üî• Saved to Firestore');
            } catch (err) {
                console.error('üî• Firebase save error:', err);
                updateFirebaseStatus('‚ö†Ô∏è Save failed', '#ef4444');
            }
        }

        async function loadFromFirebase(roomId) {
            try {
                updateFirebaseStatus('‚òÅÔ∏è Loading...', '#fbbf24');
                const col = fbDb.collection('vtt_rooms');
                const mainSnap = await col.doc(roomId).get();

                if (!mainSnap.exists) {
                    updateFirebaseStatus('‚òÅÔ∏è New room', '#9ca3af');
                    console.log('üî• No saved state ‚Äî starting fresh');
                    return;
                }

                const main = mainSnap.data();

                // Load all 9 possible grid cells
                const gridData = {};
                const cellFetches = [];
                for (let cy = 0; cy < 3; cy++) {
                    for (let cx = 0; cx < 3; cx++) {
                        const key = `${cx},${cy}`;
                        const safeKey = `${cx}_${cy}`;
                        cellFetches.push(
                            col.doc(roomId + '__cell_' + safeKey).get().then(snap => {
                                if (snap.exists) gridData[key] = snap.data().data;
                            })
                        );
                    }
                }

                // Load fog groups
                const fogData = {};
                const fogNames = main.fogGroupNames || ['everyone'];
                const fogFetches = fogNames.map(name => {
                    const safeGroup = name.replace(/[^a-zA-Z0-9_-]/g, '_');
                    return col.doc(roomId + '__fog_' + safeGroup).get().then(snap => {
                        if (snap.exists) fogData[snap.data().name] = snap.data().data;
                    });
                });

                // Load placed images
                const imagesSnap = await col.doc(roomId + '__images').get();
                const imagesData = imagesSnap.exists ? imagesSnap.data().images : [];

                await Promise.all([...cellFetches, ...fogFetches]);

                loadGameState({
                    tokens: main.tokens || [],
                    lockedCells: main.lockedCells || {},
                    zoom: main.zoom || 1,
                    panX: main.panX || 0,
                    panY: main.panY || 0,
                    gridCells: gridData,
                    fogGroups: fogData,
                    placedImages: imagesData
                });

                updateFirebaseStatus('‚òÅÔ∏è Loaded', '#10b981');
                console.log('üî• Loaded from Firestore');
            } catch (err) {
                console.error('üî• Firebase load error:', err);
                updateFirebaseStatus('‚ö†Ô∏è Load failed', '#ef4444');
            }
        }

        function updateFirebaseStatus(text, color) {
            const header = document.getElementById('firebaseStatus');
            const panel = document.getElementById('firebaseStatusPanel');
            if (header) { header.textContent = text; header.style.color = color; header.style.display = 'inline'; }
            if (panel) { panel.textContent = text; panel.style.color = color; }
        }

        // Game state
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let gridSnapEnabled = true;
        const GRID_SNAP_SIZE = 25;
        const GRID_SIZE = 400;
        const CELL_SIZE = 400;

        // Map builder
        let currentCellX = 1;
        let currentCellY = 1;
        let gridCells = {};
        let lockedCells = {};
        let tool = 'brush';
        let color = '#4a7c59';
        let size = 8;
        let currentAsset = 'Brush';
        let lastToolBeforeEraser = 'brush'; // Track tool before eraser
        let eraserMode = 'content'; // 'content' or 'all'
        let currentStamp = 'üè∞';
        let tokenType = 'emoji'; // 'emoji' or 'image'
        let tokenImageData = null;
        
        // Image layer for DM
        let placedImages = []; // { img, x, y, width, height, rotation, gridX, gridY }
        let selectedImage = null;
        let imageResizeHandle = null; // 'nw', 'ne', 'sw', 'se', 'rotate'
        let imageDragStart = null;
        
        // History tracking
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // Drawing state
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Tokens
        let stagingTokens = [];
        let placedTokens = [];
        let draggedToken = null;
        let draggedPlacedToken = null; // For moving tokens already on the map
        let tokenDragOffset = { x: 0, y: 0 };

        // Fog
        let activeFogGroup = 'everyone';
        let fogGroups = { everyone: { name: 'Everyone', canvas: null } };
        let fogMode = false;
        let fogPaintMode = 'brush'; // 'brush' or 'rect'
        let fogBrushSize = 60;
        let fogRectStart = null;
        let isFogDrawing = false;
        let dmFogOpacity = 0.3; // DM sees through fog
        let fogBroadcastTimeout = null; // For throttling broadcasts

        // Player requests
        let pendingRequests = [];

        // Minimap
        let minimapDocked = false;
        let minimapDragOffset = null;

        const gridNames = [
            ['Top-Left', 'Top-Center', 'Top-Right'],
            ['Middle-Left', 'Center', 'Middle-Right'],
            ['Bottom-Left', 'Bottom-Center', 'Bottom-Right']
        ];

        // Canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');

        // Initialize fog canvases
        for (let group in fogGroups) {
            const fogCanvas = document.createElement('canvas');
            fogCanvas.width = GRID_SIZE * 3;
            fogCanvas.height = GRID_SIZE * 3;
            const fogCtx = fogCanvas.getContext('2d');
            fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Full opacity black fog
            fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
            fogGroups[group].canvas = fogCanvas;
        }

        // === INITIALIZATION ===
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Cleanly destroy the peer on page unload so PeerJS server
            // releases the ID immediately ‚Äî makes DM refresh reclaim instant.
            window.addEventListener('beforeunload', () => {
                if (peer && !peer.destroyed) peer.destroy();
            });
            
            mapCtx.fillStyle = '#f5f5dc';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            
            updateGridDisplay();
            updateMinimap();
            saveHistory();
            
            // Close DM panel when double-clicking outside
            document.addEventListener('dblclick', (e) => {
                if (!isDM) return;
                const panel = document.getElementById('dmPanel');
                if (!panel.contains(e.target) && panel.classList.contains('open')) {
                    toggleDMPanel();
                    deselectAllTools();
                }
            });

            console.log('‚úÖ VTT Ready!');
        }

        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            panX = (canvas.width - GRID_SIZE * 3) / 2;
            panY = (canvas.height - GRID_SIZE * 3) / 2;
            draw();
        }

        // === AUTHENTICATION ===
        function showDMLogin() {
            console.log('üé≠ showDMLogin called');
            // Pre-fill session ID from localStorage if available
            const savedSession = localStorage.getItem('fracturedSkySessionId');
            if (savedSession) {
                document.getElementById('sessionId').value = savedSession;
            }
            const modal = document.getElementById('dmModal');
            console.log('DM Modal element:', modal);
            
            // Force display with both class and inline styles
            modal.classList.add('active');
            modal.style.display = 'flex';
            modal.style.opacity = '1';
            modal.style.visibility = 'visible';
            modal.style.pointerEvents = 'all';
            
            console.log('DM Modal classes:', modal.className);
            console.log('DM Modal display:', modal.style.display);
            
            // Debug computed styles
            setTimeout(() => {
                const computed = window.getComputedStyle(modal);
                console.log('Modal computed opacity:', computed.opacity);
                console.log('Modal computed visibility:', computed.visibility);
                console.log('Modal computed z-index:', computed.zIndex);
                console.log('Modal computed display:', computed.display);
                console.log('Modal computed pointer-events:', computed.pointerEvents);
            }, 100);
        }

        function closeDMModal() {
            console.log('closeDMModal called');
            const modal = document.getElementById('dmModal');
            modal.classList.remove('active');
            modal.style.display = 'none';
            document.getElementById('dmError').classList.remove('show');
            document.getElementById('dmInfo').style.display = 'none';
        }

        function dmLogin(e) {
            e.preventDefault();
            console.log('dmLogin called');
            const user = document.getElementById('dmUser').value;
            const pass = document.getElementById('dmPass').value;
            const sessionId = document.getElementById('sessionId').value.trim();
            
            // Changed password to avoid security warnings
            if (user === 'Wizard' && pass === 'FracturedSky2025!') {
                closeDMModal();
                
                if (sessionId) {
                    // Rejoin existing session
                    savedPeerId = sessionId;
                    createRoom(sessionId);
                } else {
                    // Create new session
                    createRoom();
                }
            } else {
                document.getElementById('dmError').classList.add('show');
            }
        }

        function showPlayerLogin() {
            console.log('üë§ showPlayerLogin called');
            const modal = document.getElementById('playerModal');
            console.log('Player Modal element:', modal);
            
            // Force display with both class and inline styles
            modal.classList.add('active');
            modal.style.display = 'flex';
            modal.style.opacity = '1';
            modal.style.visibility = 'visible';
            modal.style.pointerEvents = 'all';
            
            console.log('Player Modal classes:', modal.className);
            console.log('Player Modal display:', modal.style.display);
        }

        function closePlayerModal() {
            const modal = document.getElementById('playerModal');
            modal.classList.remove('active');
            modal.style.display = 'none';
            document.getElementById('playerError').classList.remove('show');
            document.getElementById('playerSuccess').classList.remove('show');
        }

        function playerLogin(e) {
            e.preventDefault();
            myName = document.getElementById('playerName').value;
            const code = document.getElementById('roomCodeInput').value.trim();
            
            peer = new Peer();
            peer.on('open', (id) => {
                myId = id;
                const conn = peer.connect(code);
                
                setupConnection(conn, true);
                
                conn.on('open', () => {
                    // Send join request
                    sendToPeer(conn, {
                        type: 'playerJoinRequest',
                        name: myName,
                        peerId: myId
                    });
                    
                    document.getElementById('playerSuccess').classList.add('show');
                    
                    setTimeout(() => {
                        closePlayerModal();
                        document.getElementById('welcomeScreen').classList.add('hidden');
                        document.getElementById('connectionTabContainer').style.display = 'block';
                        updateConnectionStatus('Waiting for approval...', false);
                    }, 2000);
                });
                
                conn.on('error', (err) => {
                    document.getElementById('playerError').textContent = 'Connection failed: ' + err.type;
                    document.getElementById('playerError').classList.add('show');
                });
            });
        }

        // === MULTIPLAYER ===
        function createRoom(existingId = null) {
            console.log('üé≠ createRoom called with existingId:', existingId);
            isDM = true;
            myName = 'Dungeon Master';
            
            // Use existing peer ID if provided
            if (existingId) {
                console.log('Creating peer with existing ID:', existingId);
                peer = new Peer(existingId);
            } else {
                console.log('Creating peer with new ID');
                peer = new Peer();
            }
            
            console.log('Peer object created:', peer);
            
            peer.on('open', (id) => {
                console.log('‚úÖ Peer connection opened! ID:', id);
                myId = id;
                roomCode = id;
                savedPeerId = id;
                
                // Save to localStorage for easy recovery
                localStorage.setItem('fracturedSkySessionId', id);
                console.log('üíæ Saved session ID to localStorage');
                
                document.getElementById('welcomeScreen').classList.add('hidden');
                document.getElementById('connectionTabContainer').style.display = 'block';
                document.getElementById('roomCodeSection').style.display = 'block';
                document.getElementById('roomCode').textContent = roomCode;
                document.getElementById('dmControlsBtn').style.display = 'block';
                document.getElementById('stagingZone').style.display = 'flex';
                
                console.log('UI updated, calling updateConnectionStatus');
                updateConnectionStatus('Connected as DM', true);
                updateUserList();
                loadSavedCloudLink();
                
                // Show success if rejoining
                if (existingId) {
                    alert('‚úÖ Rejoined session: ' + id.substring(0, 12) + '...');
                }
                
                toggleConnectionPanel();
                setTimeout(() => {
                    if (document.getElementById('connectionPanel').classList.contains('open')) {
                        toggleConnectionPanel();
                    }
                }, 5000);
                
                console.log('‚úÖ createRoom complete!');

                // Firebase: sign in then load persisted state for this room
                document.getElementById('firebaseSection').style.display = 'block';
                document.getElementById('firebaseStatus').style.display = 'inline';
                firebaseSignIn().then(() => {
                    firebaseRoomRef = roomCode; // used as Firestore document ID
                    loadFromFirebase(roomCode);
                });
            });
            
            peer.on('connection', (conn) => {
                console.log('üë• Incoming connection from:', conn.peer);
                setupConnection(conn);
            });
            
            peer.on('error', (err) => {
                console.error('‚ùå Peer error:', err);
                console.error('Error type:', err.type);
                console.error('Error message:', err.message);

                if (err.type === 'unavailable-id') {
                    // ID still held by PeerJS server after page refresh.
                    // Retry claiming it ‚Äî server releases it within a few seconds
                    // once the old WebSocket closes.
                    const targetId = existingId;
                    let attempts = 0;
                    const maxAttempts = 8;
                    updateConnectionStatus('Reclaiming session...', false);

                    function retryClaimId() {
                        attempts++;
                        console.log(`üîÑ Retrying peer ID claim (${attempts}/${maxAttempts})...`);
                        if (peer) { try { peer.destroy(); } catch(e) {} }

                        peer = new Peer(targetId);
                        peer.on('open', (id) => {
                            console.log('‚úÖ Reclaimed peer ID:', id);
                            myId = id;
                            roomCode = id;
                            savedPeerId = id;
                            localStorage.setItem('fracturedSkySessionId', id);
                            document.getElementById('welcomeScreen').classList.add('hidden');
                            document.getElementById('connectionTabContainer').style.display = 'block';
                            document.getElementById('roomCodeSection').style.display = 'block';
                            document.getElementById('roomCode').textContent = roomCode;
                            document.getElementById('dmControlsBtn').style.display = 'block';
                            document.getElementById('stagingZone').style.display = 'flex';
                            updateConnectionStatus('Reconnected as DM', true);
                            updateUserList();
                            loadSavedCloudLink();
                            toggleConnectionPanel();
                            setTimeout(() => {
                                if (document.getElementById('connectionPanel').classList.contains('open')) {
                                    toggleConnectionPanel();
                                }
                            }, 5000);
                            document.getElementById('firebaseSection').style.display = 'block';
                            document.getElementById('firebaseStatus').style.display = 'inline';
                            firebaseSignIn().then(() => {
                                firebaseRoomRef = roomCode;
                                loadFromFirebase(roomCode);
                            });
                            // Re-attach connection listener on the new peer object
                            peer.on('connection', (conn) => {
                                console.log('üë• Incoming connection from:', conn.peer);
                                setupConnection(conn);
                            });
                            peer.on('error', (e) => console.error('Peer error after reclaim:', e));
                        });
                        peer.on('error', (e) => {
                            if (e.type === 'unavailable-id' && attempts < maxAttempts) {
                                const delay = Math.min(2000 * attempts, 10000);
                                console.log(`‚è≥ Still unavailable, retrying in ${delay}ms...`);
                                updateConnectionStatus(`Reclaiming... (${attempts}/${maxAttempts})`, false);
                                setTimeout(retryClaimId, delay);
                            } else {
                                console.error('‚ùå Could not reclaim peer ID after', attempts, 'attempts');
                                alert('‚ö†Ô∏è Could not reclaim your session. Starting a new one ‚Äî players will need to reconnect.');
                                createRoom();
                            }
                        });
                    }

                    const initialDelay = 2000;
                    console.log(`‚è≥ Waiting ${initialDelay}ms before first retry...`);
                    setTimeout(retryClaimId, initialDelay);
                } else if (err.type === 'network') {
                    alert('‚ö†Ô∏è Network error. Check your internet connection.');
                } else if (err.type === 'peer-unavailable') {
                    alert('‚ö†Ô∏è Could not connect to PeerJS server. Try again.');
                } else {
                    alert('‚ùå Connection error: ' + err.type + ' - ' + err.message);
                }
            });
            
            console.log('Peer event listeners set up');
        }

        function setupConnection(conn, isPlayer = false) {
            conn.on('data', (data) => handleMessage(conn, data));
            
            conn.on('open', () => {
                if (!isPlayer) {
                    connections.set(conn.peer, { conn, name: 'Unknown', role: 'player', approved: false });
                } else {
                    connections.set(conn.peer, { conn, name: 'Dungeon Master', role: 'dm', approved: true });
                }
                updateUserList();
            });
            
            conn.on('close', () => {
                connections.delete(conn.peer);
                updateUserList();
            });
        }

        function handleMessage(conn, data) {
            console.log('Message received:', data.type);
            
            switch (data.type) {
                case 'playerJoinRequest':
                    if (isDM) {
                        pendingRequests.push({
                            peerId: conn.peer,
                            name: data.name,
                            conn: conn
                        });
                        renderPendingRequests();
                    }
                    break;
                    
                case 'playerApproved':
                    myName = data.name;
                    updateConnectionStatus('Approved! Connected to room', true);
                    requestGameState(conn);
                    // Show player panel (dockable)
                    document.getElementById('playerPanelContainer').style.display = 'block';
                    
                    // Auto-restore player state from localStorage
                    const playerStateKey = 'fracturedSky_player_' + roomCode + '_' + myName;
                    const savedState = localStorage.getItem(playerStateKey);
                    if (savedState) {
                        try {
                            const state = JSON.parse(savedState);
                            console.log('‚úÖ Restored player state for:', myName);
                            console.log('Last session:', new Date(state.lastSeen).toLocaleString());
                            // Player tokens are managed by DM, so we just log the restore
                        } catch (err) {
                            console.error('Failed to restore player state:', err);
                        }
                    }
                    
                    // Save current player state
                    savePlayerState();
                    break;
                    
                case 'playerRejected':
                    alert('Your join request was denied by the DM.');
                    break;
                    
                case 'tokenRequest':
                    if (isDM) {
                        // Add to pending requests
                        pendingRequests.push({
                            type: 'token',
                            peerId: conn.peer,
                            name: data.playerName,
                            tokenData: data.tokenData,
                            conn: conn
                        });
                        renderPendingRequests();
                    }
                    break;
                    
                case 'tokenApproved':
                    // Token was approved, add to staging
                    stagingTokens.push(data.token);
                    renderStagingTokens();
                    break;
                    
                case 'gameState':
                    loadGameState(data.state);
                    break;
                    
                case 'gridUpdate':
                    updateGridFromNetwork(data);
                    break;
                    
                case 'tokenUpdate':
                    // Separate staging and placed tokens
                    stagingTokens = [];
                    placedTokens = [];
                    
                    data.tokens.forEach(token => {
                        if (token.x !== undefined && token.y !== undefined) {
                            // Has position = placed token
                            placedTokens.push(token);
                        } else {
                            // No position = staging token
                            stagingTokens.push(token);
                        }
                    });
                    
                    console.log('üé≤ Token update:', stagingTokens.length, 'staging,', placedTokens.length, 'placed');
                    renderStagingTokens();
                    draw();
                    break;
                    
                case 'fogUpdate':
                    updateFogFromNetwork(data);
                    break;
                    
                case 'imagesUpdate':
                    // Load images from network
                    placedImages = [];
                    data.images.forEach(imgData => {
                        const img = new Image();
                        img.onload = () => {
                            placedImages.push({
                                img: img,
                                x: imgData.x,
                                y: imgData.y,
                                width: imgData.width,
                                height: imgData.height,
                                rotation: imgData.rotation,
                                gridX: imgData.gridX,
                                gridY: imgData.gridY
                            });
                            draw();
                        };
                        img.src = imgData.src;
                    });
                    break;
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Delete selected image
            if (e.key === 'Delete' && selectedImage && isDM) {
                const index = placedImages.indexOf(selectedImage);
                if (index > -1) {
                    placedImages.splice(index, 1);
                    selectedImage = null;
                    draw();
                    broadcastImages();
                }
            }
        });

        function sendToPeer(conn, data) {
            try {
                conn.send(data);
            } catch (err) {
                console.error('Send error:', err);
            }
        }

        function broadcast(data) {
            connections.forEach(({ conn, approved }) => {
                if (approved) sendToPeer(conn, data);
            });
            scheduleSave();
        }

        function approvePlayer(index) {
            const request = pendingRequests[index];
            if (!request || request.type === 'token') return;
            
            const connData = connections.get(request.peerId);
            if (connData) {
                connData.approved = true;
                connData.name = request.name;
                
                sendToPeer(request.conn, {
                    type: 'playerApproved',
                    name: request.name
                });
                
                sendGameState(request.conn);
            }
            
            pendingRequests.splice(index, 1);
            renderPendingRequests();
            updateUserList();
        }

        function rejectPlayer(index) {
            const request = pendingRequests[index];
            if (!request || request.type === 'token') return;
            
            sendToPeer(request.conn, { type: 'playerRejected' });
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function approveToken(index) {
            const request = pendingRequests[index];
            if (!request || request.type !== 'token') return;
            
            const token = {
                ...request.tokenData,
                owner: request.name,
                approved: true
            };
            
            stagingTokens.push(token);
            renderStagingTokens();
            
            sendToPeer(request.conn, {
                type: 'tokenApproved',
                token: token
            });
            
            broadcast({
                type: 'tokenUpdate',
                tokens: [...stagingTokens, ...placedTokens]
            });
            
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function rejectToken(index) {
            pendingRequests.splice(index, 1);
            renderPendingRequests();
        }

        function renderPendingRequests() {
            const container = document.getElementById('pendingRequests');
            
            if (pendingRequests.length === 0) {
                container.innerHTML = '<p style="font-size: 0.85rem; color: var(--text-dim);">No pending requests</p>';
                return;
            }
            
            container.innerHTML = pendingRequests.map((req, idx) => {
                if (req.type === 'token') {
                    return `
                        <div class="request-item">
                            <div class="request-info">
                                <div class="request-name">${req.name}</div>
                                <div class="request-detail">Token: ${req.tokenData.icon}</div>
                            </div>
                            <div class="request-actions">
                                <button class="btn btn-small btn-success" onclick="approveToken(${idx})">‚úì</button>
                                <button class="btn btn-small btn-danger" onclick="rejectToken(${idx})">‚úï</button>
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="request-item">
                            <div class="request-info">
                                <div class="request-name">${req.name}</div>
                                <div class="request-detail">Wants to join</div>
                            </div>
                            <div class="request-actions">
                                <button class="btn btn-small btn-success" onclick="approvePlayer(${idx})">‚úì</button>
                                <button class="btn btn-small btn-danger" onclick="rejectPlayer(${idx})">‚úï</button>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }

        function sendGameState(conn) {
            const gridData = {};
            for (let key in gridCells) {
                gridData[key] = gridCells[key].toDataURL();
            }
            
            const fogData = {};
            for (let group in fogGroups) {
                fogData[group] = fogGroups[group].canvas.toDataURL();
            }
            
            // Serialize placed images
            const imagesData = placedImages.map(pi => ({
                src: pi.img.src,
                x: pi.x,
                y: pi.y,
                width: pi.width,
                height: pi.height,
                rotation: pi.rotation,
                gridX: pi.gridX,
                gridY: pi.gridY
            }));
            
            sendToPeer(conn, {
                type: 'gameState',
                state: {
                    gridCells: gridData,
                    lockedCells,
                    fogGroups: fogData,
                    tokens: [...stagingTokens, ...placedTokens],
                    placedImages: imagesData,
                    zoom,
                    panX,
                    panY
                }
            });
            
            console.log('üì§ Sent game state:', stagingTokens.length + placedTokens.length, 'tokens,', imagesData.length, 'images');
        }

        function requestGameState(conn) {
            sendToPeer(conn, { type: 'requestState' });
        }

        function loadGameState(state) {
            console.log('üì• Loading game state...');
            
            // Load grid
            gridCells = {};
            for (let key in state.gridCells) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = CELL_SIZE;
                    canvas.height = CELL_SIZE;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    gridCells[key] = canvas;
                    draw();
                };
                img.src = state.gridCells[key];
            }
            
            // Load fog
            for (let group in state.fogGroups) {
                if (!fogGroups[group]) {
                    fogGroups[group] = { name: group, canvas: document.createElement('canvas') };
                    fogGroups[group].canvas.width = GRID_SIZE * 3;
                    fogGroups[group].canvas.height = GRID_SIZE * 3;
                }
                const img = new Image();
                img.onload = () => {
                    const ctx = fogGroups[group].canvas.getContext('2d');
                    ctx.clearRect(0, 0, fogGroups[group].canvas.width, fogGroups[group].canvas.height);
                    ctx.drawImage(img, 0, 0);
                    draw();
                };
                img.src = state.fogGroups[group];
            }
            
            // Load tokens (IMPORTANT!)
            if (state.tokens) {
                stagingTokens = [];
                placedTokens = [];
                
                state.tokens.forEach(token => {
                    // Separate staging vs placed tokens
                    if (token.x !== undefined && token.y !== undefined) {
                        // It's a placed token
                        placedTokens.push(token);
                    } else {
                        // It's a staging token
                        stagingTokens.push(token);
                    }
                });
                
                console.log('‚úÖ Loaded tokens:', stagingTokens.length, 'staging,', placedTokens.length, 'placed');
                renderStagingTokens();
            }
            
            // Load placed images if present
            if (state.placedImages) {
                placedImages = [];
                state.placedImages.forEach(imgData => {
                    const img = new Image();
                    img.onload = () => {
                        placedImages.push({
                            img: img,
                            x: imgData.x,
                            y: imgData.y,
                            width: imgData.width,
                            height: imgData.height,
                            rotation: imgData.rotation,
                            gridX: imgData.gridX,
                            gridY: imgData.gridY
                        });
                        draw();
                    };
                    img.src = imgData.src;
                });
            }
            
            lockedCells = state.lockedCells || {};
            zoom = state.zoom || 1;
            panX = state.panX || 0;
            panY = state.panY || 0;
            
            document.getElementById('zoomSlider').value = zoom * 100;
            document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
            
            draw();
            updateMinimap();
        }

        function updateGridFromNetwork(data) {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = CELL_SIZE;
                canvas.height = CELL_SIZE;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                gridCells[`${data.cellX},${data.cellY}`] = canvas;
                draw();
                updateMinimap();
            };
            img.src = data.imageData;
        }

        function updateFogFromNetwork(data) {
            console.log('üå´Ô∏è Received fog update for group:', data.group);
            if (fogGroups[data.group]) {
                const img = new Image();
                img.onload = () => {
                    const ctx = fogGroups[data.group].canvas.getContext('2d');
                    ctx.clearRect(0, 0, fogGroups[data.group].canvas.width, fogGroups[data.group].canvas.height);
                    ctx.drawImage(img, 0, 0);
                    draw();
                    console.log('‚úÖ Fog updated on canvas');
                };
                img.onerror = () => {
                    console.error('‚ùå Failed to load fog image');
                };
                img.src = data.fogData;
            } else {
                console.warn('‚ö†Ô∏è Fog group not found:', data.group);
            }
        }

        function toggleConnectionPanel() {
            const panel = document.getElementById('connectionPanel');
            const tab = document.getElementById('connectionTab');
            const arrow = document.getElementById('tabArrow');
            
            if (panel.classList.contains('open')) {
                panel.classList.remove('open');
                tab.classList.remove('open');
                arrow.textContent = '‚ñº';
            } else {
                panel.classList.add('open');
                tab.classList.add('open');
                arrow.textContent = '‚ñ≤';
            }
        }

        function updateConnectionStatus(text, connected) {
            document.getElementById('statusText').textContent = text;
            const indicators = [document.getElementById('statusIndicator'), document.getElementById('tabIndicator')];
            indicators.forEach(ind => {
                if (connected) ind.classList.add('connected');
                else ind.classList.remove('connected');
            });
        }

        function updateUserList() {
            const container = document.getElementById('userList');
            const users = [];
            
            if (isDM) users.push({ name: myName, role: 'DM' });
            
            connections.forEach(({ name, role, approved }) => {
                if (approved) {
                    users.push({ name, role: role === 'dm' ? 'DM' : 'Player' });
                }
            });
            
            if (users.length === 0) {
                container.innerHTML = '<p style="font-size: 0.85rem; color: var(--text-dim);">No users</p>';
                return;
            }
            
            container.innerHTML = users.map(u => `
                <div class="user-item">
                    <span>${u.name}</span>
                    <span class="user-role">${u.role}</span>
                </div>
            `).join('');
        }

        function copyRoomCode() {
            if (!roomCode) {
                console.error('No room code to copy');
                return;
            }
            
            // Try modern clipboard API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(roomCode).then(() => {
                    const elem = document.getElementById('roomCode');
                    const old = elem.textContent;
                    elem.textContent = '‚úì Copied!';
                    elem.style.background = 'var(--accent)';
                    elem.style.color = 'white';
                    setTimeout(() => {
                        elem.textContent = old;
                        elem.style.background = 'var(--bg-dark)';
                        elem.style.color = 'var(--accent)';
                    }, 2000);
                    console.log('‚úÖ Room code copied:', roomCode);
                }).catch(err => {
                    console.error('Clipboard API failed:', err);
                    fallbackCopy();
                });
            } else {
                // Fallback for older browsers
                fallbackCopy();
            }
        }
        
        function fallbackCopy() {
            try {
                // Create temporary textarea
                const textarea = document.createElement('textarea');
                textarea.value = roomCode;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                const elem = document.getElementById('roomCode');
                const old = elem.textContent;
                elem.textContent = '‚úì Copied!';
                elem.style.background = 'var(--accent)';
                elem.style.color = 'white';
                setTimeout(() => {
                    elem.textContent = old;
                    elem.style.background = 'var(--bg-dark)';
                    elem.style.color = 'var(--accent)';
                }, 2000);
                console.log('‚úÖ Room code copied (fallback):', roomCode);
            } catch (err) {
                console.error('Copy failed:', err);
                alert('Could not copy. Room code: ' + roomCode);
            }
        }

        // === TOKENS ===
        function showTokenModal() {
            document.getElementById('tokenRequestModal').classList.add('active');
            setTokenType('emoji'); // Default to emoji
        }

        function closeTokenModal() {
            document.getElementById('tokenRequestModal').classList.remove('active');
            tokenImageData = null;
        }

        function setTokenType(type) {
            tokenType = type;
            
            document.getElementById('emojiTokenBtn').classList.remove('btn-primary');
            document.getElementById('imageTokenBtn').classList.remove('btn-primary');
            
            if (type === 'emoji') {
                document.getElementById('emojiTokenBtn').classList.add('btn-primary');
                document.getElementById('emojiTokenInputs').style.display = 'block';
                document.getElementById('imageTokenInputs').style.display = 'none';
            } else {
                document.getElementById('imageTokenBtn').classList.add('btn-primary');
                document.getElementById('emojiTokenInputs').style.display = 'none';
                document.getElementById('imageTokenInputs').style.display = 'block';
            }
        }

        function createToken() {
            const color = document.getElementById('tokenColor').value;
            
            if (tokenType === 'emoji') {
                const emoji = document.getElementById('tokenEmoji').value || '‚öîÔ∏è';
                
                if (isDM) {
                    const token = {
                        id: Date.now(),
                        type: 'emoji',
                        icon: emoji,
                        color: color,
                        size: 12, // Default size (fits in single grid square)
                        owner: 'DM',
                        approved: true
                    };
                    
                    stagingTokens.push(token);
                    renderStagingTokens();
                    closeTokenModal();
                    
                    broadcast({
                        type: 'tokenUpdate',
                        tokens: [...stagingTokens, ...placedTokens]
                    });
                }
            } else {
                // Image token
                const file = document.getElementById('tokenImageFile').files[0];
                if (!file) {
                    alert('Please select an image file');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    if (isDM) {
                        const token = {
                            id: Date.now(),
                            type: 'image',
                            imageData: e.target.result,
                            color: color,
                            size: 12, // Default size (fits in single grid square)
                            owner: 'DM',
                            approved: true
                        };
                        
                        stagingTokens.push(token);
                        renderStagingTokens();
                        closeTokenModal();
                        
                        broadcast({
                            type: 'tokenUpdate',
                            tokens: [...stagingTokens, ...placedTokens]
                        });
                    }
                };
                reader.readAsDataURL(file);
            }
        }

        function renderStagingTokens() {
            const container = document.getElementById('stagingTokens');
            container.innerHTML = stagingTokens.map(t => {
                if (t.type === 'image') {
                    return `
                        <div class="token-item" draggable="true" ondragstart="dragTokenStart(event, ${t.id})" style="background: ${t.color}; background-image: url('${t.imageData}'); background-size: cover; background-position: center;">
                            <div class="token-owner">${t.owner}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="token-item" draggable="true" ondragstart="dragTokenStart(event, ${t.id})" style="background: ${t.color};">
                            ${t.icon}
                            <div class="token-owner">${t.owner}</div>
                        </div>
                    `;
                }
            }).join('');
            
            if (stagingTokens.length > 0) {
                document.getElementById('stagingZone').style.display = 'flex';
            }
        }

        function dragTokenStart(e, tokenId) {
            const token = stagingTokens.find(t => t.id === tokenId);
            e.dataTransfer.setData('application/json', JSON.stringify(token));
            draggedToken = token;
        }

        function toggleGridSnap() {
            gridSnapEnabled = document.getElementById('gridSnap').checked;
        }

        function snapToGrid(value) {
            if (!gridSnapEnabled) return value;
            // Snap to center of grid squares instead of intersections
            // Grid squares are GRID_SNAP_SIZE x GRID_SNAP_SIZE
            // Centers are at 12.5, 37.5, 62.5, etc. (GRID_SNAP_SIZE / 2 + n * GRID_SNAP_SIZE)
            const gridCenter = GRID_SNAP_SIZE / 2;
            return Math.round((value - gridCenter) / GRID_SNAP_SIZE) * GRID_SNAP_SIZE + gridCenter;
        }

        // === DRAWING ===
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);

            // Grid cells
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const x = col * GRID_SIZE;
                    const y = row * GRID_SIZE;
                    const key = `${col},${row}`;
                    
                    ctx.fillStyle = '#1a1f2e';
                    ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                    
                    if (gridCells[key]) {
                        ctx.drawImage(gridCells[key], x, y, GRID_SIZE, GRID_SIZE);
                    }
                    
                    ctx.strokeStyle = '#2a2f3e';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                    
                    if (col === currentCellX && row === currentCellY && isDM) {
                        ctx.strokeStyle = lockedCells[key] ? '#fbbf24' : '#8b5cf6';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                    }
                }
            }

            // Grid snap lines
            if (gridSnapEnabled) {
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.15)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= GRID_SIZE * 3; x += GRID_SNAP_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, GRID_SIZE * 3);
                    ctx.stroke();
                }
                for (let y = 0; y <= GRID_SIZE * 3; y += GRID_SNAP_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(GRID_SIZE * 3, y);
                    ctx.stroke();
                }
            }

            // Placed images (DM layer)
            placedImages.forEach(pi => {
                ctx.save();
                ctx.translate(pi.x + pi.width / 2, pi.y + pi.height / 2);
                ctx.rotate(pi.rotation * Math.PI / 180);
                ctx.drawImage(pi.img, -pi.width / 2, -pi.height / 2, pi.width, pi.height);
                ctx.restore();
                
                // Draw selection handles if selected
                if (isDM && selectedImage === pi) {
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(pi.x, pi.y, pi.width, pi.height);
                    ctx.setLineDash([]);
                    
                    // Corner handles for resize
                    const handleSize = 8;
                    ctx.fillStyle = '#8b5cf6';
                    ctx.fillRect(pi.x - handleSize/2, pi.y - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(pi.x + pi.width - handleSize/2, pi.y - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(pi.x - handleSize/2, pi.y + pi.height - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(pi.x + pi.width - handleSize/2, pi.y + pi.height - handleSize/2, handleSize, handleSize);
                    
                    // Rotation handle
                    ctx.beginPath();
                    ctx.arc(pi.x + pi.width / 2, pi.y - 20, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fill();
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });

            // Placed tokens
            placedTokens.forEach(t => {
                const tokenSize = t.size || 12; // Default to 12px (fits in 25px grid square)
                const borderWidth = Math.max(2, tokenSize / 6); // Proportional border
                const fontSize = Math.max(12, tokenSize * 1.5); // Proportional font
                
                ctx.fillStyle = t.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, tokenSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = borderWidth;
                ctx.stroke();
                
                if (t.type === 'image' && t.imageData) {
                    // Draw image token
                    const img = new Image();
                    img.src = t.imageData;
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, tokenSize - 1, 0, Math.PI * 2);
                    ctx.clip();
                    const imgSize = (tokenSize - 1) * 2;
                    ctx.drawImage(img, t.x - (tokenSize - 1), t.y - (tokenSize - 1), imgSize, imgSize);
                    ctx.restore();
                } else {
                    // Draw emoji token
                    ctx.fillStyle = '#fff';
                    ctx.font = `${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(t.icon || '‚öîÔ∏è', t.x, t.y);
                }
            });

            ctx.restore();

            // Fog - FULLY OPAQUE for players, semi-transparent for DM
            if (fogGroups[activeFogGroup]) {
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoom, zoom);
                
                // DM sees through fog, players see full black
                if (isDM) {
                    ctx.globalAlpha = dmFogOpacity;
                } else {
                    ctx.globalAlpha = 1.0; // Full opacity for players
                }
                
                ctx.drawImage(fogGroups[activeFogGroup].canvas, 0, 0, GRID_SIZE * 3, GRID_SIZE * 3);
                ctx.restore();
            }

            updateMinimap();
        }

        // === MAP BUILDER ===
        function selectCell(x, y) {
            if (!isDM) return;
            currentCellX = x;
            currentCellY = y;
            
            const key = `${x},${y}`;
            if (gridCells[key]) {
                mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                mapCtx.drawImage(gridCells[key], 0, 0);
            } else {
                mapCtx.fillStyle = '#f5f5dc';
                mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            }
            
            updateGridDisplay();
            draw();
        }

        function updateGridDisplay() {
            document.getElementById('currentCell').textContent = gridNames[currentCellY][currentCellX];
        }

        function setTool(t) {
            // Track last tool before switching to eraser
            if (tool !== 'eraser' && t === 'eraser') {
                lastToolBeforeEraser = tool;
                // Show eraser options
                document.getElementById('eraserOptions').style.display = 'block';
                updateEraserModeUI();
            } else if (t !== 'eraser') {
                // Hide eraser options
                document.getElementById('eraserOptions').style.display = 'none';
            }
            
            // Show/hide stamp library toggle
            if (t === 'stamp') {
                document.getElementById('stampLibraryToggle').style.display = 'block';
            } else {
                document.getElementById('stampLibraryToggle').style.display = 'none';
            }
            
            // Deselect image when switching tools
            if (t !== 'select') {
                selectedImage = null;
                draw();
            }
            
            tool = t;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const toolBtn = document.getElementById(t + 'Btn');
            if (toolBtn) toolBtn.classList.add('active');
            
            const assetNames = {
                brush: 'Brush',
                fill: 'Fill',
                stamp: 'Stamp: ' + currentStamp,
                image: 'Place Image',
                select: 'Select & Move',
                eraser: eraserMode === 'content' ? 
                       (lastToolBeforeEraser === 'brush' ? 'Brush Strokes' : 
                        lastToolBeforeEraser === 'fill' ? 'Fill Areas' :
                        lastToolBeforeEraser === 'stamp' ? 'Stamps' : 'Content') :
                       'Everything'
            };
            currentAsset = assetNames[t] || t;
            document.getElementById('currentAsset').textContent = currentAsset;
        }

        function selectStamp(emoji) {
            currentStamp = emoji;
            currentAsset = 'Stamp: ' + emoji;
            document.getElementById('currentAsset').textContent = currentAsset;
            setTool('stamp'); // Ensure stamp tool is active
        }

        // Stamp library docking
        let stampLibraryDocked = false;
        let stampLibraryDragOffset = null;

        function toggleStampLibrary() {
            const panel = document.getElementById('stampLibraryContainer');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function closeStampLibrary() {
            document.getElementById('stampLibraryContainer').style.display = 'none';
        }

        function toggleStampLibraryCollapse() {
            document.getElementById('stampLibraryPanel').classList.toggle('collapsed');
            const btn = document.getElementById('stampCollapseBtn');
            btn.textContent = document.getElementById('stampLibraryPanel').classList.contains('collapsed') ? '+' : '‚àí';
        }

        function toggleStampLibraryDock() {
            stampLibraryDocked = !stampLibraryDocked;
            const container = document.getElementById('stampLibraryContainer');
            const btn = document.getElementById('stampDockBtn');
            
            if (stampLibraryDocked) {
                container.style.cursor = 'default';
                btn.textContent = 'üîí';
            } else {
                container.style.cursor = 'move';
                btn.textContent = 'üîì';
            }
        }

        // Stamp library dragging
        const stampLibraryContainer = document.getElementById('stampLibraryContainer');
        stampLibraryContainer.addEventListener('mousedown', (e) => {
            if (stampLibraryDocked) return;
            if (e.target.closest('.minimap-btn') || e.target.closest('.tool-btn')) return;
            
            stampLibraryDragOffset = {
                x: e.clientX - stampLibraryContainer.offsetLeft,
                y: e.clientY - stampLibraryContainer.offsetTop
            };
        });

        document.addEventListener('mousemove', (e) => {
            if (!stampLibraryDragOffset || stampLibraryDocked) return;
            
            stampLibraryContainer.style.left = (e.clientX - stampLibraryDragOffset.x) + 'px';
            stampLibraryContainer.style.top = (e.clientY - stampLibraryDragOffset.y) + 'px';
            stampLibraryContainer.style.bottom = 'auto';
        });

        document.addEventListener('mouseup', () => {
            if (stampLibraryDragOffset) {
                stampLibraryDragOffset = null;
            }
        });

        // Player token functions
        let playerTokenType = 'emoji';

        function showPlayerTokenModal() {
            document.getElementById('playerTokenModal').classList.add('active');
            setPlayerTokenType('emoji');
        }

        function closePlayerTokenModal() {
            document.getElementById('playerTokenModal').classList.remove('active');
        }

        function setPlayerTokenType(type) {
            playerTokenType = type;
            
            document.getElementById('playerEmojiTokenBtn').classList.remove('btn-primary');
            document.getElementById('playerImageTokenBtn').classList.remove('btn-primary');
            
            if (type === 'emoji') {
                document.getElementById('playerEmojiTokenBtn').classList.add('btn-primary');
                document.getElementById('playerEmojiTokenInputs').style.display = 'block';
                document.getElementById('playerImageTokenInputs').style.display = 'none';
            } else {
                document.getElementById('playerImageTokenBtn').classList.add('btn-primary');
                document.getElementById('playerEmojiTokenInputs').style.display = 'none';
                document.getElementById('playerImageTokenInputs').style.display = 'block';
            }
        }

        function requestPlayerToken() {
            const color = document.getElementById('playerTokenColor').value;
            
            if (playerTokenType === 'emoji') {
                const emoji = document.getElementById('playerTokenEmoji').value || '‚öîÔ∏è';
                
                connections.forEach(({ conn, role }) => {
                    if (role === 'dm') {
                        sendToPeer(conn, {
                            type: 'tokenRequest',
                            playerName: myName,
                            tokenData: {
                                id: Date.now(),
                                type: 'emoji',
                                icon: emoji,
                                color: color,
                                size: 12 // Default size
                            }
                        });
                    }
                });
                
                closePlayerTokenModal();
                alert('‚úÖ Token request sent to DM for approval!');
            } else {
                // Image token
                const file = document.getElementById('playerTokenImageFile').files[0];
                if (!file) {
                    alert('Please select an image file');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    connections.forEach(({ conn, role }) => {
                        if (role === 'dm') {
                            sendToPeer(conn, {
                                type: 'tokenRequest',
                                playerName: myName,
                                tokenData: {
                                    id: Date.now(),
                                    type: 'image',
                                    imageData: e.target.result,
                                    color: color,
                                    size: 12 // Default size
                                }
                            });
                        }
                    });
                    
                    closePlayerTokenModal();
                    alert('‚úÖ Token request sent to DM for approval!');
                };
                reader.readAsDataURL(file);
            }
        }

        function setStamp(emoji) {
            currentStamp = emoji;
            currentAsset = 'Stamp: ' + emoji;
            document.getElementById('currentAsset').textContent = currentAsset;
        }

        function updateColor(value) {
            color = value;
        }

        function importMapImage(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    mapCtx.drawImage(img, 0, 0, mapCanvas.width, mapCanvas.height);
                    saveHistory();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function importImageToCanvas(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Place image at center of current cell
                    const cellX = currentCellX * GRID_SIZE + GRID_SIZE / 2;
                    const cellY = currentCellY * GRID_SIZE + GRID_SIZE / 2;
                    
                    // Scale image to fit within cell
                    const maxSize = GRID_SIZE * 0.8;
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > maxSize || height > maxSize) {
                        const scale = Math.min(maxSize / width, maxSize / height);
                        width *= scale;
                        height *= scale;
                    }
                    
                    const placedImg = {
                        img: img,
                        x: cellX - width / 2,
                        y: cellY - height / 2,
                        width: width,
                        height: height,
                        rotation: 0,
                        gridX: currentCellX,
                        gridY: currentCellY
                    };
                    
                    placedImages.push(placedImg);
                    selectedImage = placedImg;
                    setTool('select');
                    draw();
                    
                    // Broadcast to players
                    broadcastImages();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function broadcastImages() {
            const imageData = placedImages.map(pi => ({
                src: pi.img.src,
                x: pi.x,
                y: pi.y,
                width: pi.width,
                height: pi.height,
                rotation: pi.rotation,
                gridX: pi.gridX,
                gridY: pi.gridY
            }));
            
            broadcast({
                type: 'imagesUpdate',
                images: imageData
            });
        }

        function setEraserMode(mode) {
            eraserMode = mode;
            updateEraserModeUI();
            
            // Update asset indicator
            if (tool === 'eraser') {
                const assetNames = {
                    content: lastToolBeforeEraser === 'brush' ? 'Brush Strokes' : 
                             lastToolBeforeEraser === 'texture' ? 'Textures' : 
                             lastToolBeforeEraser === 'image' ? 'Images' : 'Content',
                    all: 'Everything'
                };
                currentAsset = assetNames[mode];
                document.getElementById('currentAsset').textContent = currentAsset;
            }
        }

        function updateEraserModeUI() {
            // Update button states
            document.getElementById('eraseContentBtn').classList.remove('btn-primary');
            document.getElementById('eraseAllBtn').classList.remove('btn-primary');
            
            if (eraserMode === 'content') {
                document.getElementById('eraseContentBtn').classList.add('btn-primary');
                document.getElementById('eraserModeDesc').textContent = 'Erases drawn content without touching background';
            } else {
                document.getElementById('eraseAllBtn').classList.add('btn-primary');
                document.getElementById('eraserModeDesc').textContent = 'Erases everything including background color';
            }
        }

        function setSize(v) {
            size = v;
            document.getElementById('sizeValue').textContent = v + 'px';
        }

        function saveHistory() {
            const imageData = mapCtx.getImageData(0, 0, mapCanvas.width, mapCanvas.height);
            
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            history.push(imageData);
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
            
            updateHistoryButtons();
            scheduleSave();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                mapCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                mapCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
        }

        function clearMapCanvas() {
            mapCtx.fillStyle = '#f5f5dc';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            saveHistory();
        }

        function submitCell() {
            const key = `${currentCellX},${currentCellY}`;
            const cellCanvas = document.createElement('canvas');
            cellCanvas.width = CELL_SIZE;
            cellCanvas.height = CELL_SIZE;
            const cellCtx = cellCanvas.getContext('2d');
            cellCtx.drawImage(mapCanvas, 0, 0);
            gridCells[key] = cellCanvas;
            
            draw();
            
            broadcast({
                type: 'gridUpdate',
                cellX: currentCellX,
                cellY: currentCellY,
                imageData: cellCanvas.toDataURL()
            });
        }

        function deselectAllTools() {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            tool = null;
            currentAsset = 'None';
            document.getElementById('currentAsset').textContent = currentAsset;
        }

        // Map canvas drawing
        mapCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = mapCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
            lastX = x;
            lastY = y;
            
            if (tool === 'brush') {
                mapCtx.beginPath();
                mapCtx.moveTo(x, y);
                mapCtx.strokeStyle = color;
                mapCtx.lineWidth = size;
                mapCtx.lineCap = 'round';
                mapCtx.lineJoin = 'round';
            } else if (tool === 'fill') {
                mapCtx.fillStyle = color;
                mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
                saveHistory();
                isDrawing = false;
            } else if (tool === 'stamp') {
                mapCtx.font = '48px Arial';
                mapCtx.textAlign = 'center';
                mapCtx.textBaseline = 'middle';
                mapCtx.fillText(currentStamp, x, y);
                saveHistory();
                isDrawing = false;
            } else if (tool === 'eraser') {
                mapCtx.save();
                
                if (eraserMode === 'content') {
                    // Erase only drawn content, not background
                    mapCtx.globalCompositeOperation = 'destination-out';
                    mapCtx.strokeStyle = 'rgba(0,0,0,1)';
                } else {
                    // Erase everything including background
                    mapCtx.globalCompositeOperation = 'source-over';
                    mapCtx.strokeStyle = '#f5f5dc'; // Match background color
                }
                
                mapCtx.beginPath();
                mapCtx.moveTo(x, y);
                mapCtx.lineWidth = size;
                mapCtx.lineCap = 'round';
                mapCtx.lineJoin = 'round';
            }
        });

        mapCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = mapCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
            
            if (tool === 'brush' || tool === 'eraser') {
                mapCtx.lineTo(x, y);
                mapCtx.stroke();
            }
        });

        mapCanvas.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                if (tool === 'eraser') {
                    mapCtx.restore(); // Restore composite operation
                }
                saveHistory();
            }
        });

        mapCanvas.addEventListener('mouseleave', () => {
            if (isDrawing) {
                isDrawing = false;
                if (tool === 'eraser') {
                    mapCtx.restore(); // Restore composite operation
                }
                saveHistory();
            }
        });

        document.getElementById('colorPicker').addEventListener('change', (e) => {
            color = e.target.value;
        });

        // Main canvas interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX;
            const screenY = e.clientY;
            const mx = (screenX - rect.left - panX) / zoom;
            const my = (screenY - rect.top - panY) / zoom;
            
            // Check if clicking on a placed token (for moving it)
            if (!fogMode && tool !== 'select') {
                for (let i = placedTokens.length - 1; i >= 0; i--) {
                    const token = placedTokens[i];
                    const tokenSize = token.size || 25;
                    const dist = Math.hypot(mx - token.x, my - token.y);
                    if (dist < tokenSize) {
                        // Check permissions: DM can move any token, players can only move their own
                        if (isDM || token.owner === myName) {
                            draggedPlacedToken = token;
                            tokenDragOffset = { x: mx - token.x, y: my - token.y };
                            console.log('üéØ Selected token:', token.owner, token.icon || 'image');
                            return;
                        } else {
                            console.log('üö´ Cannot move token owned by:', token.owner);
                            return;
                        }
                    }
                }
            }
            
            // Image selection and manipulation (Select tool ONLY)
            if (isDM && tool === 'select') {
                // Check if clicking on rotation handle
                if (selectedImage) {
                    const rotX = selectedImage.x + selectedImage.width / 2;
                    const rotY = selectedImage.y - 20;
                    if (Math.hypot(mx - rotX, my - rotY) < 10) {
                        imageResizeHandle = 'rotate';
                        imageDragStart = { x: mx, y: my };
                        return;
                    }
                    
                    // Check corner handles for resize
                    const handleSize = 8;
                    const handles = [
                        { type: 'nw', x: selectedImage.x, y: selectedImage.y },
                        { type: 'ne', x: selectedImage.x + selectedImage.width, y: selectedImage.y },
                        { type: 'sw', x: selectedImage.x, y: selectedImage.y + selectedImage.height },
                        { type: 'se', x: selectedImage.x + selectedImage.width, y: selectedImage.y + selectedImage.height }
                    ];
                    
                    for (let h of handles) {
                        if (Math.abs(mx - h.x) < handleSize && Math.abs(my - h.y) < handleSize) {
                            imageResizeHandle = h.type;
                            imageDragStart = { x: mx, y: my, origWidth: selectedImage.width, origHeight: selectedImage.height, origX: selectedImage.x, origY: selectedImage.y };
                            return;
                        }
                    }
                }
                
                // Check if clicking on an image
                for (let i = placedImages.length - 1; i >= 0; i--) {
                    const pi = placedImages[i];
                    if (mx >= pi.x && mx <= pi.x + pi.width && my >= pi.y && my <= pi.y + pi.height) {
                        selectedImage = pi;
                        imageDragStart = { x: mx, y: my, imgX: pi.x, imgY: pi.y };
                        draw();
                        return;
                    }
                }
                
                // Clicked empty space - deselect
                selectedImage = null;
                draw();
                return;
            }
            
            // Fog mode painting
            if (isDM && fogMode) {
                isFogDrawing = true;
                
                if (fogPaintMode === 'brush') {
                    paintFog(mx, my);
                } else if (fogPaintMode === 'rect') {
                    fogRectStart = { x: mx, y: my };
                }
                return;
            }
            
            // Normal panning (when not in fog mode and not using select tool)
            lastX = screenX;
            lastY = screenY;
            isDrawing = true;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX;
            const screenY = e.clientY;
            const mx = (screenX - rect.left - panX) / zoom;
            const my = (screenY - rect.top - panY) / zoom;
            
            // Token dragging
            if (draggedPlacedToken) {
                draggedPlacedToken.x = snapToGrid(mx - tokenDragOffset.x);
                draggedPlacedToken.y = snapToGrid(my - tokenDragOffset.y);
                draw();
                return;
            }
            
            // Image manipulation (Select tool only)
            if (isDM && tool === 'select' && selectedImage && imageDragStart) {
                if (imageResizeHandle === 'rotate') {
                    // Rotate around center
                    const centerX = selectedImage.x + selectedImage.width / 2;
                    const centerY = selectedImage.y + selectedImage.height / 2;
                    const angle = Math.atan2(my - centerY, mx - centerX) * 180 / Math.PI + 90;
                    selectedImage.rotation = angle;
                    draw();
                    return;
                } else if (imageResizeHandle) {
                    // Resize
                    const dx = mx - imageDragStart.x;
                    const dy = my - imageDragStart.y;
                    
                    if (imageResizeHandle === 'se') {
                        selectedImage.width = imageDragStart.origWidth + dx;
                        selectedImage.height = imageDragStart.origHeight + dy;
                    } else if (imageResizeHandle === 'nw') {
                        selectedImage.width = imageDragStart.origWidth - dx;
                        selectedImage.height = imageDragStart.origHeight - dy;
                        selectedImage.x = imageDragStart.origX + dx;
                        selectedImage.y = imageDragStart.origY + dy;
                    } else if (imageResizeHandle === 'ne') {
                        selectedImage.width = imageDragStart.origWidth + dx;
                        selectedImage.height = imageDragStart.origHeight - dy;
                        selectedImage.y = imageDragStart.origY + dy;
                    } else if (imageResizeHandle === 'sw') {
                        selectedImage.width = imageDragStart.origWidth - dx;
                        selectedImage.height = imageDragStart.origHeight + dy;
                        selectedImage.x = imageDragStart.origX + dx;
                    }
                    
                    // Minimum size
                    if (selectedImage.width < 50) selectedImage.width = 50;
                    if (selectedImage.height < 50) selectedImage.height = 50;
                    
                    draw();
                    return;
                } else {
                    // Move
                    selectedImage.x = imageDragStart.imgX + (mx - imageDragStart.x);
                    selectedImage.y = imageDragStart.imgY + (my - imageDragStart.y);
                    draw();
                    return;
                }
            }
            
            // Fog painting
            if (isDM && isFogDrawing) {
                if (fogPaintMode === 'brush') {
                    paintFog(mx, my);
                } else if (fogPaintMode === 'rect' && fogRectStart) {
                    // Just update for preview, actual painting on mouseup
                    draw();
                    
                    // Draw preview rectangle
                    ctx.save();
                    const reveal = document.getElementById('revealMode').checked;
                    ctx.strokeStyle = reveal ? '#10b981' : '#ef4444';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 5 / zoom]);
                    ctx.translate(panX, panY);
                    ctx.scale(zoom, zoom);
                    ctx.strokeRect(fogRectStart.x, fogRectStart.y, mx - fogRectStart.x, my - fogRectStart.y);
                    ctx.restore();
                }
                return;
            }
            
            // Normal panning (only when not in fog mode and not dragging anything)
            if (!isDrawing || fogMode || (isDM && tool === 'select') || draggedPlacedToken) return;
            panX += screenX - lastX;
            panY += screenY - lastY;
            lastX = screenX;
            lastY = screenY;
            draw();
        });

        canvas.addEventListener('mouseup', (e) => {
            // Token movement complete - broadcast to all
            if (draggedPlacedToken) {
                console.log('‚úÖ Token moved:', draggedPlacedToken.owner);
                broadcast({
                    type: 'tokenUpdate',
                    tokens: [...stagingTokens, ...placedTokens]
                });
                draggedPlacedToken = null;
                tokenDragOffset = { x: 0, y: 0 };
            }
            
            // Image manipulation complete
            if (imageDragStart) {
                imageDragStart = null;
                imageResizeHandle = null;
                broadcastImages();
            }
            
            if (isFogDrawing && fogPaintMode === 'rect' && fogRectStart) {
                const rect = canvas.getBoundingClientRect();
                const mx = (e.clientX - rect.left - panX) / zoom;
                const my = (e.clientY - rect.top - panY) / zoom;
                
                paintFogRect(fogRectStart.x, fogRectStart.y, mx, my);
                fogRectStart = null;
            }
            
            isFogDrawing = false;
            isDrawing = false;
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!draggedToken) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = snapToGrid((e.clientX - rect.left - panX) / zoom);
            const y = snapToGrid((e.clientY - rect.top - panY) / zoom);
            
            const placedToken = {
                ...draggedToken,
                x,
                y
            };
            
            placedTokens.push(placedToken);
            stagingTokens = stagingTokens.filter(t => t.id !== draggedToken.id);
            
            renderStagingTokens();
            draw();
            
            broadcast({
                type: 'tokenUpdate',
                tokens: [...stagingTokens, ...placedTokens]
            });
            
            draggedToken = null;
        });

        // === FOG ===
        function showFogGroupModal() {
            document.getElementById('fogGroupModal').classList.add('active');
        }

        function closeFogGroupModal() {
            document.getElementById('fogGroupModal').classList.remove('active');
        }

        function createFogGroup() {
            const name = document.getElementById('fogGroupName').value.trim();
            if (!name) return;
            
            const id = 'group_' + Date.now();
            const fogCanvas = document.createElement('canvas');
            fogCanvas.width = GRID_SIZE * 3;
            fogCanvas.height = GRID_SIZE * 3;
            const fogCtx = fogCanvas.getContext('2d');
            fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Full opacity black fog
            fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
            
            fogGroups[id] = { name, canvas: fogCanvas };
            renderFogGroups();
            closeFogGroupModal();
            
            document.getElementById('fogGroupName').value = '';
        }

        function renderFogGroups() {
            const container = document.getElementById('fogGroups');
            container.innerHTML = Object.keys(fogGroups).map(id => `
                <div class="fog-group-item ${activeFogGroup === id ? 'active' : ''}">
                    <span class="fog-group-name">${fogGroups[id].name}</span>
                    <button class="btn btn-small ${activeFogGroup === id ? 'btn-primary' : ''}" onclick="setActiveFogGroup('${id}')">
                        ${activeFogGroup === id ? 'Active' : 'Select'}
                    </button>
                </div>
            `).join('');
        }

        function setActiveFogGroup(groupId) {
            activeFogGroup = groupId;
            renderFogGroups();
            draw();
        }

        function setFogPaintMode(mode) {
            fogPaintMode = mode;
            document.getElementById('fogBrushBtn').classList.remove('btn-primary');
            document.getElementById('fogRectBtn').classList.remove('btn-primary');
            
            if (mode === 'brush') {
                document.getElementById('fogBrushBtn').classList.add('btn-primary');
            } else {
                document.getElementById('fogRectBtn').classList.add('btn-primary');
            }
        }

        function toggleFogMode() {
            if (!isDM) return;
            
            fogMode = !fogMode;
            const btn = document.getElementById('fogModeToggle');
            const controls = document.getElementById('fogControls');
            
            if (fogMode) {
                // FOG MODE ON - Orange button
                btn.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
                btn.style.borderColor = '#f97316';
                btn.textContent = 'üå´Ô∏è Fog Paint Mode: ON';
                controls.style.opacity = '1';
                controls.style.pointerEvents = 'all';
            } else {
                // FOG MODE OFF - Purple button
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.classList.add('btn-primary');
                btn.textContent = 'üå´Ô∏è Fog Paint Mode: OFF';
                controls.style.opacity = '0.5';
                controls.style.pointerEvents = 'none';
            }
        }

        function updateFogSize(value) {
            fogBrushSize = parseInt(value);
            document.getElementById('fogSizeValue').textContent = value + 'px';
        }

        function resetFog() {
            if (!isDM) return;
            if (!confirm('Reset all fog for the active group?')) return;
            
            if (fogGroups[activeFogGroup]) {
                const ctx = fogGroups[activeFogGroup].canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0.9)';
                ctx.fillRect(0, 0, fogGroups[activeFogGroup].canvas.width, fogGroups[activeFogGroup].canvas.height);
                draw();
                
                broadcast({
                    type: 'fogUpdate',
                    group: activeFogGroup,
                    fogData: fogGroups[activeFogGroup].canvas.toDataURL()
                });
            }
        }

        function paintFog(x, y) {
            if (!isDM || !fogGroups[activeFogGroup]) return;
            
            const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
            const reveal = document.getElementById('revealMode').checked;
            
            fogCtx.save();
            
            if (reveal) {
                // Erase fog (reveal map)
                fogCtx.globalCompositeOperation = 'destination-out';
                fogCtx.fillStyle = 'rgba(0,0,0,1)';
            } else {
                // Add fog (hide map)
                fogCtx.globalCompositeOperation = 'source-over';
                fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Changed to full opacity
            }
            
            fogCtx.beginPath();
            fogCtx.arc(x, y, fogBrushSize, 0, Math.PI * 2);
            fogCtx.fill();
            fogCtx.restore();
            
            draw();
            
            // Broadcast fog update in real-time (every brush stroke)
            broadcastFog();
        }

        function paintFogRect(x1, y1, x2, y2) {
            if (!isDM || !fogGroups[activeFogGroup]) return;
            
            const fogCtx = fogGroups[activeFogGroup].canvas.getContext('2d');
            const reveal = document.getElementById('revealMode').checked;
            
            fogCtx.save();
            
            if (reveal) {
                fogCtx.globalCompositeOperation = 'destination-out';
                fogCtx.fillStyle = 'rgba(0,0,0,1)';
            } else {
                fogCtx.globalCompositeOperation = 'source-over';
                fogCtx.fillStyle = 'rgba(0,0,0,1)'; // Changed to full opacity
            }
            
            const width = x2 - x1;
            const height = y2 - y1;
            fogCtx.fillRect(x1, y1, width, height);
            fogCtx.restore();
            
            draw();
            
            // Broadcast fog update
            broadcastFog();
        }

        function broadcastFog() {
            if (!isDM) return;
            
            // Clear any pending broadcast
            if (fogBroadcastTimeout) {
                clearTimeout(fogBroadcastTimeout);
            }
            
            // Throttle broadcasts to every 100ms for smooth real-time updates
            fogBroadcastTimeout = setTimeout(() => {
                const fogData = fogGroups[activeFogGroup].canvas.toDataURL();
                console.log('üì° Broadcasting fog update, size:', fogData.length, 'bytes');
                
                broadcast({
                    type: 'fogUpdate',
                    group: activeFogGroup,
                    fogData: fogData
                });
                
                fogBroadcastTimeout = null;
            }, 100);
        }

        // Initialize fog mode buttons
        setFogPaintMode('brush');

        // === CAMPAIGN EXPORT/IMPORT ===
        function exportCampaign() {
            if (!isDM) return;
            
            // Serialize grid cells
            const gridData = {};
            for (let key in gridCells) {
                gridData[key] = gridCells[key].toDataURL();
            }
            
            // Serialize fog groups
            const fogData = {};
            for (let group in fogGroups) {
                fogData[group] = {
                    name: fogGroups[group].name,
                    canvas: fogGroups[group].canvas.toDataURL()
                };
            }
            
            // Serialize placed images
            const imagesData = placedImages.map(pi => ({
                src: pi.img.src,
                x: pi.x,
                y: pi.y,
                width: pi.width,
                height: pi.height,
                rotation: pi.rotation,
                gridX: pi.gridX,
                gridY: pi.gridY
            }));
            
            // Get player data
            const playerData = [];
            connections.forEach(({ name, role, approved }, peerId) => {
                if (approved) {
                    playerData.push({ name, role, peerId });
                }
            });
            
            const campaignData = {
                version: '4.0',
                name: prompt('Campaign name:', 'My Campaign') || 'Untitled Campaign',
                sessionId: roomCode,
                exported: new Date().toISOString(),
                gridCells: gridData,
                lockedCells: lockedCells,
                fogGroups: fogData,
                activeFogGroup: activeFogGroup,
                stagingTokens: stagingTokens,
                placedTokens: placedTokens,
                placedImages: imagesData,
                playerData: playerData,
                zoom: zoom,
                panX: panX,
                panY: panY,
                currentCellX: currentCellX,
                currentCellY: currentCellY,
                gridSnapEnabled: gridSnapEnabled
            };
            
            // Create downloadable file
            const dataStr = JSON.stringify(campaignData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `${campaignData.name.replace(/[^a-z0-9]/gi, '_')}_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            document.getElementById('exportSuccess').classList.add('show');
            setTimeout(() => {
                document.getElementById('exportSuccess').classList.remove('show');
            }, 3000);
            
            console.log('‚úÖ Campaign exported:', campaignData.name);
            console.log('Includes:', playerData.length, 'players,', stagingTokens.length + placedTokens.length, 'tokens');
        }
        
        function importCampaign(event) {
            if (!isDM) return;
            
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (!data.version || !data.gridCells) {
                        throw new Error('Invalid campaign file format');
                    }
                    
                    // Load grid cells
                    gridCells = {};
                    let cellsLoaded = 0;
                    const totalCells = Object.keys(data.gridCells).length;
                    
                    for (let key in data.gridCells) {
                        const img = new Image();
                        img.onload = () => {
                            const cellCanvas = document.createElement('canvas');
                            cellCanvas.width = CELL_SIZE;
                            cellCanvas.height = CELL_SIZE;
                            const cellCtx = cellCanvas.getContext('2d');
                            cellCtx.drawImage(img, 0, 0);
                            gridCells[key] = cellCanvas;
                            
                            cellsLoaded++;
                            if (cellsLoaded === totalCells) {
                                draw();
                                updateMinimap();
                            }
                        };
                        img.src = data.gridCells[key];
                    }
                    
                    // Load fog groups
                    fogGroups = {};
                    for (let group in data.fogGroups) {
                        const fogCanvas = document.createElement('canvas');
                        fogCanvas.width = GRID_SIZE * 3;
                        fogCanvas.height = GRID_SIZE * 3;
                        const fogCtx = fogCanvas.getContext('2d');
                        
                        const img = new Image();
                        img.onload = () => {
                            fogCtx.drawImage(img, 0, 0);
                            draw();
                            // Broadcast fog to all players
                            broadcastFog();
                        };
                        img.src = data.fogGroups[group].canvas;
                        
                        fogGroups[group] = {
                            name: data.fogGroups[group].name,
                            canvas: fogCanvas
                        };
                    }
                    
                    // Load placed images
                    if (data.placedImages) {
                        placedImages = [];
                        data.placedImages.forEach(imgData => {
                            const img = new Image();
                            img.onload = () => {
                                placedImages.push({
                                    img: img,
                                    x: imgData.x,
                                    y: imgData.y,
                                    width: imgData.width,
                                    height: imgData.height,
                                    rotation: imgData.rotation,
                                    gridX: imgData.gridX,
                                    gridY: imgData.gridY
                                });
                                draw();
                                broadcastImages();
                            };
                            img.src = imgData.src;
                        });
                    }
                    
                    // Load other data
                    lockedCells = data.lockedCells || {};
                    activeFogGroup = data.activeFogGroup || 'everyone';
                    stagingTokens = data.stagingTokens || [];
                    placedTokens = data.placedTokens || [];
                    zoom = data.zoom || 1;
                    panX = data.panX || 0;
                    panY = data.panY || 0;
                    currentCellX = data.currentCellX || 1;
                    currentCellY = data.currentCellY || 1;
                    gridSnapEnabled = data.gridSnapEnabled !== undefined ? data.gridSnapEnabled : true;
                    
                    // Update UI
                    document.getElementById('zoomSlider').value = zoom * 100;
                    document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
                    
                    updateGridDisplay();
                    renderFogGroups();
                    renderStagingTokens();
                    draw();
                    updateMinimap();
                    
                    // Broadcast complete state to all connected players
                    connections.forEach(({conn, approved}) => {
                        if (approved) sendGameState(conn);
                    });
                    
                    document.getElementById('importSuccess').classList.add('show');
                    setTimeout(() => {
                        document.getElementById('importSuccess').classList.remove('show');
                    }, 3000);
                    
                    const playerCount = data.playerData ? data.playerData.length : 0;
                    const tokenCount = stagingTokens.length + placedTokens.length;
                    alert('‚úÖ Campaign imported: ' + (data.name || 'Untitled') + '\n' + 
                          playerCount + ' players, ' + tokenCount + ' tokens loaded');
                    console.log('‚úÖ Campaign imported:', data.name);
                    console.log('Loaded:', playerCount, 'players,', tokenCount, 'tokens');
                    
                } catch (err) {
                    console.error('Import error:', err);
                    document.getElementById('importError').textContent = 'Import failed: ' + err.message;
                    document.getElementById('importError').classList.add('show');
                    setTimeout(() => {
                        document.getElementById('importError').classList.remove('show');
                    }, 5000);
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        function saveCloudLink() {
            if (!isDM) return;
            
            const link = document.getElementById('cloudLink').value.trim();
            if (!link) {
                alert('Please enter a cloud link first');
                return;
            }
            
            // Save to session storage
            const key = 'fracturedSky_cloudLink_' + roomCode;
            localStorage.setItem(key, link);
            
            document.getElementById('linkSuccess').classList.add('show');
            setTimeout(() => {
                document.getElementById('linkSuccess').classList.remove('show');
            }, 3000);
            
            console.log('‚úÖ Cloud link saved for session:', roomCode);
        }
        
        function openCloudLink() {
            const link = document.getElementById('cloudLink').value.trim();
            if (!link) {
                // Try to load saved link
                const key = 'fracturedSky_cloudLink_' + roomCode;
                const saved = localStorage.getItem(key);
                if (saved) {
                    window.open(saved, '_blank');
                } else {
                    alert('No cloud link saved. Paste a link first.');
                }
            } else {
                window.open(link, '_blank');
            }
        }
        
        // Load saved cloud link on DM connect
        function loadSavedCloudLink() {
            if (isDM && roomCode) {
                const key = 'fracturedSky_cloudLink_' + roomCode;
                const saved = localStorage.getItem(key);
                if (saved) {
                    document.getElementById('cloudLink').value = saved;
                }
            }
        }

        function savePlayerState() {
            if (!myName || !roomCode) return;
            
            const playerStateKey = 'fracturedSky_player_' + roomCode + '_' + myName;
            const state = {
                name: myName,
                roomCode: roomCode,
                lastSeen: Date.now(),
                isDM: isDM
            };
            
            localStorage.setItem(playerStateKey, JSON.stringify(state));
        }

        // Save player state periodically
        setInterval(savePlayerState, 60000); // Every minute

        // === PLAYER PANEL DOCKING ===
        let playerPanelDocked = false;
        let playerPanelDragOffset = null;

        function togglePlayerPanelCollapse() {
            document.getElementById('playerPanelDock').classList.toggle('collapsed');
            const btn = document.getElementById('playerCollapseBtn');
            btn.textContent = document.getElementById('playerPanelDock').classList.contains('collapsed') ? '+' : '‚àí';
        }

        function togglePlayerPanelDock() {
            playerPanelDocked = !playerPanelDocked;
            const container = document.getElementById('playerPanelContainer');
            const btn = document.getElementById('playerDockBtn');
            
            if (playerPanelDocked) {
                container.style.cursor = 'default';
                btn.textContent = 'üîí';
            } else {
                container.style.cursor = 'move';
                btn.textContent = 'üîì';
            }
        }

        // Player panel dragging
        const playerPanelContainer = document.getElementById('playerPanelContainer');
        playerPanelContainer.addEventListener('mousedown', (e) => {
            if (playerPanelDocked) return;
            if (e.target.closest('.minimap-btn') || e.target.closest('.btn')) return;
            
            playerPanelDragOffset = {
                x: e.clientX - playerPanelContainer.offsetLeft,
                y: e.clientY - playerPanelContainer.offsetTop
            };
        });

        document.addEventListener('mousemove', (e) => {
            if (!playerPanelDragOffset || playerPanelDocked) return;
            
            playerPanelContainer.style.left = (e.clientX - playerPanelDragOffset.x) + 'px';
            playerPanelContainer.style.top = (e.clientY - playerPanelDragOffset.y) + 'px';
            playerPanelContainer.style.right = 'auto';
            playerPanelContainer.style.bottom = 'auto';
        });

        document.addEventListener('mouseup', () => {
            if (playerPanelDragOffset) {
                playerPanelDragOffset = null;
            }
        });

        // === PLAYER TOKEN SIZE ===
        function updatePlayerTokenSize(value) {
            const size = parseInt(value);
            document.getElementById('playerTokenSizeValue').textContent = size;
            
            // Update all tokens owned by this player
            let updated = false;
            placedTokens.forEach(token => {
                if (token.owner === myName) {
                    token.size = size;
                    updated = true;
                }
            });
            
            if (updated) {
                draw();
                // Broadcast token update
                broadcast({
                    type: 'tokenUpdate',
                    tokens: [...stagingTokens, ...placedTokens]
                });
            }
        }

        function adjustPlayerTokenSize(delta) {
            const slider = document.getElementById('playerTokenSize');
            const newValue = Math.max(8, Math.min(30, parseInt(slider.value) + delta));
            slider.value = newValue;
            updatePlayerTokenSize(newValue);
        }

        // === MINIMAP ===
        function updateMinimap() {
            const grid = document.getElementById('minimapGrid');
            let html = '';
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const key = `${col},${row}`;
                    const classes = ['minimap-cell'];
                    if (gridCells[key]) classes.push('has-content');
                    if (lockedCells[key]) classes.push('locked');
                    if (col === currentCellX && row === currentCellY) classes.push('current');
                    
                    html += `<div class="${classes.join(' ')}" onclick="minimapNavigate(${col}, ${row})"></div>`;
                }
            }
            
            grid.innerHTML = html;
        }

        function minimapNavigate(col, row) {
            const centerX = (col + 0.5) * GRID_SIZE;
            const centerY = (row + 0.5) * GRID_SIZE;
            panX = canvas.width / 2 - centerX * zoom;
            panY = canvas.height / 2 - centerY * zoom;
            draw();
        }

        function recenterView() {
            panX = (canvas.width - GRID_SIZE * 3 * zoom) / 2;
            panY = (canvas.height - GRID_SIZE * 3 * zoom) / 2;
            draw();
        }

        function resetZoom() {
            zoom = 1;
            document.getElementById('zoomSlider').value = 100;
            document.getElementById('zoomValue').textContent = '100%';
            recenterView();
        }

        function setZoom(v) {
            zoom = v / 100;
            document.getElementById('zoomValue').textContent = Math.round(v) + '%';
            draw();
        }

        function toggleMinimapCollapse() {
            document.getElementById('minimap').classList.toggle('collapsed');
        }

        function toggleMinimapDock() {
            minimapDocked = !minimapDocked;
            const container = document.getElementById('minimapContainer');
            const btn = document.getElementById('dockBtn');
            
            if (minimapDocked) {
                container.classList.add('docked');
                btn.textContent = 'üîí';
            } else {
                container.classList.remove('docked');
                btn.textContent = 'üîì';
            }
        }

        // Minimap dragging
        const minimapContainer = document.getElementById('minimapContainer');
        minimapContainer.addEventListener('mousedown', (e) => {
            if (minimapDocked) return;
            if (e.target.closest('.minimap-btn') || e.target.closest('.minimap-cell')) return;
            
            minimapDragOffset = {
                x: e.clientX - minimapContainer.offsetLeft,
                y: e.clientY - minimapContainer.offsetTop
            };
        });

        document.addEventListener('mousemove', (e) => {
            if (!minimapDragOffset || minimapDocked) return;
            
            minimapContainer.style.left = (e.clientX - minimapDragOffset.x) + 'px';
            minimapContainer.style.top = (e.clientY - minimapDragOffset.y) + 'px';
            minimapContainer.style.bottom = 'auto';
        });

        document.addEventListener('mouseup', () => {
            minimapDragOffset = null;
        });

        // === UI ===
        function toggleDMPanel() {
            document.getElementById('dmPanel').classList.toggle('open');
        }

        // Global error handler
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('üö® JavaScript Error:', msg);
            console.error('Line:', lineNo, 'Column:', columnNo);
            console.error('Error object:', error);
            return false;
        };

        // Wrap init in try-catch
        try {
            console.log('Calling init()...');
            init();
            console.log('‚úÖ Init complete, functions should be available');
            console.log('showDMLogin type:', typeof showDMLogin);
            console.log('showPlayerLogin type:', typeof showPlayerLogin);
        } catch (err) {
            console.error('‚ùå Init failed:', err);
            alert('Error loading VTT: ' + err.message);
        }
    </script>
</body>
</html>
